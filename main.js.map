{"mappings":"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","sources":["node_modules/sax/lib/sax.js","node_modules/miniget/dist/index.js","node_modules/miniget/src/index.ts","node_modules/ytdl-core/package.json","node_modules/m3u8stream/dist/m3u8-parser.js","node_modules/m3u8stream/src/m3u8-parser.ts","node_modules/m3u8stream/dist/dash-mpd-parser.js","node_modules/m3u8stream/src/dash-mpd-parser.ts","node_modules/m3u8stream/dist/parse-time.js","node_modules/m3u8stream/src/parse-time.ts","node_modules/fluent-ffmpeg/lib/fluent-ffmpeg.js","node_modules/fluent-ffmpeg/lib/utils.js","node_modules/which/which.js","node_modules/isexe/index.js","node_modules/isexe/windows.js","node_modules/isexe/mode.js","node_modules/fluent-ffmpeg/lib/options/inputs.js","node_modules/fluent-ffmpeg/lib/options/audio.js","node_modules/fluent-ffmpeg/lib/options/video.js","node_modules/fluent-ffmpeg/lib/options/videosize.js","node_modules/fluent-ffmpeg/lib/options/output.js","node_modules/fluent-ffmpeg/lib/options/custom.js","node_modules/fluent-ffmpeg/lib/options/misc.js","node_modules/fluent-ffmpeg/lib/processor.js","node_modules/async/dist/async.mjs","node_modules/fluent-ffmpeg/lib/capabilities.js","node_modules/fluent-ffmpeg/lib/ffprobe.js","node_modules/fluent-ffmpeg/lib/recipes.js","node_modules/dotenv/lib/main.js","node_modules/dotenv/package.json","index.js","node_modules/ytdl-core/lib/index.js","node_modules/ytdl-core/lib/info.js","node_modules/ytdl-core/lib/utils.js","node_modules/ytdl-core/lib/format-utils.js","node_modules/ytdl-core/lib/formats.js","node_modules/ytdl-core/lib/url-utils.js","node_modules/ytdl-core/lib/info-extras.js","node_modules/m3u8stream/dist/index.js","node_modules/m3u8stream/src/index.ts","node_modules/m3u8stream/dist/queue.js","node_modules/m3u8stream/src/queue.ts","node_modules/ytdl-core/lib/sig.js","node_modules/ytdl-core/lib/cache.js","node_modules/fluent-ffmpeg/index.js","node_modules/ffmpeg-on-progress/index.js","node_modules/hh-mm-ss/index.js","node_modules/zero-fill/index.js","Max.js"],"sourcesContent":[";(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'opentagstart',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  var Stream\n  try {\n    Stream = require('stream').Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream (strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream (strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder\n        this._decoder = new SD('utf8')\n      }\n      data = this._decoder.write(data)\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  function isWhitespace (c) {\n    return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t'\n  }\n\n  function isQuote (c) {\n    return c === '\"' || c === '\\''\n  }\n\n  function isAttribEnd (c) {\n    return c === '>' || isWhitespace(c)\n  }\n\n  function isMatch (regex, c) {\n    return regex.test(c)\n  }\n\n  function notMatch (regex, c) {\n    return !isMatch(regex, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line +\n        '\\nColumn: ' + parser.column +\n        '\\nChar: ' + parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n    emitNode(parser, 'onopentagstart', tag)\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function charAt (chunk, i) {\n    var result = ''\n    if (i < chunk.length) {\n      result = chunk.charAt(i)\n    }\n    return result\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    if (typeof chunk === 'object') {\n      chunk = chunk.toString()\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = charAt(chunk, i++)\n      parser.c = c\n\n      if (!c) {\n        break\n      }\n\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = charAt(chunk, i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c\n          if (c === ']') {\n            parser.state = S.DOCTYPE\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (isWhitespace(c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue\n          } else if (isQuote(c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            strictFail(parser, 'Unquoted attribute value')\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            parser[buffer] += parseEntity(parser)\n            parser.entity = ''\n            parser.state = returnState\n          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint)\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xD800\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    }())\n  }\n})(typeof exports === 'undefined' ? this.sax = {} : exports)\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst http_1 = __importDefault(require(\"http\"));\nconst https_1 = __importDefault(require(\"https\"));\nconst stream_1 = require(\"stream\");\nconst httpLibs = { 'http:': http_1.default, 'https:': https_1.default };\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst retryStatusCodes = new Set([429, 503]);\n// `request`, `response`, `abort`, left out, miniget will emit these.\nconst requestEvents = ['connect', 'continue', 'information', 'socket', 'timeout', 'upgrade'];\nconst responseEvents = ['aborted'];\nMiniget.MinigetError = class MinigetError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.statusCode = statusCode;\n    }\n};\nMiniget.defaultOptions = {\n    maxRedirects: 10,\n    maxRetries: 2,\n    maxReconnects: 0,\n    backoff: { inc: 100, max: 10000 },\n};\nfunction Miniget(url, options = {}) {\n    var _a;\n    const opts = Object.assign({}, Miniget.defaultOptions, options);\n    const stream = new stream_1.PassThrough({ highWaterMark: opts.highWaterMark });\n    stream.destroyed = stream.aborted = false;\n    let activeRequest;\n    let activeResponse;\n    let activeDecodedStream;\n    let redirects = 0;\n    let retries = 0;\n    let retryTimeout;\n    let reconnects = 0;\n    let contentLength;\n    let acceptRanges = false;\n    let rangeStart = 0, rangeEnd;\n    let downloaded = 0;\n    // Check if this is a ranged request.\n    if ((_a = opts.headers) === null || _a === void 0 ? void 0 : _a.Range) {\n        let r = /bytes=(\\d+)-(\\d+)?/.exec(`${opts.headers.Range}`);\n        if (r) {\n            rangeStart = parseInt(r[1], 10);\n            rangeEnd = parseInt(r[2], 10);\n        }\n    }\n    // Add `Accept-Encoding` header.\n    if (opts.acceptEncoding) {\n        opts.headers = Object.assign({\n            'Accept-Encoding': Object.keys(opts.acceptEncoding).join(', '),\n        }, opts.headers);\n    }\n    const downloadHasStarted = () => activeDecodedStream && downloaded > 0;\n    const downloadComplete = () => !acceptRanges || downloaded === contentLength;\n    const reconnect = (err) => {\n        activeDecodedStream = null;\n        retries = 0;\n        let inc = opts.backoff.inc;\n        let ms = Math.min(inc, opts.backoff.max);\n        retryTimeout = setTimeout(doDownload, ms);\n        stream.emit('reconnect', reconnects, err);\n    };\n    const reconnectIfEndedEarly = (err) => {\n        if (options.method !== 'HEAD' && !downloadComplete() && reconnects++ < opts.maxReconnects) {\n            reconnect(err);\n            return true;\n        }\n        return false;\n    };\n    const retryRequest = (retryOptions) => {\n        if (stream.destroyed) {\n            return false;\n        }\n        if (downloadHasStarted()) {\n            return reconnectIfEndedEarly(retryOptions.err);\n        }\n        else if ((!retryOptions.err || retryOptions.err.message === 'ENOTFOUND') &&\n            retries++ < opts.maxRetries) {\n            let ms = retryOptions.retryAfter ||\n                Math.min(retries * opts.backoff.inc, opts.backoff.max);\n            retryTimeout = setTimeout(doDownload, ms);\n            stream.emit('retry', retries, retryOptions.err);\n            return true;\n        }\n        return false;\n    };\n    const forwardEvents = (ee, events) => {\n        for (let event of events) {\n            ee.on(event, stream.emit.bind(stream, event));\n        }\n    };\n    const doDownload = () => {\n        let parsed = {}, httpLib;\n        try {\n            let urlObj = typeof url === 'string' ? new URL(url) : url;\n            parsed = Object.assign({}, {\n                host: urlObj.host,\n                hostname: urlObj.hostname,\n                path: urlObj.pathname + urlObj.search + urlObj.hash,\n                port: urlObj.port,\n                protocol: urlObj.protocol,\n            });\n            if (urlObj.username) {\n                parsed.auth = `${urlObj.username}:${urlObj.password}`;\n            }\n            httpLib = httpLibs[String(parsed.protocol)];\n        }\n        catch (err) {\n            // Let the error be caught by the if statement below.\n        }\n        if (!httpLib) {\n            stream.emit('error', new Miniget.MinigetError(`Invalid URL: ${url}`));\n            return;\n        }\n        Object.assign(parsed, opts);\n        if (acceptRanges && downloaded > 0) {\n            let start = downloaded + rangeStart;\n            let end = rangeEnd || '';\n            parsed.headers = Object.assign({}, parsed.headers, {\n                Range: `bytes=${start}-${end}`,\n            });\n        }\n        if (opts.transform) {\n            try {\n                parsed = opts.transform(parsed);\n            }\n            catch (err) {\n                stream.emit('error', err);\n                return;\n            }\n            if (!parsed || parsed.protocol) {\n                httpLib = httpLibs[String(parsed === null || parsed === void 0 ? void 0 : parsed.protocol)];\n                if (!httpLib) {\n                    stream.emit('error', new Miniget.MinigetError('Invalid URL object from `transform` function'));\n                    return;\n                }\n            }\n        }\n        const onError = (err) => {\n            if (stream.destroyed || stream.readableEnded) {\n                return;\n            }\n            cleanup();\n            if (!retryRequest({ err })) {\n                stream.emit('error', err);\n            }\n            else {\n                activeRequest.removeListener('close', onRequestClose);\n            }\n        };\n        const onRequestClose = () => {\n            cleanup();\n            retryRequest({});\n        };\n        const cleanup = () => {\n            activeRequest.removeListener('close', onRequestClose);\n            activeResponse === null || activeResponse === void 0 ? void 0 : activeResponse.removeListener('data', onData);\n            activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.removeListener('end', onEnd);\n        };\n        const onData = (chunk) => { downloaded += chunk.length; };\n        const onEnd = () => {\n            cleanup();\n            if (!reconnectIfEndedEarly()) {\n                stream.end();\n            }\n        };\n        activeRequest = httpLib.request(parsed, (res) => {\n            // Needed for node v10, v12.\n            // istanbul ignore next\n            if (stream.destroyed) {\n                return;\n            }\n            if (redirectStatusCodes.has(res.statusCode)) {\n                if (redirects++ >= opts.maxRedirects) {\n                    stream.emit('error', new Miniget.MinigetError('Too many redirects'));\n                }\n                else {\n                    if (res.headers.location) {\n                        url = res.headers.location;\n                    }\n                    else {\n                        let err = new Miniget.MinigetError('Redirect status code given with no location', res.statusCode);\n                        stream.emit('error', err);\n                        cleanup();\n                        return;\n                    }\n                    setTimeout(doDownload, parseInt(res.headers['retry-after'] || '0', 10) * 1000);\n                    stream.emit('redirect', url);\n                }\n                cleanup();\n                return;\n                // Check for rate limiting.\n            }\n            else if (retryStatusCodes.has(res.statusCode)) {\n                if (!retryRequest({ retryAfter: parseInt(res.headers['retry-after'] || '0', 10) })) {\n                    let err = new Miniget.MinigetError(`Status code: ${res.statusCode}`, res.statusCode);\n                    stream.emit('error', err);\n                }\n                cleanup();\n                return;\n            }\n            else if (res.statusCode && (res.statusCode < 200 || res.statusCode >= 400)) {\n                let err = new Miniget.MinigetError(`Status code: ${res.statusCode}`, res.statusCode);\n                if (res.statusCode >= 500) {\n                    onError(err);\n                }\n                else {\n                    stream.emit('error', err);\n                }\n                cleanup();\n                return;\n            }\n            activeDecodedStream = res;\n            if (opts.acceptEncoding && res.headers['content-encoding']) {\n                for (let enc of res.headers['content-encoding'].split(', ').reverse()) {\n                    let fn = opts.acceptEncoding[enc];\n                    if (fn) {\n                        activeDecodedStream = activeDecodedStream.pipe(fn());\n                        activeDecodedStream.on('error', onError);\n                    }\n                }\n            }\n            if (!contentLength) {\n                contentLength = parseInt(`${res.headers['content-length']}`, 10);\n                acceptRanges = res.headers['accept-ranges'] === 'bytes' &&\n                    contentLength > 0 && opts.maxReconnects > 0;\n            }\n            res.on('data', onData);\n            activeDecodedStream.on('end', onEnd);\n            activeDecodedStream.pipe(stream, { end: !acceptRanges });\n            activeResponse = res;\n            stream.emit('response', res);\n            res.on('error', onError);\n            forwardEvents(res, responseEvents);\n        });\n        activeRequest.on('error', onError);\n        activeRequest.on('close', onRequestClose);\n        forwardEvents(activeRequest, requestEvents);\n        if (stream.destroyed) {\n            streamDestroy(...destroyArgs);\n        }\n        stream.emit('request', activeRequest);\n        activeRequest.end();\n    };\n    stream.abort = (err) => {\n        console.warn('`MinigetStream#abort()` has been deprecated in favor of `MinigetStream#destroy()`');\n        stream.aborted = true;\n        stream.emit('abort');\n        stream.destroy(err);\n    };\n    let destroyArgs;\n    const streamDestroy = (err) => {\n        activeRequest.destroy(err);\n        activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.unpipe(stream);\n        activeDecodedStream === null || activeDecodedStream === void 0 ? void 0 : activeDecodedStream.destroy();\n        clearTimeout(retryTimeout);\n    };\n    stream._destroy = (...args) => {\n        stream.destroyed = true;\n        if (activeRequest) {\n            streamDestroy(...args);\n        }\n        else {\n            destroyArgs = args;\n        }\n    };\n    stream.text = () => new Promise((resolve, reject) => {\n        let body = '';\n        stream.setEncoding('utf8');\n        stream.on('data', chunk => body += chunk);\n        stream.on('end', () => resolve(body));\n        stream.on('error', reject);\n    });\n    process.nextTick(doDownload);\n    return stream;\n}\nmodule.exports = Miniget;\n//# sourceMappingURL=index.js.map",null,"{\n  \"name\": \"ytdl-core\",\n  \"description\": \"YouTube video downloader in pure javascript.\",\n  \"keywords\": [\n    \"youtube\",\n    \"video\",\n    \"download\"\n  ],\n  \"version\": \"4.11.3\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/fent/node-ytdl-core.git\"\n  },\n  \"author\": \"fent <fentbox@gmail.com> (https://github.com/fent)\",\n  \"contributors\": [\n    \"Tobias Kutscha (https://github.com/TimeForANinja)\",\n    \"Andrew Kelley (https://github.com/andrewrk)\",\n    \"Mauricio Allende (https://github.com/mallendeo)\",\n    \"Rodrigo Altamirano (https://github.com/raltamirano)\",\n    \"Jim Buck (https://github.com/JimmyBoh)\",\n    \"Paweł Ruciński (https://github.com/Roki100)\",\n    \"Alexander Paolini (https://github.com/Million900o)\"\n  ],\n  \"main\": \"./lib/index.js\",\n  \"types\": \"./typings/index.d.ts\",\n  \"files\": [\n    \"lib\",\n    \"typings\"\n  ],\n  \"scripts\": {\n    \"test\": \"nyc --reporter=lcov --reporter=text-summary npm run test:unit\",\n    \"test:unit\": \"mocha --ignore test/irl-test.js test/*-test.js --timeout 4000\",\n    \"test:irl\": \"mocha --timeout 16000 test/irl-test.js\",\n    \"lint\": \"eslint ./\",\n    \"lint:fix\": \"eslint --fix ./\",\n    \"lint:typings\": \"tslint typings/index.d.ts\",\n    \"lint:typings:fix\": \"tslint --fix typings/index.d.ts\"\n  },\n  \"dependencies\": {\n    \"m3u8stream\": \"^0.8.6\",\n    \"miniget\": \"^4.2.2\",\n    \"sax\": \"^1.1.3\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^13.1.0\",\n    \"assert-diff\": \"^3.0.1\",\n    \"dtslint\": \"^3.6.14\",\n    \"eslint\": \"^6.8.0\",\n    \"mocha\": \"^7.0.0\",\n    \"muk-require\": \"^1.2.0\",\n    \"nock\": \"^13.0.4\",\n    \"nyc\": \"^15.0.0\",\n    \"sinon\": \"^9.0.0\",\n    \"stream-equal\": \"~1.1.0\",\n    \"typescript\": \"^3.9.7\"\n  },\n  \"engines\": {\n    \"node\": \">=12\"\n  },\n  \"license\": \"MIT\"\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stream_1 = require(\"stream\");\n/**\n * A very simple m3u8 playlist file parser that detects tags and segments.\n */\nclass m3u8Parser extends stream_1.Writable {\n    constructor() {\n        super();\n        this._lastLine = '';\n        this._seq = 0;\n        this._nextItemDuration = null;\n        this._nextItemRange = null;\n        this._lastItemRangeEnd = 0;\n        this.on('finish', () => {\n            this._parseLine(this._lastLine);\n            this.emit('end');\n        });\n    }\n    _parseAttrList(value) {\n        let attrs = {};\n        let regex = /([A-Z0-9-]+)=(?:\"([^\"]*?)\"|([^,]*?))/g;\n        let match;\n        while ((match = regex.exec(value)) !== null) {\n            attrs[match[1]] = match[2] || match[3];\n        }\n        return attrs;\n    }\n    _parseRange(value) {\n        if (!value)\n            return null;\n        let svalue = value.split('@');\n        let start = svalue[1] ? parseInt(svalue[1]) : this._lastItemRangeEnd + 1;\n        let end = start + parseInt(svalue[0]) - 1;\n        let range = { start, end };\n        this._lastItemRangeEnd = range.end;\n        return range;\n    }\n    _parseLine(line) {\n        let match = line.match(/^#(EXT[A-Z0-9-]+)(?::(.*))?/);\n        if (match) {\n            // This is a tag.\n            const tag = match[1];\n            const value = match[2] || '';\n            switch (tag) {\n                case 'EXT-X-PROGRAM-DATE-TIME':\n                    this.emit('starttime', new Date(value).getTime());\n                    break;\n                case 'EXT-X-MEDIA-SEQUENCE':\n                    this._seq = parseInt(value);\n                    break;\n                case 'EXT-X-MAP': {\n                    let attrs = this._parseAttrList(value);\n                    if (!attrs.URI) {\n                        this.destroy(new Error('`EXT-X-MAP` found without required attribute `URI`'));\n                        return;\n                    }\n                    this.emit('item', {\n                        url: attrs.URI,\n                        seq: this._seq,\n                        init: true,\n                        duration: 0,\n                        range: this._parseRange(attrs.BYTERANGE),\n                    });\n                    break;\n                }\n                case 'EXT-X-BYTERANGE': {\n                    this._nextItemRange = this._parseRange(value);\n                    break;\n                }\n                case 'EXTINF':\n                    this._nextItemDuration =\n                        Math.round(parseFloat(value.split(',')[0]) * 1000);\n                    break;\n                case 'EXT-X-ENDLIST':\n                    this.emit('endlist');\n                    break;\n            }\n        }\n        else if (!/^#/.test(line) && line.trim()) {\n            // This is a segment\n            this.emit('item', {\n                url: line.trim(),\n                seq: this._seq++,\n                duration: this._nextItemDuration,\n                range: this._nextItemRange,\n            });\n            this._nextItemRange = null;\n        }\n    }\n    _write(chunk, encoding, callback) {\n        let lines = chunk.toString('utf8').split('\\n');\n        if (this._lastLine) {\n            lines[0] = this._lastLine + lines[0];\n        }\n        lines.forEach((line, i) => {\n            if (this.destroyed)\n                return;\n            if (i < lines.length - 1) {\n                this._parseLine(line);\n            }\n            else {\n                // Save the last line in case it has been broken up.\n                this._lastLine = line;\n            }\n        });\n        callback();\n    }\n}\nexports.default = m3u8Parser;\n//# sourceMappingURL=m3u8-parser.js.map",null,"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stream_1 = require(\"stream\");\nconst sax_1 = __importDefault(require(\"sax\"));\nconst parse_time_1 = require(\"./parse-time\");\n/**\n * A wrapper around sax that emits segments.\n */\nclass DashMPDParser extends stream_1.Writable {\n    constructor(targetID) {\n        super();\n        this._parser = sax_1.default.createStream(false, { lowercase: true });\n        this._parser.on('error', this.destroy.bind(this));\n        let lastTag;\n        let currtime = 0;\n        let seq = 0;\n        let segmentTemplate;\n        let timescale, offset, duration, baseURL;\n        let timeline = [];\n        let getSegments = false;\n        let gotSegments = false;\n        let isStatic;\n        let treeLevel;\n        let periodStart;\n        const tmpl = (str) => {\n            const context = {\n                RepresentationID: targetID,\n                Number: seq,\n                Time: currtime,\n            };\n            return str.replace(/\\$(\\w+)\\$/g, (m, p1) => `${context[p1]}`);\n        };\n        this._parser.on('opentag', node => {\n            switch (node.name) {\n                case 'mpd':\n                    currtime =\n                        node.attributes.availabilitystarttime ?\n                            new Date(node.attributes.availabilitystarttime).getTime() : 0;\n                    isStatic = node.attributes.type !== 'dynamic';\n                    break;\n                case 'period':\n                    // Reset everything on <Period> tag.\n                    seq = 0;\n                    timescale = 1000;\n                    duration = 0;\n                    offset = 0;\n                    baseURL = [];\n                    treeLevel = 0;\n                    periodStart = parse_time_1.durationStr(node.attributes.start) || 0;\n                    break;\n                case 'segmentlist':\n                    seq = parseInt(node.attributes.startnumber) || seq;\n                    timescale = parseInt(node.attributes.timescale) || timescale;\n                    duration = parseInt(node.attributes.duration) || duration;\n                    offset = parseInt(node.attributes.presentationtimeoffset) || offset;\n                    break;\n                case 'segmenttemplate':\n                    segmentTemplate = node.attributes;\n                    seq = parseInt(node.attributes.startnumber) || seq;\n                    timescale = parseInt(node.attributes.timescale) || timescale;\n                    break;\n                case 'segmenttimeline':\n                case 'baseurl':\n                    lastTag = node.name;\n                    break;\n                case 's':\n                    timeline.push({\n                        duration: parseInt(node.attributes.d),\n                        repeat: parseInt(node.attributes.r),\n                        time: parseInt(node.attributes.t),\n                    });\n                    break;\n                case 'adaptationset':\n                case 'representation':\n                    treeLevel++;\n                    if (!targetID) {\n                        targetID = node.attributes.id;\n                    }\n                    getSegments = node.attributes.id === `${targetID}`;\n                    if (getSegments) {\n                        if (periodStart) {\n                            currtime += periodStart;\n                        }\n                        if (offset) {\n                            currtime -= offset / timescale * 1000;\n                        }\n                        this.emit('starttime', currtime);\n                    }\n                    break;\n                case 'initialization':\n                    if (getSegments) {\n                        this.emit('item', {\n                            url: baseURL.filter(s => !!s).join('') + node.attributes.sourceurl,\n                            seq: seq,\n                            init: true,\n                            duration: 0,\n                        });\n                    }\n                    break;\n                case 'segmenturl':\n                    if (getSegments) {\n                        gotSegments = true;\n                        let tl = timeline.shift();\n                        let segmentDuration = ((tl === null || tl === void 0 ? void 0 : tl.duration) || duration) / timescale * 1000;\n                        this.emit('item', {\n                            url: baseURL.filter(s => !!s).join('') + node.attributes.media,\n                            seq: seq++,\n                            duration: segmentDuration,\n                        });\n                        currtime += segmentDuration;\n                    }\n                    break;\n            }\n        });\n        const onEnd = () => {\n            if (isStatic) {\n                this.emit('endlist');\n            }\n            if (!getSegments) {\n                this.destroy(Error(`Representation '${targetID}' not found`));\n            }\n            else {\n                this.emit('end');\n            }\n        };\n        this._parser.on('closetag', tagName => {\n            switch (tagName) {\n                case 'adaptationset':\n                case 'representation':\n                    treeLevel--;\n                    if (segmentTemplate && timeline.length) {\n                        gotSegments = true;\n                        if (segmentTemplate.initialization) {\n                            this.emit('item', {\n                                url: baseURL.filter(s => !!s).join('') +\n                                    tmpl(segmentTemplate.initialization),\n                                seq: seq,\n                                init: true,\n                                duration: 0,\n                            });\n                        }\n                        for (let { duration: itemDuration, repeat, time } of timeline) {\n                            itemDuration = itemDuration / timescale * 1000;\n                            repeat = repeat || 1;\n                            currtime = time || currtime;\n                            for (let i = 0; i < repeat; i++) {\n                                this.emit('item', {\n                                    url: baseURL.filter(s => !!s).join('') +\n                                        tmpl(segmentTemplate.media),\n                                    seq: seq++,\n                                    duration: itemDuration,\n                                });\n                                currtime += itemDuration;\n                            }\n                        }\n                    }\n                    if (gotSegments) {\n                        this.emit('endearly');\n                        onEnd();\n                        this._parser.removeAllListeners();\n                        this.removeAllListeners('finish');\n                    }\n                    break;\n            }\n        });\n        this._parser.on('text', text => {\n            if (lastTag === 'baseurl') {\n                baseURL[treeLevel] = text;\n                lastTag = null;\n            }\n        });\n        this.on('finish', onEnd);\n    }\n    _write(chunk, encoding, callback) {\n        this._parser.write(chunk);\n        callback();\n    }\n}\nexports.default = DashMPDParser;\n//# sourceMappingURL=dash-mpd-parser.js.map",null,"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.durationStr = exports.humanStr = void 0;\nconst numberFormat = /^\\d+$/;\nconst timeFormat = /^(?:(?:(\\d+):)?(\\d{1,2}):)?(\\d{1,2})(?:\\.(\\d{3}))?$/;\nconst timeUnits = {\n    ms: 1,\n    s: 1000,\n    m: 60000,\n    h: 3600000,\n};\n/**\n * Converts human friendly time to milliseconds. Supports the format\n * 00:00:00.000 for hours, minutes, seconds, and milliseconds respectively.\n * And 0ms, 0s, 0m, 0h, and together 1m1s.\n *\n * @param {number|string} time\n * @returns {number}\n */\nexports.humanStr = (time) => {\n    if (typeof time === 'number') {\n        return time;\n    }\n    if (numberFormat.test(time)) {\n        return +time;\n    }\n    const firstFormat = timeFormat.exec(time);\n    if (firstFormat) {\n        return (+(firstFormat[1] || 0) * timeUnits.h) +\n            (+(firstFormat[2] || 0) * timeUnits.m) +\n            (+firstFormat[3] * timeUnits.s) +\n            +(firstFormat[4] || 0);\n    }\n    else {\n        let total = 0;\n        const r = /(-?\\d+)(ms|s|m|h)/g;\n        let rs;\n        while ((rs = r.exec(time)) !== null) {\n            total += +rs[1] * timeUnits[rs[2]];\n        }\n        return total;\n    }\n};\n/**\n * Parses a duration string in the form of \"123.456S\", returns milliseconds.\n *\n * @param {string} time\n * @returns {number}\n */\nexports.durationStr = (time) => {\n    let total = 0;\n    const r = /(\\d+(?:\\.\\d+)?)(S|M|H)/g;\n    let rs;\n    while ((rs = r.exec(time)) !== null) {\n        total += +rs[1] * timeUnits[rs[2].toLowerCase()];\n    }\n    return total;\n};\n//# sourceMappingURL=parse-time.js.map",null,"/*jshint node:true*/\n'use strict';\n\nvar path = require('path');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\nvar utils = require('./utils');\nvar ARGLISTS = ['_global', '_audio', '_audioFilters', '_video', '_videoFilters', '_sizeFilters', '_complexFilters'];\n\n\n/**\n * Create an ffmpeg command\n *\n * Can be called with or without the 'new' operator, and the 'input' parameter\n * may be specified as 'options.source' instead (or passed later with the\n * addInput method).\n *\n * @constructor\n * @param {String|ReadableStream} [input] input file path or readable stream\n * @param {Object} [options] command options\n * @param {Object} [options.logger=<no logging>] logger object with 'error', 'warning', 'info' and 'debug' methods\n * @param {Number} [options.niceness=0] ffmpeg process niceness, ignored on Windows\n * @param {Number} [options.priority=0] alias for `niceness`\n * @param {String} [options.presets=\"fluent-ffmpeg/lib/presets\"] directory to load presets from\n * @param {String} [options.preset=\"fluent-ffmpeg/lib/presets\"] alias for `presets`\n * @param {String} [options.stdoutLines=100] maximum lines of ffmpeg output to keep in memory, use 0 for unlimited\n * @param {Number} [options.timeout=<no timeout>] ffmpeg processing timeout in seconds\n * @param {String|ReadableStream} [options.source=<no input>] alias for the `input` parameter\n */\nfunction FfmpegCommand(input, options) {\n  // Make 'new' optional\n  if (!(this instanceof FfmpegCommand)) {\n    return new FfmpegCommand(input, options);\n  }\n\n  EventEmitter.call(this);\n\n  if (typeof input === 'object' && !('readable' in input)) {\n    // Options object passed directly\n    options = input;\n  } else {\n    // Input passed first\n    options = options || {};\n    options.source = input;\n  }\n\n  // Add input if present\n  this._inputs = [];\n  if (options.source) {\n    this.input(options.source);\n  }\n\n  // Add target-less output for backwards compatibility\n  this._outputs = [];\n  this.output();\n\n  // Create argument lists\n  var self = this;\n  ['_global', '_complexFilters'].forEach(function(prop) {\n    self[prop] = utils.args();\n  });\n\n  // Set default option values\n  options.stdoutLines = 'stdoutLines' in options ? options.stdoutLines : 100;\n  options.presets = options.presets || options.preset || path.join(__dirname, 'presets');\n  options.niceness = options.niceness || options.priority || 0;\n\n  // Save options\n  this.options = options;\n\n  // Setup logger\n  this.logger = options.logger || {\n    debug: function() {},\n    info: function() {},\n    warn: function() {},\n    error: function() {}\n  };\n}\nutil.inherits(FfmpegCommand, EventEmitter);\nmodule.exports = FfmpegCommand;\n\n\n/**\n * Clone an ffmpeg command\n *\n * This method is useful when you want to process the same input multiple times.\n * It returns a new FfmpegCommand instance with the exact same options.\n *\n * All options set _after_ the clone() call will only be applied to the instance\n * it has been called on.\n *\n * @example\n *   var command = ffmpeg('/path/to/source.avi')\n *     .audioCodec('libfaac')\n *     .videoCodec('libx264')\n *     .format('mp4');\n *\n *   command.clone()\n *     .size('320x200')\n *     .save('/path/to/output-small.mp4');\n *\n *   command.clone()\n *     .size('640x400')\n *     .save('/path/to/output-medium.mp4');\n *\n *   command.save('/path/to/output-original-size.mp4');\n *\n * @method FfmpegCommand#clone\n * @return FfmpegCommand\n */\nFfmpegCommand.prototype.clone = function() {\n  var clone = new FfmpegCommand();\n  var self = this;\n\n  // Clone options and logger\n  clone.options = this.options;\n  clone.logger = this.logger;\n\n  // Clone inputs\n  clone._inputs = this._inputs.map(function(input) {\n    return {\n      source: input.source,\n      options: input.options.clone()\n    };\n  });\n\n  // Create first output\n  if ('target' in this._outputs[0]) {\n    // We have outputs set, don't clone them and create first output\n    clone._outputs = [];\n    clone.output();\n  } else {\n    // No outputs set, clone first output options\n    clone._outputs = [\n      clone._currentOutput = {\n        flags: {}\n      }\n    ];\n\n    ['audio', 'audioFilters', 'video', 'videoFilters', 'sizeFilters', 'options'].forEach(function(key) {\n      clone._currentOutput[key] = self._currentOutput[key].clone();\n    });\n\n    if (this._currentOutput.sizeData) {\n      clone._currentOutput.sizeData = {};\n      utils.copy(this._currentOutput.sizeData, clone._currentOutput.sizeData);\n    }\n\n    utils.copy(this._currentOutput.flags, clone._currentOutput.flags);\n  }\n\n  // Clone argument lists\n  ['_global', '_complexFilters'].forEach(function(prop) {\n    clone[prop] = self[prop].clone();\n  });\n\n  return clone;\n};\n\n\n/* Add methods from options submodules */\n\nrequire('./options/inputs')(FfmpegCommand.prototype);\nrequire('./options/audio')(FfmpegCommand.prototype);\nrequire('./options/video')(FfmpegCommand.prototype);\nrequire('./options/videosize')(FfmpegCommand.prototype);\nrequire('./options/output')(FfmpegCommand.prototype);\nrequire('./options/custom')(FfmpegCommand.prototype);\nrequire('./options/misc')(FfmpegCommand.prototype);\n\n\n/* Add processor methods */\n\nrequire('./processor')(FfmpegCommand.prototype);\n\n\n/* Add capabilities methods */\n\nrequire('./capabilities')(FfmpegCommand.prototype);\n\nFfmpegCommand.setFfmpegPath = function(path) {\n  (new FfmpegCommand()).setFfmpegPath(path);\n};\n\nFfmpegCommand.setFfprobePath = function(path) {\n  (new FfmpegCommand()).setFfprobePath(path);\n};\n\nFfmpegCommand.setFlvtoolPath = function(path) {\n  (new FfmpegCommand()).setFlvtoolPath(path);\n};\n\nFfmpegCommand.availableFilters =\nFfmpegCommand.getAvailableFilters = function(callback) {\n  (new FfmpegCommand()).availableFilters(callback);\n};\n\nFfmpegCommand.availableCodecs =\nFfmpegCommand.getAvailableCodecs = function(callback) {\n  (new FfmpegCommand()).availableCodecs(callback);\n};\n\nFfmpegCommand.availableFormats =\nFfmpegCommand.getAvailableFormats = function(callback) {\n  (new FfmpegCommand()).availableFormats(callback);\n};\n\nFfmpegCommand.availableEncoders =\nFfmpegCommand.getAvailableEncoders = function(callback) {\n  (new FfmpegCommand()).availableEncoders(callback);\n};\n\n\n/* Add ffprobe methods */\n\nrequire('./ffprobe')(FfmpegCommand.prototype);\n\nFfmpegCommand.ffprobe = function(file) {\n  var instance = new FfmpegCommand(file);\n  instance.ffprobe.apply(instance, Array.prototype.slice.call(arguments, 1));\n};\n\n/* Add processing recipes */\n\nrequire('./recipes')(FfmpegCommand.prototype);\n","/*jshint node:true*/\n'use strict';\n\nvar exec = require('child_process').exec;\nvar isWindows = require('os').platform().match(/win(32|64)/);\nvar which = require('which');\n\nvar nlRegexp = /\\r\\n|\\r|\\n/g;\nvar streamRegexp = /^\\[?(.*?)\\]?$/;\nvar filterEscapeRegexp = /[,]/;\nvar whichCache = {};\n\n/**\n * Parse progress line from ffmpeg stderr\n *\n * @param {String} line progress line\n * @return progress object\n * @private\n */\nfunction parseProgressLine(line) {\n  var progress = {};\n\n  // Remove all spaces after = and trim\n  line  = line.replace(/=\\s+/g, '=').trim();\n  var progressParts = line.split(' ');\n\n  // Split every progress part by \"=\" to get key and value\n  for(var i = 0; i < progressParts.length; i++) {\n    var progressSplit = progressParts[i].split('=', 2);\n    var key = progressSplit[0];\n    var value = progressSplit[1];\n\n    // This is not a progress line\n    if(typeof value === 'undefined')\n      return null;\n\n    progress[key] = value;\n  }\n\n  return progress;\n}\n\n\nvar utils = module.exports = {\n  isWindows: isWindows,\n  streamRegexp: streamRegexp,\n\n\n  /**\n   * Copy an object keys into another one\n   *\n   * @param {Object} source source object\n   * @param {Object} dest destination object\n   * @private\n   */\n  copy: function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n      dest[key] = source[key];\n    });\n  },\n\n\n  /**\n   * Create an argument list\n   *\n   * Returns a function that adds new arguments to the list.\n   * It also has the following methods:\n   * - clear() empties the argument list\n   * - get() returns the argument list\n   * - find(arg, count) finds 'arg' in the list and return the following 'count' items, or undefined if not found\n   * - remove(arg, count) remove 'arg' in the list as well as the following 'count' items\n   *\n   * @private\n   */\n  args: function() {\n    var list = [];\n\n    // Append argument(s) to the list\n    var argfunc = function() {\n      if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        list = list.concat(arguments[0]);\n      } else {\n        list = list.concat([].slice.call(arguments));\n      }\n    };\n\n    // Clear argument list\n    argfunc.clear = function() {\n      list = [];\n    };\n\n    // Return argument list\n    argfunc.get = function() {\n      return list;\n    };\n\n    // Find argument 'arg' in list, and if found, return an array of the 'count' items that follow it\n    argfunc.find = function(arg, count) {\n      var index = list.indexOf(arg);\n      if (index !== -1) {\n        return list.slice(index + 1, index + 1 + (count || 0));\n      }\n    };\n\n    // Find argument 'arg' in list, and if found, remove it as well as the 'count' items that follow it\n    argfunc.remove = function(arg, count) {\n      var index = list.indexOf(arg);\n      if (index !== -1) {\n        list.splice(index, (count || 0) + 1);\n      }\n    };\n\n    // Clone argument list\n    argfunc.clone = function() {\n      var cloned = utils.args();\n      cloned(list);\n      return cloned;\n    };\n\n    return argfunc;\n  },\n\n\n  /**\n   * Generate filter strings\n   *\n   * @param {String[]|Object[]} filters filter specifications. When using objects,\n   *   each must have the following properties:\n   * @param {String} filters.filter filter name\n   * @param {String|Array} [filters.inputs] (array of) input stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically choosing the first unused matching streams\n   * @param {String|Array} [filters.outputs] (array of) output stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically assigning the output to the output file\n   * @param {Object|String|Array} [filters.options] filter options, can be omitted to not set any options\n   * @return String[]\n   * @private\n   */\n  makeFilterStrings: function(filters) {\n    return filters.map(function(filterSpec) {\n      if (typeof filterSpec === 'string') {\n        return filterSpec;\n      }\n\n      var filterString = '';\n\n      // Filter string format is:\n      // [input1][input2]...filter[output1][output2]...\n      // The 'filter' part can optionaly have arguments:\n      //   filter=arg1:arg2:arg3\n      //   filter=arg1=v1:arg2=v2:arg3=v3\n\n      // Add inputs\n      if (Array.isArray(filterSpec.inputs)) {\n        filterString += filterSpec.inputs.map(function(streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.inputs === 'string') {\n        filterString += filterSpec.inputs.replace(streamRegexp, '[$1]');\n      }\n\n      // Add filter\n      filterString += filterSpec.filter;\n\n      // Add options\n      if (filterSpec.options) {\n        if (typeof filterSpec.options === 'string' || typeof filterSpec.options === 'number') {\n          // Option string\n          filterString += '=' + filterSpec.options;\n        } else if (Array.isArray(filterSpec.options)) {\n          // Option array (unnamed options)\n          filterString += '=' + filterSpec.options.map(function(option) {\n            if (typeof option === 'string' && option.match(filterEscapeRegexp)) {\n              return '\\'' + option + '\\'';\n            } else {\n              return option;\n            }\n          }).join(':');\n        } else if (Object.keys(filterSpec.options).length) {\n          // Option object (named options)\n          filterString += '=' + Object.keys(filterSpec.options).map(function(option) {\n            var value = filterSpec.options[option];\n\n            if (typeof value === 'string' && value.match(filterEscapeRegexp)) {\n              value = '\\'' + value + '\\'';\n            }\n\n            return option + '=' + value;\n          }).join(':');\n        }\n      }\n\n      // Add outputs\n      if (Array.isArray(filterSpec.outputs)) {\n        filterString += filterSpec.outputs.map(function(streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.outputs === 'string') {\n        filterString += filterSpec.outputs.replace(streamRegexp, '[$1]');\n      }\n\n      return filterString;\n    });\n  },\n\n\n  /**\n   * Search for an executable\n   *\n   * Uses 'which' or 'where' depending on platform\n   *\n   * @param {String} name executable name\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  which: function(name, callback) {\n    if (name in whichCache) {\n      return callback(null, whichCache[name]);\n    }\n\n    which(name, function(err, result){\n      if (err) {\n        // Treat errors as not found\n        return callback(null, whichCache[name] = '');\n      }\n      callback(null, whichCache[name] = result);\n    });\n  },\n\n\n  /**\n   * Convert a [[hh:]mm:]ss[.xxx] timemark into seconds\n   *\n   * @param {String} timemark timemark string\n   * @return Number\n   * @private\n   */\n  timemarkToSeconds: function(timemark) {\n    if (typeof timemark === 'number') {\n      return timemark;\n    }\n\n    if (timemark.indexOf(':') === -1 && timemark.indexOf('.') >= 0) {\n      return Number(timemark);\n    }\n\n    var parts = timemark.split(':');\n\n    // add seconds\n    var secs = Number(parts.pop());\n\n    if (parts.length) {\n      // add minutes\n      secs += Number(parts.pop()) * 60;\n    }\n\n    if (parts.length) {\n      // add hours\n      secs += Number(parts.pop()) * 3600;\n    }\n\n    return secs;\n  },\n\n\n  /**\n   * Extract codec data from ffmpeg stderr and emit 'codecData' event if appropriate\n   * Call it with an initially empty codec object once with each line of stderr output until it returns true\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr output line\n   * @param {Object} codecObject object used to accumulate codec data between calls\n   * @return {Boolean} true if codec data is complete (and event was emitted), false otherwise\n   * @private\n   */\n  extractCodecData: function(command, stderrLine, codecsObject) {\n    var inputPattern = /Input #[0-9]+, ([^ ]+),/;\n    var durPattern = /Duration\\: ([^,]+)/;\n    var audioPattern = /Audio\\: (.*)/;\n    var videoPattern = /Video\\: (.*)/;\n\n    if (!('inputStack' in codecsObject)) {\n      codecsObject.inputStack = [];\n      codecsObject.inputIndex = -1;\n      codecsObject.inInput = false;\n    }\n\n    var inputStack = codecsObject.inputStack;\n    var inputIndex = codecsObject.inputIndex;\n    var inInput = codecsObject.inInput;\n\n    var format, dur, audio, video;\n\n    if (format = stderrLine.match(inputPattern)) {\n      inInput = codecsObject.inInput = true;\n      inputIndex = codecsObject.inputIndex = codecsObject.inputIndex + 1;\n\n      inputStack[inputIndex] = { format: format[1], audio: '', video: '', duration: '' };\n    } else if (inInput && (dur = stderrLine.match(durPattern))) {\n      inputStack[inputIndex].duration = dur[1];\n    } else if (inInput && (audio = stderrLine.match(audioPattern))) {\n      audio = audio[1].split(', ');\n      inputStack[inputIndex].audio = audio[0];\n      inputStack[inputIndex].audio_details = audio;\n    } else if (inInput && (video = stderrLine.match(videoPattern))) {\n      video = video[1].split(', ');\n      inputStack[inputIndex].video = video[0];\n      inputStack[inputIndex].video_details = video;\n    } else if (/Output #\\d+/.test(stderrLine)) {\n      inInput = codecsObject.inInput = false;\n    } else if (/Stream mapping:|Press (\\[q\\]|ctrl-c) to stop/.test(stderrLine)) {\n      command.emit.apply(command, ['codecData'].concat(inputStack));\n      return true;\n    }\n\n    return false;\n  },\n\n\n  /**\n   * Extract progress data from ffmpeg stderr and emit 'progress' event if appropriate\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr data\n   * @private\n   */\n  extractProgress: function(command, stderrLine) {\n    var progress = parseProgressLine(stderrLine);\n\n    if (progress) {\n      // build progress report object\n      var ret = {\n        frames: parseInt(progress.frame, 10),\n        currentFps: parseInt(progress.fps, 10),\n        currentKbps: progress.bitrate ? parseFloat(progress.bitrate.replace('kbits/s', '')) : 0,\n        targetSize: parseInt(progress.size || progress.Lsize, 10),\n        timemark: progress.time\n      };\n\n      // calculate percent progress using duration\n      if (command._ffprobeData && command._ffprobeData.format && command._ffprobeData.format.duration) {\n        var duration = Number(command._ffprobeData.format.duration);\n        if (!isNaN(duration))\n          ret.percent = (utils.timemarkToSeconds(ret.timemark) / duration) * 100;\n      }\n      command.emit('progress', ret);\n    }\n  },\n\n\n  /**\n   * Extract error message(s) from ffmpeg stderr\n   *\n   * @param {String} stderr ffmpeg stderr data\n   * @return {String}\n   * @private\n   */\n  extractError: function(stderr) {\n    // Only return the last stderr lines that don't start with a space or a square bracket\n    return stderr.split(nlRegexp).reduce(function(messages, message) {\n      if (message.charAt(0) === ' ' || message.charAt(0) === '[') {\n        return [];\n      } else {\n        messages.push(message);\n        return messages;\n      }\n    }, []).join('\\n');\n  },\n\n\n  /**\n   * Creates a line ring buffer object with the following methods:\n   * - append(str) : appends a string or buffer\n   * - get() : returns the whole string\n   * - close() : prevents further append() calls and does a last call to callbacks\n   * - callback(cb) : calls cb for each line (incl. those already in the ring)\n   *\n   * @param {Numebr} maxLines maximum number of lines to store (<= 0 for unlimited)\n   */\n  linesRing: function(maxLines) {\n    var cbs = [];\n    var lines = [];\n    var current = null;\n    var closed = false\n    var max = maxLines - 1;\n\n    function emit(line) {\n      cbs.forEach(function(cb) { cb(line); });\n    }\n\n    return {\n      callback: function(cb) {\n        lines.forEach(function(l) { cb(l); });\n        cbs.push(cb);\n      },\n\n      append: function(str) {\n        if (closed) return;\n        if (str instanceof Buffer) str = '' + str;\n        if (!str || str.length === 0) return;\n\n        var newLines = str.split(nlRegexp);\n\n        if (newLines.length === 1) {\n          if (current !== null) {\n            current = current + newLines.shift();\n          } else {\n            current = newLines.shift();\n          }\n        } else {\n          if (current !== null) {\n            current = current + newLines.shift();\n            emit(current);\n            lines.push(current);\n          }\n\n          current = newLines.pop();\n\n          newLines.forEach(function(l) {\n            emit(l);\n            lines.push(l);\n          });\n\n          if (max > -1 && lines.length > max) {\n            lines.splice(0, lines.length - max);\n          }\n        }\n      },\n\n      get: function() {\n        if (current !== null) {\n          return lines.concat([current]).join('\\n');\n        } else {\n          return lines.join('\\n');\n        }\n      },\n\n      close: function() {\n        if (closed) return;\n\n        if (current !== null) {\n          emit(current);\n          lines.push(current);\n\n          if (max > -1 && lines.length > max) {\n            lines.shift();\n          }\n\n          current = null;\n        }\n\n        closed = true;\n      }\n    };\n  }\n};\n","module.exports = which\nwhich.sync = whichSync\n\nvar isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nvar path = require('path')\nvar COLON = isWindows ? ';' : ':'\nvar isexe = require('isexe')\n\nfunction getNotFoundError (cmd) {\n  var er = new Error('not found: ' + cmd)\n  er.code = 'ENOENT'\n\n  return er\n}\n\nfunction getPathInfo (cmd, opt) {\n  var colon = opt.colon || COLON\n  var pathEnv = opt.path || process.env.PATH || ''\n  var pathExt = ['']\n\n  pathEnv = pathEnv.split(colon)\n\n  var pathExtExe = ''\n  if (isWindows) {\n    pathEnv.unshift(process.cwd())\n    pathExtExe = (opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM')\n    pathExt = pathExtExe.split(colon)\n\n\n    // Always test the cmd itself first.  isexe will check to make sure\n    // it's found in the pathExt set.\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  if (cmd.match(/\\//) || isWindows && cmd.match(/\\\\/))\n    pathEnv = ['']\n\n  return {\n    env: pathEnv,\n    ext: pathExt,\n    extExe: pathExtExe\n  }\n}\n\nfunction which (cmd, opt, cb) {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n\n  var info = getPathInfo(cmd, opt)\n  var pathEnv = info.env\n  var pathExt = info.ext\n  var pathExtExe = info.extExe\n  var found = []\n\n  ;(function F (i, l) {\n    if (i === l) {\n      if (opt.all && found.length)\n        return cb(null, found)\n      else\n        return cb(getNotFoundError(cmd))\n    }\n\n    var pathPart = pathEnv[i]\n    if (pathPart.charAt(0) === '\"' && pathPart.slice(-1) === '\"')\n      pathPart = pathPart.slice(1, -1)\n\n    var p = path.join(pathPart, cmd)\n    if (!pathPart && (/^\\.[\\\\\\/]/).test(cmd)) {\n      p = cmd.slice(0, 2) + p\n    }\n    ;(function E (ii, ll) {\n      if (ii === ll) return F(i + 1, l)\n      var ext = pathExt[ii]\n      isexe(p + ext, { pathExt: pathExtExe }, function (er, is) {\n        if (!er && is) {\n          if (opt.all)\n            found.push(p + ext)\n          else\n            return cb(null, p + ext)\n        }\n        return E(ii + 1, ll)\n      })\n    })(0, pathExt.length)\n  })(0, pathEnv.length)\n}\n\nfunction whichSync (cmd, opt) {\n  opt = opt || {}\n\n  var info = getPathInfo(cmd, opt)\n  var pathEnv = info.env\n  var pathExt = info.ext\n  var pathExtExe = info.extExe\n  var found = []\n\n  for (var i = 0, l = pathEnv.length; i < l; i ++) {\n    var pathPart = pathEnv[i]\n    if (pathPart.charAt(0) === '\"' && pathPart.slice(-1) === '\"')\n      pathPart = pathPart.slice(1, -1)\n\n    var p = path.join(pathPart, cmd)\n    if (!pathPart && /^\\.[\\\\\\/]/.test(cmd)) {\n      p = cmd.slice(0, 2) + p\n    }\n    for (var j = 0, ll = pathExt.length; j < ll; j ++) {\n      var cur = p + pathExt[j]\n      var is\n      try {\n        is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n","var fs = require('fs')\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = require('./windows.js')\n} else {\n  core = require('./mode.js')\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n","/*jshint node:true*/\n'use strict';\n\nvar utils = require('../utils');\n\n/*\n *! Input-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Add an input to command\n   *\n   * Also switches \"current input\", that is the input that will be affected\n   * by subsequent input-related methods.\n   *\n   * Note: only one stream input is supported for now.\n   *\n   * @method FfmpegCommand#input\n   * @category Input\n   * @aliases mergeAdd,addInput\n   *\n   * @param {String|Readable} source input file path or readable stream\n   * @return FfmpegCommand\n   */\n  proto.mergeAdd =\n  proto.addInput =\n  proto.input = function(source) {\n    var isFile = false;\n    var isStream = false;\n\n    if (typeof source !== 'string') {\n      if (!('readable' in source) || !(source.readable)) {\n        throw new Error('Invalid input');\n      }\n\n      var hasInputStream = this._inputs.some(function(input) {\n        return input.isStream;\n      });\n\n      if (hasInputStream) {\n        throw new Error('Only one input stream is supported');\n      }\n\n      isStream = true;\n      source.pause();\n    } else {\n      var protocol = source.match(/^([a-z]{2,}):/i);\n      isFile = !protocol || protocol[0] === 'file';\n    }\n\n    this._inputs.push(this._currentInput = {\n      source: source,\n      isFile: isFile,\n      isStream: isStream,\n      options: utils.args()\n    });\n\n    return this;\n  };\n\n\n  /**\n   * Specify input format for the last specified input\n   *\n   * @method FfmpegCommand#inputFormat\n   * @category Input\n   * @aliases withInputFormat,fromFormat\n   *\n   * @param {String} format input format\n   * @return FfmpegCommand\n   */\n  proto.withInputFormat =\n  proto.inputFormat =\n  proto.fromFormat = function(format) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-f', format);\n    return this;\n  };\n\n\n  /**\n   * Specify input FPS for the last specified input\n   * (only valid for raw video formats)\n   *\n   * @method FfmpegCommand#inputFps\n   * @category Input\n   * @aliases withInputFps,withInputFPS,withFpsInput,withFPSInput,inputFPS,inputFps,fpsInput\n   *\n   * @param {Number} fps input FPS\n   * @return FfmpegCommand\n   */\n  proto.withInputFps =\n  proto.withInputFPS =\n  proto.withFpsInput =\n  proto.withFPSInput =\n  proto.inputFPS =\n  proto.inputFps =\n  proto.fpsInput =\n  proto.FPSInput = function(fps) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-r', fps);\n    return this;\n  };\n\n\n  /**\n   * Use native framerate for the last specified input\n   *\n   * @method FfmpegCommand#native\n   * @category Input\n   * @aliases nativeFramerate,withNativeFramerate\n   *\n   * @return FfmmegCommand\n   */\n  proto.nativeFramerate =\n  proto.withNativeFramerate =\n  proto.native = function() {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-re');\n    return this;\n  };\n\n\n  /**\n   * Specify input seek time for the last specified input\n   *\n   * @method FfmpegCommand#seekInput\n   * @category Input\n   * @aliases setStartTime,seekTo\n   *\n   * @param {String|Number} seek seek time in seconds or as a '[hh:[mm:]]ss[.xxx]' string\n   * @return FfmpegCommand\n   */\n  proto.setStartTime =\n  proto.seekInput = function(seek) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-ss', seek);\n\n    return this;\n  };\n\n\n  /**\n   * Loop over the last specified input\n   *\n   * @method FfmpegCommand#loop\n   * @category Input\n   *\n   * @param {String|Number} [duration] loop duration in seconds or as a '[[hh:]mm:]ss[.xxx]' string\n   * @return FfmpegCommand\n   */\n  proto.loop = function(duration) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-loop', '1');\n\n    if (typeof duration !== 'undefined') {\n      this.duration(duration);\n    }\n\n    return this;\n  };\n};\n","/*jshint node:true*/\n'use strict';\n\nvar utils = require('../utils');\n\n\n/*\n *! Audio-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Disable audio in the output\n   *\n   * @method FfmpegCommand#noAudio\n   * @category Audio\n   * @aliases withNoAudio\n   * @return FfmpegCommand\n   */\n  proto.withNoAudio =\n  proto.noAudio = function() {\n    this._currentOutput.audio.clear();\n    this._currentOutput.audioFilters.clear();\n    this._currentOutput.audio('-an');\n\n    return this;\n  };\n\n\n  /**\n   * Specify audio codec\n   *\n   * @method FfmpegCommand#audioCodec\n   * @category Audio\n   * @aliases withAudioCodec\n   *\n   * @param {String} codec audio codec name\n   * @return FfmpegCommand\n   */\n  proto.withAudioCodec =\n  proto.audioCodec = function(codec) {\n    this._currentOutput.audio('-acodec', codec);\n\n    return this;\n  };\n\n\n  /**\n   * Specify audio bitrate\n   *\n   * @method FfmpegCommand#audioBitrate\n   * @category Audio\n   * @aliases withAudioBitrate\n   *\n   * @param {String|Number} bitrate audio bitrate in kbps (with an optional 'k' suffix)\n   * @return FfmpegCommand\n   */\n  proto.withAudioBitrate =\n  proto.audioBitrate = function(bitrate) {\n    this._currentOutput.audio('-b:a', ('' + bitrate).replace(/k?$/, 'k'));\n    return this;\n  };\n\n\n  /**\n   * Specify audio channel count\n   *\n   * @method FfmpegCommand#audioChannels\n   * @category Audio\n   * @aliases withAudioChannels\n   *\n   * @param {Number} channels channel count\n   * @return FfmpegCommand\n   */\n  proto.withAudioChannels =\n  proto.audioChannels = function(channels) {\n    this._currentOutput.audio('-ac', channels);\n    return this;\n  };\n\n\n  /**\n   * Specify audio frequency\n   *\n   * @method FfmpegCommand#audioFrequency\n   * @category Audio\n   * @aliases withAudioFrequency\n   *\n   * @param {Number} freq audio frequency in Hz\n   * @return FfmpegCommand\n   */\n  proto.withAudioFrequency =\n  proto.audioFrequency = function(freq) {\n    this._currentOutput.audio('-ar', freq);\n    return this;\n  };\n\n\n  /**\n   * Specify audio quality\n   *\n   * @method FfmpegCommand#audioQuality\n   * @category Audio\n   * @aliases withAudioQuality\n   *\n   * @param {Number} quality audio quality factor\n   * @return FfmpegCommand\n   */\n  proto.withAudioQuality =\n  proto.audioQuality = function(quality) {\n    this._currentOutput.audio('-aq', quality);\n    return this;\n  };\n\n\n  /**\n   * Specify custom audio filter(s)\n   *\n   * Can be called both with one or many filters, or a filter array.\n   *\n   * @example\n   * command.audioFilters('filter1');\n   *\n   * @example\n   * command.audioFilters('filter1', 'filter2=param1=value1:param2=value2');\n   *\n   * @example\n   * command.audioFilters(['filter1', 'filter2']);\n   *\n   * @example\n   * command.audioFilters([\n   *   {\n   *     filter: 'filter1'\n   *   },\n   *   {\n   *     filter: 'filter2',\n   *     options: 'param=value:param=value'\n   *   }\n   * ]);\n   *\n   * @example\n   * command.audioFilters(\n   *   {\n   *     filter: 'filter1',\n   *     options: ['value1', 'value2']\n   *   },\n   *   {\n   *     filter: 'filter2',\n   *     options: { param1: 'value1', param2: 'value2' }\n   *   }\n   * );\n   *\n   * @method FfmpegCommand#audioFilters\n   * @aliases withAudioFilter,withAudioFilters,audioFilter\n   * @category Audio\n   *\n   * @param {...String|String[]|Object[]} filters audio filter strings, string array or\n   *   filter specification array, each with the following properties:\n   * @param {String} filters.filter filter name\n   * @param {String|String[]|Object} [filters.options] filter option string, array, or object\n   * @return FfmpegCommand\n   */\n  proto.withAudioFilter =\n  proto.withAudioFilters =\n  proto.audioFilter =\n  proto.audioFilters = function(filters) {\n    if (arguments.length > 1) {\n      filters = [].slice.call(arguments);\n    }\n\n    if (!Array.isArray(filters)) {\n      filters = [filters];\n    }\n\n    this._currentOutput.audioFilters(utils.makeFilterStrings(filters));\n    return this;\n  };\n};\n","/*jshint node:true*/\n'use strict';\n\nvar utils = require('../utils');\n\n\n/*\n *! Video-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Disable video in the output\n   *\n   * @method FfmpegCommand#noVideo\n   * @category Video\n   * @aliases withNoVideo\n   *\n   * @return FfmpegCommand\n   */\n  proto.withNoVideo =\n  proto.noVideo = function() {\n    this._currentOutput.video.clear();\n    this._currentOutput.videoFilters.clear();\n    this._currentOutput.video('-vn');\n\n    return this;\n  };\n\n\n  /**\n   * Specify video codec\n   *\n   * @method FfmpegCommand#videoCodec\n   * @category Video\n   * @aliases withVideoCodec\n   *\n   * @param {String} codec video codec name\n   * @return FfmpegCommand\n   */\n  proto.withVideoCodec =\n  proto.videoCodec = function(codec) {\n    this._currentOutput.video('-vcodec', codec);\n    return this;\n  };\n\n\n  /**\n   * Specify video bitrate\n   *\n   * @method FfmpegCommand#videoBitrate\n   * @category Video\n   * @aliases withVideoBitrate\n   *\n   * @param {String|Number} bitrate video bitrate in kbps (with an optional 'k' suffix)\n   * @param {Boolean} [constant=false] enforce constant bitrate\n   * @return FfmpegCommand\n   */\n  proto.withVideoBitrate =\n  proto.videoBitrate = function(bitrate, constant) {\n    bitrate = ('' + bitrate).replace(/k?$/, 'k');\n\n    this._currentOutput.video('-b:v', bitrate);\n    if (constant) {\n      this._currentOutput.video(\n        '-maxrate', bitrate,\n        '-minrate', bitrate,\n        '-bufsize', '3M'\n      );\n    }\n\n    return this;\n  };\n\n\n  /**\n   * Specify custom video filter(s)\n   *\n   * Can be called both with one or many filters, or a filter array.\n   *\n   * @example\n   * command.videoFilters('filter1');\n   *\n   * @example\n   * command.videoFilters('filter1', 'filter2=param1=value1:param2=value2');\n   *\n   * @example\n   * command.videoFilters(['filter1', 'filter2']);\n   *\n   * @example\n   * command.videoFilters([\n   *   {\n   *     filter: 'filter1'\n   *   },\n   *   {\n   *     filter: 'filter2',\n   *     options: 'param=value:param=value'\n   *   }\n   * ]);\n   *\n   * @example\n   * command.videoFilters(\n   *   {\n   *     filter: 'filter1',\n   *     options: ['value1', 'value2']\n   *   },\n   *   {\n   *     filter: 'filter2',\n   *     options: { param1: 'value1', param2: 'value2' }\n   *   }\n   * );\n   *\n   * @method FfmpegCommand#videoFilters\n   * @category Video\n   * @aliases withVideoFilter,withVideoFilters,videoFilter\n   *\n   * @param {...String|String[]|Object[]} filters video filter strings, string array or\n   *   filter specification array, each with the following properties:\n   * @param {String} filters.filter filter name\n   * @param {String|String[]|Object} [filters.options] filter option string, array, or object\n   * @return FfmpegCommand\n   */\n  proto.withVideoFilter =\n  proto.withVideoFilters =\n  proto.videoFilter =\n  proto.videoFilters = function(filters) {\n    if (arguments.length > 1) {\n      filters = [].slice.call(arguments);\n    }\n\n    if (!Array.isArray(filters)) {\n      filters = [filters];\n    }\n\n    this._currentOutput.videoFilters(utils.makeFilterStrings(filters));\n\n    return this;\n  };\n\n\n  /**\n   * Specify output FPS\n   *\n   * @method FfmpegCommand#fps\n   * @category Video\n   * @aliases withOutputFps,withOutputFPS,withFpsOutput,withFPSOutput,withFps,withFPS,outputFPS,outputFps,fpsOutput,FPSOutput,FPS\n   *\n   * @param {Number} fps output FPS\n   * @return FfmpegCommand\n   */\n  proto.withOutputFps =\n  proto.withOutputFPS =\n  proto.withFpsOutput =\n  proto.withFPSOutput =\n  proto.withFps =\n  proto.withFPS =\n  proto.outputFPS =\n  proto.outputFps =\n  proto.fpsOutput =\n  proto.FPSOutput =\n  proto.fps =\n  proto.FPS = function(fps) {\n    this._currentOutput.video('-r', fps);\n    return this;\n  };\n\n\n  /**\n   * Only transcode a certain number of frames\n   *\n   * @method FfmpegCommand#frames\n   * @category Video\n   * @aliases takeFrames,withFrames\n   *\n   * @param {Number} frames frame count\n   * @return FfmpegCommand\n   */\n  proto.takeFrames =\n  proto.withFrames =\n  proto.frames = function(frames) {\n    this._currentOutput.video('-vframes', frames);\n    return this;\n  };\n};\n","/*jshint node:true*/\n'use strict';\n\n/*\n *! Size helpers\n */\n\n\n/**\n * Return filters to pad video to width*height,\n *\n * @param {Number} width output width\n * @param {Number} height output height\n * @param {Number} aspect video aspect ratio (without padding)\n * @param {Number} color padding color\n * @return scale/pad filters\n * @private\n */\nfunction getScalePadFilters(width, height, aspect, color) {\n  /*\n    let a be the input aspect ratio, A be the requested aspect ratio\n\n    if a > A, padding is done on top and bottom\n    if a < A, padding is done on left and right\n   */\n\n  return [\n    /*\n      In both cases, we first have to scale the input to match the requested size.\n      When using computed width/height, we truncate them to multiples of 2\n     */\n    {\n      filter: 'scale',\n      options: {\n        w: 'if(gt(a,' + aspect + '),' + width + ',trunc(' + height + '*a/2)*2)',\n        h: 'if(lt(a,' + aspect + '),' + height + ',trunc(' + width + '/a/2)*2)'\n      }\n    },\n\n    /*\n      Then we pad the scaled input to match the target size\n      (here iw and ih refer to the padding input, i.e the scaled output)\n     */\n\n    {\n      filter: 'pad',\n      options: {\n        w: width,\n        h: height,\n        x: 'if(gt(a,' + aspect + '),0,(' + width + '-iw)/2)',\n        y: 'if(lt(a,' + aspect + '),0,(' + height + '-ih)/2)',\n        color: color\n      }\n    }\n  ];\n}\n\n\n/**\n * Recompute size filters\n *\n * @param {Object} output\n * @param {String} key newly-added parameter name ('size', 'aspect' or 'pad')\n * @param {String} value newly-added parameter value\n * @return filter string array\n * @private\n */\nfunction createSizeFilters(output, key, value) {\n  // Store parameters\n  var data = output.sizeData = output.sizeData || {};\n  data[key] = value;\n\n  if (!('size' in data)) {\n    // No size requested, keep original size\n    return [];\n  }\n\n  // Try to match the different size string formats\n  var fixedSize = data.size.match(/([0-9]+)x([0-9]+)/);\n  var fixedWidth = data.size.match(/([0-9]+)x\\?/);\n  var fixedHeight = data.size.match(/\\?x([0-9]+)/);\n  var percentRatio = data.size.match(/\\b([0-9]{1,3})%/);\n  var width, height, aspect;\n\n  if (percentRatio) {\n    var ratio = Number(percentRatio[1]) / 100;\n    return [{\n      filter: 'scale',\n      options: {\n        w: 'trunc(iw*' + ratio + '/2)*2',\n        h: 'trunc(ih*' + ratio + '/2)*2'\n      }\n    }];\n  } else if (fixedSize) {\n    // Round target size to multiples of 2\n    width = Math.round(Number(fixedSize[1]) / 2) * 2;\n    height = Math.round(Number(fixedSize[2]) / 2) * 2;\n\n    aspect = width / height;\n\n    if (data.pad) {\n      return getScalePadFilters(width, height, aspect, data.pad);\n    } else {\n      // No autopad requested, rescale to target size\n      return [{ filter: 'scale', options: { w: width, h: height }}];\n    }\n  } else if (fixedWidth || fixedHeight) {\n    if ('aspect' in data) {\n      // Specified aspect ratio\n      width = fixedWidth ? fixedWidth[1] : Math.round(Number(fixedHeight[1]) * data.aspect);\n      height = fixedHeight ? fixedHeight[1] : Math.round(Number(fixedWidth[1]) / data.aspect);\n\n      // Round to multiples of 2\n      width = Math.round(width / 2) * 2;\n      height = Math.round(height / 2) * 2;\n\n      if (data.pad) {\n        return getScalePadFilters(width, height, data.aspect, data.pad);\n      } else {\n        // No autopad requested, rescale to target size\n        return [{ filter: 'scale', options: { w: width, h: height }}];\n      }\n    } else {\n      // Keep input aspect ratio\n\n      if (fixedWidth) {\n        return [{\n          filter: 'scale',\n          options: {\n            w: Math.round(Number(fixedWidth[1]) / 2) * 2,\n            h: 'trunc(ow/a/2)*2'\n          }\n        }];\n      } else {\n        return [{\n          filter: 'scale',\n          options: {\n            w: 'trunc(oh*a/2)*2',\n            h: Math.round(Number(fixedHeight[1]) / 2) * 2\n          }\n        }];\n      }\n    }\n  } else {\n    throw new Error('Invalid size specified: ' + data.size);\n  }\n}\n\n\n/*\n *! Video size-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Keep display aspect ratio\n   *\n   * This method is useful when converting an input with non-square pixels to an output format\n   * that does not support non-square pixels.  It rescales the input so that the display aspect\n   * ratio is the same.\n   *\n   * @method FfmpegCommand#keepDAR\n   * @category Video size\n   * @aliases keepPixelAspect,keepDisplayAspect,keepDisplayAspectRatio\n   *\n   * @return FfmpegCommand\n   */\n  proto.keepPixelAspect = // Only for compatibility, this is not about keeping _pixel_ aspect ratio\n  proto.keepDisplayAspect =\n  proto.keepDisplayAspectRatio =\n  proto.keepDAR = function() {\n    return this.videoFilters([\n      {\n        filter: 'scale',\n        options: {\n          w: 'if(gt(sar,1),iw*sar,iw)',\n          h: 'if(lt(sar,1),ih/sar,ih)'\n        }\n      },\n      {\n        filter: 'setsar',\n        options: '1'\n      }\n    ]);\n  };\n\n\n  /**\n   * Set output size\n   *\n   * The 'size' parameter can have one of 4 forms:\n   * - 'X%': rescale to xx % of the original size\n   * - 'WxH': specify width and height\n   * - 'Wx?': specify width and compute height from input aspect ratio\n   * - '?xH': specify height and compute width from input aspect ratio\n   *\n   * Note: both dimensions will be truncated to multiples of 2.\n   *\n   * @method FfmpegCommand#size\n   * @category Video size\n   * @aliases withSize,setSize\n   *\n   * @param {String} size size string, eg. '33%', '320x240', '320x?', '?x240'\n   * @return FfmpegCommand\n   */\n  proto.withSize =\n  proto.setSize =\n  proto.size = function(size) {\n    var filters = createSizeFilters(this._currentOutput, 'size', size);\n\n    this._currentOutput.sizeFilters.clear();\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n\n\n  /**\n   * Set output aspect ratio\n   *\n   * @method FfmpegCommand#aspect\n   * @category Video size\n   * @aliases withAspect,withAspectRatio,setAspect,setAspectRatio,aspectRatio\n   *\n   * @param {String|Number} aspect aspect ratio (number or 'X:Y' string)\n   * @return FfmpegCommand\n   */\n  proto.withAspect =\n  proto.withAspectRatio =\n  proto.setAspect =\n  proto.setAspectRatio =\n  proto.aspect =\n  proto.aspectRatio = function(aspect) {\n    var a = Number(aspect);\n    if (isNaN(a)) {\n      var match = aspect.match(/^(\\d+):(\\d+)$/);\n      if (match) {\n        a = Number(match[1]) / Number(match[2]);\n      } else {\n        throw new Error('Invalid aspect ratio: ' + aspect);\n      }\n    }\n\n    var filters = createSizeFilters(this._currentOutput, 'aspect', a);\n\n    this._currentOutput.sizeFilters.clear();\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n\n\n  /**\n   * Enable auto-padding the output\n   *\n   * @method FfmpegCommand#autopad\n   * @category Video size\n   * @aliases applyAutopadding,applyAutoPadding,applyAutopad,applyAutoPad,withAutopadding,withAutoPadding,withAutopad,withAutoPad,autoPad\n   *\n   * @param {Boolean} [pad=true] enable/disable auto-padding\n   * @param {String} [color='black'] pad color\n   */\n  proto.applyAutopadding =\n  proto.applyAutoPadding =\n  proto.applyAutopad =\n  proto.applyAutoPad =\n  proto.withAutopadding =\n  proto.withAutoPadding =\n  proto.withAutopad =\n  proto.withAutoPad =\n  proto.autoPad =\n  proto.autopad = function(pad, color) {\n    // Allow autopad(color)\n    if (typeof pad === 'string') {\n      color = pad;\n      pad = true;\n    }\n\n    // Allow autopad() and autopad(undefined, color)\n    if (typeof pad === 'undefined') {\n      pad = true;\n    }\n\n    var filters = createSizeFilters(this._currentOutput, 'pad', pad ? color || 'black' : false);\n\n    this._currentOutput.sizeFilters.clear();\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n};\n","/*jshint node:true*/\n'use strict';\n\nvar utils = require('../utils');\n\n\n/*\n *! Output-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Add output\n   *\n   * @method FfmpegCommand#output\n   * @category Output\n   * @aliases addOutput\n   *\n   * @param {String|Writable} target target file path or writable stream\n   * @param {Object} [pipeopts={}] pipe options (only applies to streams)\n   * @return FfmpegCommand\n   */\n  proto.addOutput =\n  proto.output = function(target, pipeopts) {\n    var isFile = false;\n\n    if (!target && this._currentOutput) {\n      // No target is only allowed when called from constructor\n      throw new Error('Invalid output');\n    }\n\n    if (target && typeof target !== 'string') {\n      if (!('writable' in target) || !(target.writable)) {\n        throw new Error('Invalid output');\n      }\n    } else if (typeof target === 'string') {\n      var protocol = target.match(/^([a-z]{2,}):/i);\n      isFile = !protocol || protocol[0] === 'file';\n    }\n\n    if (target && !('target' in this._currentOutput)) {\n      // For backwards compatibility, set target for first output\n      this._currentOutput.target = target;\n      this._currentOutput.isFile = isFile;\n      this._currentOutput.pipeopts = pipeopts || {};\n    } else {\n      if (target && typeof target !== 'string') {\n        var hasOutputStream = this._outputs.some(function(output) {\n          return typeof output.target !== 'string';\n        });\n\n        if (hasOutputStream) {\n          throw new Error('Only one output stream is supported');\n        }\n      }\n\n      this._outputs.push(this._currentOutput = {\n        target: target,\n        isFile: isFile,\n        flags: {},\n        pipeopts: pipeopts || {}\n      });\n\n      var self = this;\n      ['audio', 'audioFilters', 'video', 'videoFilters', 'sizeFilters', 'options'].forEach(function(key) {\n        self._currentOutput[key] = utils.args();\n      });\n\n      if (!target) {\n        // Call from constructor: remove target key\n        delete this._currentOutput.target;\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * Specify output seek time\n   *\n   * @method FfmpegCommand#seek\n   * @category Input\n   * @aliases seekOutput\n   *\n   * @param {String|Number} seek seek time in seconds or as a '[hh:[mm:]]ss[.xxx]' string\n   * @return FfmpegCommand\n   */\n  proto.seekOutput =\n  proto.seek = function(seek) {\n    this._currentOutput.options('-ss', seek);\n    return this;\n  };\n\n\n  /**\n   * Set output duration\n   *\n   * @method FfmpegCommand#duration\n   * @category Output\n   * @aliases withDuration,setDuration\n   *\n   * @param {String|Number} duration duration in seconds or as a '[[hh:]mm:]ss[.xxx]' string\n   * @return FfmpegCommand\n   */\n  proto.withDuration =\n  proto.setDuration =\n  proto.duration = function(duration) {\n    this._currentOutput.options('-t', duration);\n    return this;\n  };\n\n\n  /**\n   * Set output format\n   *\n   * @method FfmpegCommand#format\n   * @category Output\n   * @aliases toFormat,withOutputFormat,outputFormat\n   *\n   * @param {String} format output format name\n   * @return FfmpegCommand\n   */\n  proto.toFormat =\n  proto.withOutputFormat =\n  proto.outputFormat =\n  proto.format = function(format) {\n    this._currentOutput.options('-f', format);\n    return this;\n  };\n\n\n  /**\n   * Add stream mapping to output\n   *\n   * @method FfmpegCommand#map\n   * @category Output\n   *\n   * @param {String} spec stream specification string, with optional square brackets\n   * @return FfmpegCommand\n   */\n  proto.map = function(spec) {\n    this._currentOutput.options('-map', spec.replace(utils.streamRegexp, '[$1]'));\n    return this;\n  };\n\n\n  /**\n   * Run flvtool2/flvmeta on output\n   *\n   * @method FfmpegCommand#flvmeta\n   * @category Output\n   * @aliases updateFlvMetadata\n   *\n   * @return FfmpegCommand\n   */\n  proto.updateFlvMetadata =\n  proto.flvmeta = function() {\n    this._currentOutput.flags.flvmeta = true;\n    return this;\n  };\n};\n","/*jshint node:true*/\n'use strict';\n\nvar utils = require('../utils');\n\n\n/*\n *! Custom options methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Add custom input option(s)\n   *\n   * When passing a single string or an array, each string containing two\n   * words is split (eg. inputOptions('-option value') is supported) for\n   * compatibility reasons.  This is not the case when passing more than\n   * one argument.\n   *\n   * @example\n   * command.inputOptions('option1');\n   *\n   * @example\n   * command.inputOptions('option1', 'option2');\n   *\n   * @example\n   * command.inputOptions(['option1', 'option2']);\n   *\n   * @method FfmpegCommand#inputOptions\n   * @category Custom options\n   * @aliases addInputOption,addInputOptions,withInputOption,withInputOptions,inputOption\n   *\n   * @param {...String} options option string(s) or string array\n   * @return FfmpegCommand\n   */\n  proto.addInputOption =\n  proto.addInputOptions =\n  proto.withInputOption =\n  proto.withInputOptions =\n  proto.inputOption =\n  proto.inputOptions = function(options) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    var doSplit = true;\n\n    if (arguments.length > 1) {\n      options = [].slice.call(arguments);\n      doSplit = false;\n    }\n\n    if (!Array.isArray(options)) {\n      options = [options];\n    }\n\n    this._currentInput.options(options.reduce(function(options, option) {\n      var split = String(option).split(' ');\n\n      if (doSplit && split.length === 2) {\n        options.push(split[0], split[1]);\n      } else {\n        options.push(option);\n      }\n\n      return options;\n    }, []));\n    return this;\n  };\n\n\n  /**\n   * Add custom output option(s)\n   *\n   * @example\n   * command.outputOptions('option1');\n   *\n   * @example\n   * command.outputOptions('option1', 'option2');\n   *\n   * @example\n   * command.outputOptions(['option1', 'option2']);\n   *\n   * @method FfmpegCommand#outputOptions\n   * @category Custom options\n   * @aliases addOutputOption,addOutputOptions,addOption,addOptions,withOutputOption,withOutputOptions,withOption,withOptions,outputOption\n   *\n   * @param {...String} options option string(s) or string array\n   * @return FfmpegCommand\n   */\n  proto.addOutputOption =\n  proto.addOutputOptions =\n  proto.addOption =\n  proto.addOptions =\n  proto.withOutputOption =\n  proto.withOutputOptions =\n  proto.withOption =\n  proto.withOptions =\n  proto.outputOption =\n  proto.outputOptions = function(options) {\n    var doSplit = true;\n\n    if (arguments.length > 1) {\n      options = [].slice.call(arguments);\n      doSplit = false;\n    }\n\n    if (!Array.isArray(options)) {\n      options = [options];\n    }\n\n    this._currentOutput.options(options.reduce(function(options, option) {\n      var split = String(option).split(' ');\n\n      if (doSplit && split.length === 2) {\n        options.push(split[0], split[1]);\n      } else {\n        options.push(option);\n      }\n\n      return options;\n    }, []));\n    return this;\n  };\n\n\n  /**\n   * Specify a complex filtergraph\n   *\n   * Calling this method will override any previously set filtergraph, but you can set\n   * as many filters as needed in one call.\n   *\n   * @example <caption>Overlay an image over a video (using a filtergraph string)</caption>\n   *   ffmpeg()\n   *     .input('video.avi')\n   *     .input('image.png')\n   *     .complexFilter('[0:v][1:v]overlay[out]', ['out']);\n   *\n   * @example <caption>Overlay an image over a video (using a filter array)</caption>\n   *   ffmpeg()\n   *     .input('video.avi')\n   *     .input('image.png')\n   *     .complexFilter([{\n   *       filter: 'overlay',\n   *       inputs: ['0:v', '1:v'],\n   *       outputs: ['out']\n   *     }], ['out']);\n   *\n   * @example <caption>Split video into RGB channels and output a 3x1 video with channels side to side</caption>\n   *  ffmpeg()\n   *    .input('video.avi')\n   *    .complexFilter([\n   *      // Duplicate video stream 3 times into streams a, b, and c\n   *      { filter: 'split', options: '3', outputs: ['a', 'b', 'c'] },\n   *\n   *      // Create stream 'red' by cancelling green and blue channels from stream 'a'\n   *      { filter: 'lutrgb', options: { g: 0, b: 0 }, inputs: 'a', outputs: 'red' },\n   *\n   *      // Create stream 'green' by cancelling red and blue channels from stream 'b'\n   *      { filter: 'lutrgb', options: { r: 0, b: 0 }, inputs: 'b', outputs: 'green' },\n   *\n   *      // Create stream 'blue' by cancelling red and green channels from stream 'c'\n   *      { filter: 'lutrgb', options: { r: 0, g: 0 }, inputs: 'c', outputs: 'blue' },\n   *\n   *      // Pad stream 'red' to 3x width, keeping the video on the left, and name output 'padded'\n   *      { filter: 'pad', options: { w: 'iw*3', h: 'ih' }, inputs: 'red', outputs: 'padded' },\n   *\n   *      // Overlay 'green' onto 'padded', moving it to the center, and name output 'redgreen'\n   *      { filter: 'overlay', options: { x: 'w', y: 0 }, inputs: ['padded', 'green'], outputs: 'redgreen'},\n   *\n   *      // Overlay 'blue' onto 'redgreen', moving it to the right\n   *      { filter: 'overlay', options: { x: '2*w', y: 0 }, inputs: ['redgreen', 'blue']},\n   *    ]);\n   *\n   * @method FfmpegCommand#complexFilter\n   * @category Custom options\n   * @aliases filterGraph\n   *\n   * @param {String|Array} spec filtergraph string or array of filter specification\n   *   objects, each having the following properties:\n   * @param {String} spec.filter filter name\n   * @param {String|Array} [spec.inputs] (array of) input stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically choosing the first unused matching streams\n   * @param {String|Array} [spec.outputs] (array of) output stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically assigning the output to the output file\n   * @param {Object|String|Array} [spec.options] filter options, can be omitted to not set any options\n   * @param {Array} [map] (array of) stream specifier(s) from the graph to include in\n   *   ffmpeg output, defaults to ffmpeg automatically choosing the first matching streams.\n   * @return FfmpegCommand\n   */\n  proto.filterGraph =\n  proto.complexFilter = function(spec, map) {\n    this._complexFilters.clear();\n\n    if (!Array.isArray(spec)) {\n      spec = [spec];\n    }\n\n    this._complexFilters('-filter_complex', utils.makeFilterStrings(spec).join(';'));\n\n    if (Array.isArray(map)) {\n      var self = this;\n      map.forEach(function(streamSpec) {\n        self._complexFilters('-map', streamSpec.replace(utils.streamRegexp, '[$1]'));\n      });\n    } else if (typeof map === 'string') {\n      this._complexFilters('-map', map.replace(utils.streamRegexp, '[$1]'));\n    }\n\n    return this;\n  };\n};\n","/*jshint node:true*/\n'use strict';\n\nvar path = require('path');\n\n/*\n *! Miscellaneous methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Use preset\n   *\n   * @method FfmpegCommand#preset\n   * @category Miscellaneous\n   * @aliases usingPreset\n   *\n   * @param {String|Function} preset preset name or preset function\n   */\n  proto.usingPreset =\n  proto.preset = function(preset) {\n    if (typeof preset === 'function') {\n      preset(this);\n    } else {\n      try {\n        var modulePath = path.join(this.options.presets, preset);\n        var module = require(modulePath);\n\n        if (typeof module.load === 'function') {\n          module.load(this);\n        } else {\n          throw new Error('preset ' + modulePath + ' has no load() function');\n        }\n      } catch (err) {\n        throw new Error('preset ' + modulePath + ' could not be loaded: ' + err.message);\n      }\n    }\n\n    return this;\n  };\n};\n","/*jshint node:true*/\n'use strict';\n\nvar spawn = require('child_process').spawn;\nvar path = require('path');\nvar fs = require('fs');\nvar async = require('async');\nvar utils = require('./utils');\n\nvar nlRegexp = /\\r\\n|\\r|\\n/g;\n\n/*\n *! Processor methods\n */\n\n\n/**\n * Run ffprobe asynchronously and store data in command\n *\n * @param {FfmpegCommand} command\n * @private\n */\nfunction runFfprobe(command) {\n  const inputProbeIndex = 0;\n  if (command._inputs[inputProbeIndex].isStream) {\n    // Don't probe input streams as this will consume them\n    return;\n  }\n  command.ffprobe(inputProbeIndex, function(err, data) {\n    command._ffprobeData = data;\n  });\n}\n\n\nmodule.exports = function(proto) {\n  /**\n   * Emitted just after ffmpeg has been spawned.\n   *\n   * @event FfmpegCommand#start\n   * @param {String} command ffmpeg command line\n   */\n\n  /**\n   * Emitted when ffmpeg reports progress information\n   *\n   * @event FfmpegCommand#progress\n   * @param {Object} progress progress object\n   * @param {Number} progress.frames number of frames transcoded\n   * @param {Number} progress.currentFps current processing speed in frames per second\n   * @param {Number} progress.currentKbps current output generation speed in kilobytes per second\n   * @param {Number} progress.targetSize current output file size\n   * @param {String} progress.timemark current video timemark\n   * @param {Number} [progress.percent] processing progress (may not be available depending on input)\n   */\n\n  /**\n   * Emitted when ffmpeg outputs to stderr\n   *\n   * @event FfmpegCommand#stderr\n   * @param {String} line stderr output line\n   */\n\n  /**\n   * Emitted when ffmpeg reports input codec data\n   *\n   * @event FfmpegCommand#codecData\n   * @param {Object} codecData codec data object\n   * @param {String} codecData.format input format name\n   * @param {String} codecData.audio input audio codec name\n   * @param {String} codecData.audio_details input audio codec parameters\n   * @param {String} codecData.video input video codec name\n   * @param {String} codecData.video_details input video codec parameters\n   */\n\n  /**\n   * Emitted when an error happens when preparing or running a command\n   *\n   * @event FfmpegCommand#error\n   * @param {Error} error error object, with optional properties 'inputStreamError' / 'outputStreamError' for errors on their respective streams\n   * @param {String|null} stdout ffmpeg stdout, unless outputting to a stream\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n  /**\n   * Emitted when a command finishes processing\n   *\n   * @event FfmpegCommand#end\n   * @param {Array|String|null} [filenames|stdout] generated filenames when taking screenshots, ffmpeg stdout when not outputting to a stream, null otherwise\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n\n  /**\n   * Spawn an ffmpeg process\n   *\n   * The 'options' argument may contain the following keys:\n   * - 'niceness': specify process niceness, ignored on Windows (default: 0)\n   * - `cwd`: change working directory\n   * - 'captureStdout': capture stdout and pass it to 'endCB' as its 2nd argument (default: false)\n   * - 'stdoutLines': override command limit (default: use command limit)\n   *\n   * The 'processCB' callback, if present, is called as soon as the process is created and\n   * receives a nodejs ChildProcess object.  It may not be called at all if an error happens\n   * before spawning the process.\n   *\n   * The 'endCB' callback is called either when an error occurs or when the ffmpeg process finishes.\n   *\n   * @method FfmpegCommand#_spawnFfmpeg\n   * @param {Array} args ffmpeg command line argument list\n   * @param {Object} [options] spawn options (see above)\n   * @param {Function} [processCB] callback called with process object and stdout/stderr ring buffers when process has been created\n   * @param {Function} endCB callback called with error (if applicable) and stdout/stderr ring buffers when process finished\n   * @private\n   */\n  proto._spawnFfmpeg = function(args, options, processCB, endCB) {\n    // Enable omitting options\n    if (typeof options === 'function') {\n      endCB = processCB;\n      processCB = options;\n      options = {};\n    }\n\n    // Enable omitting processCB\n    if (typeof endCB === 'undefined') {\n      endCB = processCB;\n      processCB = function() {};\n    }\n\n    var maxLines = 'stdoutLines' in options ? options.stdoutLines : this.options.stdoutLines;\n\n    // Find ffmpeg\n    this._getFfmpegPath(function(err, command) {\n      if (err) {\n        return endCB(err);\n      } else if (!command || command.length === 0) {\n        return endCB(new Error('Cannot find ffmpeg'));\n      }\n\n      // Apply niceness\n      if (options.niceness && options.niceness !== 0 && !utils.isWindows) {\n        args.unshift('-n', options.niceness, command);\n        command = 'nice';\n      }\n\n      var stdoutRing = utils.linesRing(maxLines);\n      var stdoutClosed = false;\n\n      var stderrRing = utils.linesRing(maxLines);\n      var stderrClosed = false;\n\n      // Spawn process\n      var ffmpegProc = spawn(command, args, options);\n\n      if (ffmpegProc.stderr) {\n        ffmpegProc.stderr.setEncoding('utf8');\n      }\n\n      ffmpegProc.on('error', function(err) {\n        endCB(err);\n      });\n\n      // Ensure we wait for captured streams to end before calling endCB\n      var exitError = null;\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n\n        if (processExited && (stdoutClosed || !options.captureStdout) && stderrClosed) {\n          endCB(exitError, stdoutRing, stderrRing);\n        }\n      }\n\n      // Handle process exit\n      var processExited = false;\n      ffmpegProc.on('exit', function(code, signal) {\n        processExited = true;\n\n        if (signal) {\n          handleExit(new Error('ffmpeg was killed with signal ' + signal));\n        } else if (code) {\n          handleExit(new Error('ffmpeg exited with code ' + code));\n        } else {\n          handleExit();\n        }\n      });\n\n      // Capture stdout if specified\n      if (options.captureStdout) {\n        ffmpegProc.stdout.on('data', function(data) {\n          stdoutRing.append(data);\n        });\n\n        ffmpegProc.stdout.on('close', function() {\n          stdoutRing.close();\n          stdoutClosed = true;\n          handleExit();\n        });\n      }\n\n      // Capture stderr if specified\n      ffmpegProc.stderr.on('data', function(data) {\n        stderrRing.append(data);\n      });\n\n      ffmpegProc.stderr.on('close', function() {\n        stderrRing.close();\n        stderrClosed = true;\n        handleExit();\n      });\n\n      // Call process callback\n      processCB(ffmpegProc, stdoutRing, stderrRing);\n    });\n  };\n\n\n  /**\n   * Build the argument list for an ffmpeg command\n   *\n   * @method FfmpegCommand#_getArguments\n   * @return argument list\n   * @private\n   */\n  proto._getArguments = function() {\n    var complexFilters = this._complexFilters.get();\n\n    var fileOutput = this._outputs.some(function(output) {\n      return output.isFile;\n    });\n\n    return [].concat(\n        // Inputs and input options\n        this._inputs.reduce(function(args, input) {\n          var source = (typeof input.source === 'string') ? input.source : 'pipe:0';\n\n          // For each input, add input options, then '-i <source>'\n          return args.concat(\n            input.options.get(),\n            ['-i', source]\n          );\n        }, []),\n\n        // Global options\n        this._global.get(),\n\n        // Overwrite if we have file outputs\n        fileOutput ? ['-y'] : [],\n\n        // Complex filters\n        complexFilters,\n\n        // Outputs, filters and output options\n        this._outputs.reduce(function(args, output) {\n          var sizeFilters = utils.makeFilterStrings(output.sizeFilters.get());\n          var audioFilters = output.audioFilters.get();\n          var videoFilters = output.videoFilters.get().concat(sizeFilters);\n          var outputArg;\n\n          if (!output.target) {\n            outputArg = [];\n          } else if (typeof output.target === 'string') {\n            outputArg = [output.target];\n          } else {\n            outputArg = ['pipe:1'];\n          }\n\n          return args.concat(\n            output.audio.get(),\n            audioFilters.length ? ['-filter:a', audioFilters.join(',')] : [],\n            output.video.get(),\n            videoFilters.length ? ['-filter:v', videoFilters.join(',')] : [],\n            output.options.get(),\n            outputArg\n          );\n        }, [])\n      );\n  };\n\n\n  /**\n   * Prepare execution of an ffmpeg command\n   *\n   * Checks prerequisites for the execution of the command (codec/format availability, flvtool...),\n   * then builds the argument list for ffmpeg and pass them to 'callback'.\n   *\n   * @method FfmpegCommand#_prepare\n   * @param {Function} callback callback with signature (err, args)\n   * @param {Boolean} [readMetadata=false] read metadata before processing\n   * @private\n   */\n  proto._prepare = function(callback, readMetadata) {\n    var self = this;\n\n    async.waterfall([\n      // Check codecs and formats\n      function(cb) {\n        self._checkCapabilities(cb);\n      },\n\n      // Read metadata if required\n      function(cb) {\n        if (!readMetadata) {\n          return cb();\n        }\n\n        self.ffprobe(0, function(err, data) {\n          if (!err) {\n            self._ffprobeData = data;\n          }\n\n          cb();\n        });\n      },\n\n      // Check for flvtool2/flvmeta if necessary\n      function(cb) {\n        var flvmeta = self._outputs.some(function(output) {\n          // Remove flvmeta flag on non-file output\n          if (output.flags.flvmeta && !output.isFile) {\n            self.logger.warn('Updating flv metadata is only supported for files');\n            output.flags.flvmeta = false;\n          }\n\n          return output.flags.flvmeta;\n        });\n\n        if (flvmeta) {\n          self._getFlvtoolPath(function(err) {\n            cb(err);\n          });\n        } else {\n          cb();\n        }\n      },\n\n      // Build argument list\n      function(cb) {\n        var args;\n        try {\n          args = self._getArguments();\n        } catch(e) {\n          return cb(e);\n        }\n\n        cb(null, args);\n      },\n\n      // Add \"-strict experimental\" option where needed\n      function(args, cb) {\n        self.availableEncoders(function(err, encoders) {\n          for (var i = 0; i < args.length; i++) {\n            if (args[i] === '-acodec' || args[i] === '-vcodec') {\n              i++;\n\n              if ((args[i] in encoders) && encoders[args[i]].experimental) {\n                args.splice(i + 1, 0, '-strict', 'experimental');\n                i += 2;\n              }\n            }\n          }\n\n          cb(null, args);\n        });\n      }\n    ], callback);\n\n    if (!readMetadata) {\n      // Read metadata as soon as 'progress' listeners are added\n\n      if (this.listeners('progress').length > 0) {\n        // Read metadata in parallel\n        runFfprobe(this);\n      } else {\n        // Read metadata as soon as the first 'progress' listener is added\n        this.once('newListener', function(event) {\n          if (event === 'progress') {\n            runFfprobe(this);\n          }\n        });\n      }\n    }\n  };\n\n\n  /**\n   * Run ffmpeg command\n   *\n   * @method FfmpegCommand#run\n   * @category Processing\n   * @aliases exec,execute\n   */\n  proto.exec =\n  proto.execute =\n  proto.run = function() {\n    var self = this;\n\n    // Check if at least one output is present\n    var outputPresent = this._outputs.some(function(output) {\n      return 'target' in output;\n    });\n\n    if (!outputPresent) {\n      throw new Error('No output specified');\n    }\n\n    // Get output stream if any\n    var outputStream = this._outputs.filter(function(output) {\n      return typeof output.target !== 'string';\n    })[0];\n\n    // Get input stream if any\n    var inputStream = this._inputs.filter(function(input) {\n      return typeof input.source !== 'string';\n    })[0];\n\n    // Ensure we send 'end' or 'error' only once\n    var ended = false;\n    function emitEnd(err, stdout, stderr) {\n      if (!ended) {\n        ended = true;\n\n        if (err) {\n          self.emit('error', err, stdout, stderr);\n        } else {\n          self.emit('end', stdout, stderr);\n        }\n      }\n    }\n\n    self._prepare(function(err, args) {\n      if (err) {\n        return emitEnd(err);\n      }\n\n      // Run ffmpeg\n      self._spawnFfmpeg(\n        args,\n        {\n          captureStdout: !outputStream,\n          niceness: self.options.niceness,\n          cwd: self.options.cwd\n        },\n\n        function processCB(ffmpegProc, stdoutRing, stderrRing) {\n          self.ffmpegProc = ffmpegProc;\n          self.emit('start', 'ffmpeg ' + args.join(' '));\n\n          // Pipe input stream if any\n          if (inputStream) {\n            inputStream.source.on('error', function(err) {\n              var reportingErr = new Error('Input stream error: ' + err.message);\n              reportingErr.inputStreamError = err;\n              emitEnd(reportingErr);\n              ffmpegProc.kill();\n            });\n\n            inputStream.source.resume();\n            inputStream.source.pipe(ffmpegProc.stdin);\n\n            // Set stdin error handler on ffmpeg (prevents nodejs catching the error, but\n            // ffmpeg will fail anyway, so no need to actually handle anything)\n            ffmpegProc.stdin.on('error', function() {});\n          }\n\n          // Setup timeout if requested\n          var processTimer;\n          if (self.options.timeout) {\n            processTimer = setTimeout(function() {\n              var msg = 'process ran into a timeout (' + self.options.timeout + 's)';\n\n              emitEnd(new Error(msg), stdoutRing.get(), stderrRing.get());\n              ffmpegProc.kill();\n            }, self.options.timeout * 1000);\n          }\n\n\n          if (outputStream) {\n            // Pipe ffmpeg stdout to output stream\n            ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts);\n\n            // Handle output stream events\n            outputStream.target.on('close', function() {\n              self.logger.debug('Output stream closed, scheduling kill for ffmpeg process');\n\n              // Don't kill process yet, to give a chance to ffmpeg to\n              // terminate successfully first  This is necessary because\n              // under load, the process 'exit' event sometimes happens\n              // after the output stream 'close' event.\n              setTimeout(function() {\n                emitEnd(new Error('Output stream closed'));\n                ffmpegProc.kill();\n              }, 20);\n            });\n\n            outputStream.target.on('error', function(err) {\n              self.logger.debug('Output stream error, killing ffmpeg process');\n              var reportingErr = new Error('Output stream error: ' + err.message);\n              reportingErr.outputStreamError = err;\n              emitEnd(reportingErr, stdoutRing.get(), stderrRing.get());\n              ffmpegProc.kill('SIGKILL');\n            });\n          }\n\n          // Setup stderr handling\n          if (stderrRing) {\n\n            // 'stderr' event\n            if (self.listeners('stderr').length) {\n              stderrRing.callback(function(line) {\n                self.emit('stderr', line);\n              });\n            }\n\n            // 'codecData' event\n            if (self.listeners('codecData').length) {\n              var codecDataSent = false;\n              var codecObject = {};\n\n              stderrRing.callback(function(line) {\n                if (!codecDataSent)\n                  codecDataSent = utils.extractCodecData(self, line, codecObject);\n              });\n            }\n\n            // 'progress' event\n            if (self.listeners('progress').length) {\n              stderrRing.callback(function(line) {\n                utils.extractProgress(self, line);\n              });\n            }\n          }\n        },\n\n        function endCB(err, stdoutRing, stderrRing) {\n          delete self.ffmpegProc;\n\n          if (err) {\n            if (err.message.match(/ffmpeg exited with code/)) {\n              // Add ffmpeg error message\n              err.message += ': ' + utils.extractError(stderrRing.get());\n            }\n\n            emitEnd(err, stdoutRing.get(), stderrRing.get());\n          } else {\n            // Find out which outputs need flv metadata\n            var flvmeta = self._outputs.filter(function(output) {\n              return output.flags.flvmeta;\n            });\n\n            if (flvmeta.length) {\n              self._getFlvtoolPath(function(err, flvtool) {\n                if (err) {\n                  return emitEnd(err);\n                }\n\n                async.each(\n                  flvmeta,\n                  function(output, cb) {\n                    spawn(flvtool, ['-U', output.target])\n                      .on('error', function(err) {\n                        cb(new Error('Error running ' + flvtool + ' on ' + output.target + ': ' + err.message));\n                      })\n                      .on('exit', function(code, signal) {\n                        if (code !== 0 || signal) {\n                          cb(\n                            new Error(flvtool + ' ' +\n                              (signal ? 'received signal ' + signal\n                                      : 'exited with code ' + code)) +\n                              ' when running on ' + output.target\n                          );\n                        } else {\n                          cb();\n                        }\n                      });\n                  },\n                  function(err) {\n                    if (err) {\n                      emitEnd(err);\n                    } else {\n                      emitEnd(null, stdoutRing.get(), stderrRing.get());\n                    }\n                  }\n                );\n              });\n            } else {\n              emitEnd(null, stdoutRing.get(), stderrRing.get());\n            }\n          }\n        }\n      );\n    });\n  };\n\n\n  /**\n   * Renice current and/or future ffmpeg processes\n   *\n   * Ignored on Windows platforms.\n   *\n   * @method FfmpegCommand#renice\n   * @category Processing\n   *\n   * @param {Number} [niceness=0] niceness value between -20 (highest priority) and 20 (lowest priority)\n   * @return FfmpegCommand\n   */\n  proto.renice = function(niceness) {\n    if (!utils.isWindows) {\n      niceness = niceness || 0;\n\n      if (niceness < -20 || niceness > 20) {\n        this.logger.warn('Invalid niceness value: ' + niceness + ', must be between -20 and 20');\n      }\n\n      niceness = Math.min(20, Math.max(-20, niceness));\n      this.options.niceness = niceness;\n\n      if (this.ffmpegProc) {\n        var logger = this.logger;\n        var pid = this.ffmpegProc.pid;\n        var renice = spawn('renice', [niceness, '-p', pid]);\n\n        renice.on('error', function(err) {\n          logger.warn('could not renice process ' + pid + ': ' + err.message);\n        });\n\n        renice.on('exit', function(code, signal) {\n          if (signal) {\n            logger.warn('could not renice process ' + pid + ': renice was killed by signal ' + signal);\n          } else if (code) {\n            logger.warn('could not renice process ' + pid + ': renice exited with ' + code);\n          } else {\n            logger.info('successfully reniced process ' + pid + ' to ' + niceness + ' niceness');\n          }\n        });\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * Kill current ffmpeg process, if any\n   *\n   * @method FfmpegCommand#kill\n   * @category Processing\n   *\n   * @param {String} [signal=SIGKILL] signal name\n   * @return FfmpegCommand\n   */\n  proto.kill = function(signal) {\n    if (!this.ffmpegProc) {\n      this.logger.warn('No running ffmpeg process, cannot send signal');\n    } else {\n      this.ffmpegProc.kill(signal || 'SIGKILL');\n    }\n\n    return this;\n  };\n};\n","/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} fn - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @returns {Function} the partially-applied function\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */\nfunction apply(fn, ...args) {\n    return (...callArgs) => fn(...args,...callArgs);\n}\n\nfunction initialParams (fn) {\n    return function (...args/*, callback*/) {\n        var callback = args.pop();\n        return fn.call(this, args, callback);\n    };\n}\n\n/* istanbul ignore file */\n\nvar hasQueueMicrotask = typeof queueMicrotask === 'function' && queueMicrotask;\nvar hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return (fn, ...args) => defer(() => fn(...args));\n}\n\nvar _defer;\n\nif (hasQueueMicrotask) {\n    _defer = queueMicrotask;\n} else if (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nvar setImmediate$1 = wrap(_defer);\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    if (isAsync(func)) {\n        return function (...args/*, callback*/) {\n            const callback = args.pop();\n            const promise = func.apply(this, args);\n            return handlePromise(promise, callback)\n        }\n    }\n\n    return initialParams(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (result && typeof result.then === 'function') {\n            return handlePromise(result, callback)\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction handlePromise(promise, callback) {\n    return promise.then(value => {\n        invokeCallback(callback, null, value);\n    }, err => {\n        invokeCallback(callback, err && err.message ? err : new Error(err));\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (err) {\n        setImmediate$1(e => { throw e }, err);\n    }\n}\n\nfunction isAsync(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction isAsyncGenerator(fn) {\n    return fn[Symbol.toStringTag] === 'AsyncGenerator';\n}\n\nfunction isAsyncIterable(obj) {\n    return typeof obj[Symbol.asyncIterator] === 'function';\n}\n\nfunction wrapAsync(asyncFn) {\n    if (typeof asyncFn !== 'function') throw new Error('expected a function')\n    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n}\n\n// conditionally promisify a function.\n// only return a promise if a callback is omitted\nfunction awaitify (asyncFn, arity = asyncFn.length) {\n    if (!arity) throw new Error('arity is undefined')\n    function awaitable (...args) {\n        if (typeof args[arity - 1] === 'function') {\n            return asyncFn.apply(this, args)\n        }\n\n        return new Promise((resolve, reject) => {\n            args[arity - 1] = (err, ...cbArgs) => {\n                if (err) return reject(err)\n                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);\n            };\n            asyncFn.apply(this, args);\n        })\n    }\n\n    return awaitable\n}\n\nfunction applyEach (eachfn) {\n    return function applyEach(fns, ...callArgs) {\n        const go = awaitify(function (callback) {\n            var that = this;\n            return eachfn(fns, (fn, cb) => {\n                wrapAsync(fn).apply(that, callArgs.concat(cb));\n            }, callback);\n        });\n        return go;\n    };\n}\n\nfunction _asyncMap(eachfn, arr, iteratee, callback) {\n    arr = arr || [];\n    var results = [];\n    var counter = 0;\n    var _iteratee = wrapAsync(iteratee);\n\n    return eachfn(arr, (value, _, iterCb) => {\n        var index = counter++;\n        _iteratee(value, (err, v) => {\n            results[index] = v;\n            iterCb(err);\n        });\n    }, err => {\n        callback(err, results);\n    });\n}\n\nfunction isArrayLike(value) {\n    return value &&\n        typeof value.length === 'number' &&\n        value.length >= 0 &&\n        value.length % 1 === 0;\n}\n\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nconst breakLoop = {};\n\nfunction once(fn) {\n    function wrapper (...args) {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    }\n    Object.assign(wrapper, fn);\n    return wrapper\n}\n\nfunction getIterator (coll) {\n    return coll[Symbol.iterator] && coll[Symbol.iterator]();\n}\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? {value: coll[i], key: i} : null;\n    }\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done)\n            return null;\n        i++;\n        return {value: item.value, key: i};\n    }\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = obj ? Object.keys(obj) : [];\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        if (key === '__proto__') {\n            return next();\n        }\n        return i < len ? {value: obj[key], key} : null;\n    };\n}\n\nfunction createIterator(coll) {\n    if (isArrayLike(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = getIterator(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\n\nfunction onlyOnce(fn) {\n    return function (...args) {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, args);\n    };\n}\n\n// for async generators\nfunction asyncEachOfLimit(generator, limit, iteratee, callback) {\n    let done = false;\n    let canceled = false;\n    let awaiting = false;\n    let running = 0;\n    let idx = 0;\n\n    function replenish() {\n        //console.log('replenish')\n        if (running >= limit || awaiting || done) return\n        //console.log('replenish awaiting')\n        awaiting = true;\n        generator.next().then(({value, done: iterDone}) => {\n            //console.log('got value', value)\n            if (canceled || done) return\n            awaiting = false;\n            if (iterDone) {\n                done = true;\n                if (running <= 0) {\n                    //console.log('done nextCb')\n                    callback(null);\n                }\n                return;\n            }\n            running++;\n            iteratee(value, idx, iterateeCallback);\n            idx++;\n            replenish();\n        }).catch(handleError);\n    }\n\n    function iterateeCallback(err, result) {\n        //console.log('iterateeCallback')\n        running -= 1;\n        if (canceled) return\n        if (err) return handleError(err)\n\n        if (err === false) {\n            done = true;\n            canceled = true;\n            return\n        }\n\n        if (result === breakLoop || (done && running <= 0)) {\n            done = true;\n            //console.log('done iterCb')\n            return callback(null);\n        }\n        replenish();\n    }\n\n    function handleError(err) {\n        if (canceled) return\n        awaiting = false;\n        done = true;\n        callback(err);\n    }\n\n    replenish();\n}\n\nvar eachOfLimit = (limit) => {\n    return (obj, iteratee, callback) => {\n        callback = once(callback);\n        if (limit <= 0) {\n            throw new RangeError('concurrency limit cannot be less than 1')\n        }\n        if (!obj) {\n            return callback(null);\n        }\n        if (isAsyncGenerator(obj)) {\n            return asyncEachOfLimit(obj, limit, iteratee, callback)\n        }\n        if (isAsyncIterable(obj)) {\n            return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback)\n        }\n        var nextElem = createIterator(obj);\n        var done = false;\n        var canceled = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            if (canceled) return\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            }\n            else if (err === false) {\n                done = true;\n                canceled = true;\n            }\n            else if (value === breakLoop || (done && running <= 0)) {\n                done = true;\n                return callback(null);\n            }\n            else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish () {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n};\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachOfLimit$1(coll, limit, iteratee, callback) {\n    return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);\n}\n\nvar eachOfLimit$2 = awaitify(eachOfLimit$1, 4);\n\n// eachOf implementation optimized for array-likes\nfunction eachOfArrayLike(coll, iteratee, callback) {\n    callback = once(callback);\n    var index = 0,\n        completed = 0,\n        {length} = coll,\n        canceled = false;\n    if (length === 0) {\n        callback(null);\n    }\n\n    function iteratorCallback(err, value) {\n        if (err === false) {\n            canceled = true;\n        }\n        if (canceled === true) return\n        if (err) {\n            callback(err);\n        } else if ((++completed === length) || value === breakLoop) {\n            callback(null);\n        }\n    }\n\n    for (; index < length; index++) {\n        iteratee(coll[index], index, onlyOnce(iteratorCallback));\n    }\n}\n\n// a generic version of eachOf which can handle array, object, and iterator cases.\nfunction eachOfGeneric (coll, iteratee, callback) {\n    return eachOfLimit$2(coll, Infinity, iteratee, callback);\n}\n\n/**\n * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n * to the iteratee.\n *\n * @name eachOf\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEachOf\n * @category Collection\n * @see [async.each]{@link module:Collections.each}\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each\n * item in `coll`.\n * The `key` is the item's key, or index in the case of an array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * // dev.json is a file containing a valid json object config for dev environment\n * // dev.json is a file containing a valid json object config for test environment\n * // prod.json is a file containing a valid json object config for prod environment\n * // invalid.json is a file with a malformed json object\n *\n * let configs = {}; //global variable\n * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};\n * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};\n *\n * // asynchronous function that reads a json file and parses the contents as json object\n * function parseFile(file, key, callback) {\n *     fs.readFile(file, \"utf8\", function(err, data) {\n *         if (err) return calback(err);\n *         try {\n *             configs[key] = JSON.parse(data);\n *         } catch (e) {\n *             return callback(e);\n *         }\n *         callback();\n *     });\n * }\n *\n * // Using callbacks\n * async.forEachOf(validConfigFileMap, parseFile, function (err) {\n *     if (err) {\n *         console.error(err);\n *     } else {\n *         console.log(configs);\n *         // configs is now a map of JSON data, e.g.\n *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n *     }\n * });\n *\n * //Error handing\n * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {\n *     if (err) {\n *         console.error(err);\n *         // JSON parse error exception\n *     } else {\n *         console.log(configs);\n *     }\n * });\n *\n * // Using Promises\n * async.forEachOf(validConfigFileMap, parseFile)\n * .then( () => {\n *     console.log(configs);\n *     // configs is now a map of JSON data, e.g.\n *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n * }).catch( err => {\n *     console.error(err);\n * });\n *\n * //Error handing\n * async.forEachOf(invalidConfigFileMap, parseFile)\n * .then( () => {\n *     console.log(configs);\n * }).catch( err => {\n *     console.error(err);\n *     // JSON parse error exception\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.forEachOf(validConfigFileMap, parseFile);\n *         console.log(configs);\n *         // configs is now a map of JSON data, e.g.\n *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * //Error handing\n * async () => {\n *     try {\n *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);\n *         console.log(configs);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // JSON parse error exception\n *     }\n * }\n *\n */\nfunction eachOf(coll, iteratee, callback) {\n    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n    return eachOfImplementation(coll, wrapAsync(iteratee), callback);\n}\n\nvar eachOf$1 = awaitify(eachOf, 3);\n\n/**\n * Produces a new collection of values by mapping each value in `coll` through\n * the `iteratee` function. The `iteratee` is called with an item from `coll`\n * and a callback for when it has finished processing. Each of these callbacks\n * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n * `iteratee` passes an error to its callback, the main `callback` (for the\n * `map` function) is immediately called with the error.\n *\n * Note, that since this function applies the `iteratee` to each item in\n * parallel, there is no guarantee that the `iteratee` functions will complete\n * in order. However, the results array will be in the same order as the\n * original `coll`.\n *\n * If `map` is passed an Object, the results will be an Array.  The results\n * will roughly be in the order of the original Objects' keys (but this can\n * vary across JavaScript engines).\n *\n * @name map\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an Array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n * // file4.txt does not exist\n *\n * const fileList = ['file1.txt','file2.txt','file3.txt'];\n * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];\n *\n * // asynchronous function that returns the file size in bytes\n * function getFileSizeInBytes(file, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         callback(null, stat.size);\n *     });\n * }\n *\n * // Using callbacks\n * async.map(fileList, getFileSizeInBytes, function(err, results) {\n *     if (err) {\n *         console.log(err);\n *     } else {\n *         console.log(results);\n *         // results is now an array of the file size in bytes for each file, e.g.\n *         // [ 1000, 2000, 3000]\n *     }\n * });\n *\n * // Error Handling\n * async.map(withMissingFileList, getFileSizeInBytes, function(err, results) {\n *     if (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     } else {\n *         console.log(results);\n *     }\n * });\n *\n * // Using Promises\n * async.map(fileList, getFileSizeInBytes)\n * .then( results => {\n *     console.log(results);\n *     // results is now an array of the file size in bytes for each file, e.g.\n *     // [ 1000, 2000, 3000]\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Error Handling\n * async.map(withMissingFileList, getFileSizeInBytes)\n * .then( results => {\n *     console.log(results);\n * }).catch( err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let results = await async.map(fileList, getFileSizeInBytes);\n *         console.log(results);\n *         // results is now an array of the file size in bytes for each file, e.g.\n *         // [ 1000, 2000, 3000]\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         let results = await async.map(withMissingFileList, getFileSizeInBytes);\n *         console.log(results);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     }\n * }\n *\n */\nfunction map (coll, iteratee, callback) {\n    return _asyncMap(eachOf$1, coll, iteratee, callback)\n}\nvar map$1 = awaitify(map, 3);\n\n/**\n * Applies the provided arguments to each function in the array, calling\n * `callback` after all functions have completed. If you only provide the first\n * argument, `fns`, then it will return a function which lets you pass in the\n * arguments as if it were a single function call. If more arguments are\n * provided, `callback` is required while `args` is still optional. The results\n * for each of the applied async functions are passed to the final callback\n * as an array.\n *\n * @name applyEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s\n * to all call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {AsyncFunction} - Returns a function that takes no args other than\n * an optional callback, that is the result of applying the `args` to each\n * of the functions.\n * @example\n *\n * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')\n *\n * appliedFn((err, results) => {\n *     // results[0] is the results for `enableSearch`\n *     // results[1] is the results for `updateSchema`\n * });\n *\n * // partial application example:\n * async.each(\n *     buckets,\n *     async (bucket) => async.applyEach([enableSearch, updateSchema], bucket)(),\n *     callback\n * );\n */\nvar applyEach$1 = applyEach(map$1);\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachOfSeries(coll, iteratee, callback) {\n    return eachOfLimit$2(coll, 1, iteratee, callback)\n}\nvar eachOfSeries$1 = awaitify(eachOfSeries, 3);\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n *\n * @name mapSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction mapSeries (coll, iteratee, callback) {\n    return _asyncMap(eachOfSeries$1, coll, iteratee, callback)\n}\nvar mapSeries$1 = awaitify(mapSeries, 3);\n\n/**\n * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n *\n * @name applyEachSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {AsyncFunction} - A function, that when called, is the result of\n * appling the `args` to the list of functions.  It takes no args, other than\n * a callback.\n */\nvar applyEachSeries = applyEach(mapSeries$1);\n\nconst PROMISE_SYMBOL = Symbol('promiseCallback');\n\nfunction promiseCallback () {\n    let resolve, reject;\n    function callback (err, ...args) {\n        if (err) return reject(err)\n        resolve(args.length > 1 ? args : args[0]);\n    }\n\n    callback[PROMISE_SYMBOL] = new Promise((res, rej) => {\n        resolve = res,\n        reject = rej;\n    });\n\n    return callback\n}\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n * @example\n *\n * //Using Callbacks\n * async.auto({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     if (err) {\n *         console.log('err = ', err);\n *     }\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * });\n *\n * //Using Promises\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }).then(results => {\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * }).catch(err => {\n *     console.log('err = ', err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.auto({\n *             get_data: function(callback) {\n *                 // async code to get some data\n *                 callback(null, 'data', 'converted to array');\n *             },\n *             make_folder: function(callback) {\n *                 // async code to create a directory to store a file in\n *                 // this is run at the same time as getting the data\n *                 callback(null, 'folder');\n *             },\n *             write_file: ['get_data', 'make_folder', function(results, callback) {\n *                 // once there is some data and the directory exists,\n *                 // write the data to a file in the directory\n *                 callback(null, 'filename');\n *             }],\n *             email_link: ['write_file', function(results, callback) {\n *                 // once the file is written let's email a link to it...\n *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *             }]\n *         });\n *         console.log('results = ', results);\n *         // results = {\n *         //     get_data: ['data', 'converted to array']\n *         //     make_folder; 'folder',\n *         //     write_file: 'filename'\n *         //     email_link: { file: 'filename', email: 'user@example.com' }\n *         // }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction auto(tasks, concurrency, callback) {\n    if (typeof concurrency !== 'number') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = once(callback || promiseCallback());\n    var numTasks = Object.keys(tasks).length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var canceled = false;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    Object.keys(tasks).forEach(key => {\n        var task = tasks[key];\n        if (!Array.isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        dependencies.forEach(dependencyName => {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key +\n                    '` has a non-existent dependency `' +\n                    dependencyName + '` in ' +\n                    dependencies.join(', '));\n            }\n            addListener(dependencyName, () => {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(() => runTask(key, task));\n    }\n\n    function processQueue() {\n        if (canceled) return\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while(readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        taskListeners.forEach(fn => fn());\n        processQueue();\n    }\n\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = onlyOnce((err, ...result) => {\n            runningTasks--;\n            if (err === false) {\n                canceled = true;\n                return\n            }\n            if (result.length < 2) {\n                [result] = result;\n            }\n            if (err) {\n                var safeResults = {};\n                Object.keys(results).forEach(rkey => {\n                    safeResults[rkey] = results[rkey];\n                });\n                safeResults[key] = result;\n                hasError = true;\n                listeners = Object.create(null);\n                if (canceled) return\n                callback(err, safeResults);\n            } else {\n                results[key] = result;\n                taskComplete(key);\n            }\n        });\n\n        runningTasks++;\n        var taskFn = wrapAsync(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            getDependents(currentTask).forEach(dependent => {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error(\n                'async.auto cannot execute tasks due to a recursive dependency'\n            );\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        Object.keys(tasks).forEach(key => {\n            const task = tasks[key];\n            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n\n    return callback[PROMISE_SYMBOL]\n}\n\nvar FN_ARGS = /^(?:async\\s+)?(?:function)?\\s*\\w*\\s*\\(\\s*([^)]+)\\s*\\)(?:\\s*{)/;\nvar ARROW_FN_ARGS = /^(?:async\\s+)?\\(?\\s*([^)=]+)\\s*\\)?(?:\\s*=>)/;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\n\nfunction stripComments(string) {\n    let stripped = '';\n    let index = 0;\n    let endBlockComment = string.indexOf('*/');\n    while (index < string.length) {\n        if (string[index] === '/' && string[index+1] === '/') {\n            // inline comment\n            let endIndex = string.indexOf('\\n', index);\n            index = (endIndex === -1) ? string.length : endIndex;\n        } else if ((endBlockComment !== -1) && (string[index] === '/') && (string[index+1] === '*')) {\n            // block comment\n            let endIndex = string.indexOf('*/', index);\n            if (endIndex !== -1) {\n                index = endIndex + 2;\n                endBlockComment = string.indexOf('*/', index);\n            } else {\n                stripped += string[index];\n                index++;\n            }\n        } else {\n            stripped += string[index];\n            index++;\n        }\n    }\n    return stripped;\n}\n\nfunction parseParams(func) {\n    const src = stripComments(func.toString());\n    let match = src.match(FN_ARGS);\n    if (!match) {\n        match = src.match(ARROW_FN_ARGS);\n    }\n    if (!match) throw new Error('could not parse args in autoInject\\nSource:\\n' + src)\n    let [, args] = match;\n    return args\n        .replace(/\\s/g, '')\n        .split(FN_ARG_SPLIT)\n        .map((arg) => arg.replace(FN_ARG, '').trim());\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    Object.keys(tasks).forEach(key => {\n        var taskFn = tasks[key];\n        var params;\n        var fnIsAsync = isAsync(taskFn);\n        var hasNoDeps =\n            (!fnIsAsync && taskFn.length === 1) ||\n            (fnIsAsync && taskFn.length === 0);\n\n        if (Array.isArray(taskFn)) {\n            params = [...taskFn];\n            taskFn = params.pop();\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if ((taskFn.length === 0 && !fnIsAsync) && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = params.map(name => results[name]);\n            newArgs.push(taskCb);\n            wrapAsync(taskFn)(...newArgs);\n        }\n    });\n\n    return auto(newTasks, callback);\n}\n\n// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n// used for queues. This implementation assumes that the node provided by the user can be modified\n// to adjust the next and last properties. We implement only the minimal functionality\n// for queue support.\nclass DLL {\n    constructor() {\n        this.head = this.tail = null;\n        this.length = 0;\n    }\n\n    removeLink(node) {\n        if (node.prev) node.prev.next = node.next;\n        else this.head = node.next;\n        if (node.next) node.next.prev = node.prev;\n        else this.tail = node.prev;\n\n        node.prev = node.next = null;\n        this.length -= 1;\n        return node;\n    }\n\n    empty () {\n        while(this.head) this.shift();\n        return this;\n    }\n\n    insertAfter(node, newNode) {\n        newNode.prev = node;\n        newNode.next = node.next;\n        if (node.next) node.next.prev = newNode;\n        else this.tail = newNode;\n        node.next = newNode;\n        this.length += 1;\n    }\n\n    insertBefore(node, newNode) {\n        newNode.prev = node.prev;\n        newNode.next = node;\n        if (node.prev) node.prev.next = newNode;\n        else this.head = newNode;\n        node.prev = newNode;\n        this.length += 1;\n    }\n\n    unshift(node) {\n        if (this.head) this.insertBefore(this.head, node);\n        else setInitial(this, node);\n    }\n\n    push(node) {\n        if (this.tail) this.insertAfter(this.tail, node);\n        else setInitial(this, node);\n    }\n\n    shift() {\n        return this.head && this.removeLink(this.head);\n    }\n\n    pop() {\n        return this.tail && this.removeLink(this.tail);\n    }\n\n    toArray() {\n        return [...this]\n    }\n\n    *[Symbol.iterator] () {\n        var cur = this.head;\n        while (cur) {\n            yield cur.data;\n            cur = cur.next;\n        }\n    }\n\n    remove (testFn) {\n        var curr = this.head;\n        while(curr) {\n            var {next} = curr;\n            if (testFn(curr)) {\n                this.removeLink(curr);\n            }\n            curr = next;\n        }\n        return this;\n    }\n}\n\nfunction setInitial(dll, node) {\n    dll.length = 1;\n    dll.head = dll.tail = node;\n}\n\nfunction queue(worker, concurrency, payload) {\n    if (concurrency == null) {\n        concurrency = 1;\n    }\n    else if(concurrency === 0) {\n        throw new RangeError('Concurrency must not be zero');\n    }\n\n    var _worker = wrapAsync(worker);\n    var numRunning = 0;\n    var workersList = [];\n    const events = {\n        error: [],\n        drain: [],\n        saturated: [],\n        unsaturated: [],\n        empty: []\n    };\n\n    function on (event, handler) {\n        events[event].push(handler);\n    }\n\n    function once (event, handler) {\n        const handleAndRemove = (...args) => {\n            off(event, handleAndRemove);\n            handler(...args);\n        };\n        events[event].push(handleAndRemove);\n    }\n\n    function off (event, handler) {\n        if (!event) return Object.keys(events).forEach(ev => events[ev] = [])\n        if (!handler) return events[event] = []\n        events[event] = events[event].filter(ev => ev !== handler);\n    }\n\n    function trigger (event, ...args) {\n        events[event].forEach(handler => handler(...args));\n    }\n\n    var processingScheduled = false;\n    function _insert(data, insertAtFront, rejectOnError, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n\n        var res, rej;\n        function promiseCallback (err, ...args) {\n            // we don't care about the error, let the global error handler\n            // deal with it\n            if (err) return rejectOnError ? rej(err) : res()\n            if (args.length <= 1) return res(args[0])\n            res(args);\n        }\n\n        var item = q._createTaskItem(\n            data,\n            rejectOnError ? promiseCallback :\n                (callback || promiseCallback)\n        );\n\n        if (insertAtFront) {\n            q._tasks.unshift(item);\n        } else {\n            q._tasks.push(item);\n        }\n\n        if (!processingScheduled) {\n            processingScheduled = true;\n            setImmediate$1(() => {\n                processingScheduled = false;\n                q.process();\n            });\n        }\n\n        if (rejectOnError || !callback) {\n            return new Promise((resolve, reject) => {\n                res = resolve;\n                rej = reject;\n            })\n        }\n    }\n\n    function _createCB(tasks) {\n        return function (err, ...args) {\n            numRunning -= 1;\n\n            for (var i = 0, l = tasks.length; i < l; i++) {\n                var task = tasks[i];\n\n                var index = workersList.indexOf(task);\n                if (index === 0) {\n                    workersList.shift();\n                } else if (index > 0) {\n                    workersList.splice(index, 1);\n                }\n\n                task.callback(err, ...args);\n\n                if (err != null) {\n                    trigger('error', err, task.data);\n                }\n            }\n\n            if (numRunning <= (q.concurrency - q.buffer) ) {\n                trigger('unsaturated');\n            }\n\n            if (q.idle()) {\n                trigger('drain');\n            }\n            q.process();\n        };\n    }\n\n    function _maybeDrain(data) {\n        if (data.length === 0 && q.idle()) {\n            // call drain immediately if there are no tasks\n            setImmediate$1(() => trigger('drain'));\n            return true\n        }\n        return false\n    }\n\n    const eventMethod = (name) => (handler) => {\n        if (!handler) {\n            return new Promise((resolve, reject) => {\n                once(name, (err, data) => {\n                    if (err) return reject(err)\n                    resolve(data);\n                });\n            })\n        }\n        off(name);\n        on(name, handler);\n\n    };\n\n    var isProcessing = false;\n    var q = {\n        _tasks: new DLL(),\n        _createTaskItem (data, callback) {\n            return {\n                data,\n                callback\n            };\n        },\n        *[Symbol.iterator] () {\n            yield* q._tasks[Symbol.iterator]();\n        },\n        concurrency,\n        payload,\n        buffer: concurrency / 4,\n        started: false,\n        paused: false,\n        push (data, callback) {\n            if (Array.isArray(data)) {\n                if (_maybeDrain(data)) return\n                return data.map(datum => _insert(datum, false, false, callback))\n            }\n            return _insert(data, false, false, callback);\n        },\n        pushAsync (data, callback) {\n            if (Array.isArray(data)) {\n                if (_maybeDrain(data)) return\n                return data.map(datum => _insert(datum, false, true, callback))\n            }\n            return _insert(data, false, true, callback);\n        },\n        kill () {\n            off();\n            q._tasks.empty();\n        },\n        unshift (data, callback) {\n            if (Array.isArray(data)) {\n                if (_maybeDrain(data)) return\n                return data.map(datum => _insert(datum, true, false, callback))\n            }\n            return _insert(data, true, false, callback);\n        },\n        unshiftAsync (data, callback) {\n            if (Array.isArray(data)) {\n                if (_maybeDrain(data)) return\n                return data.map(datum => _insert(datum, true, true, callback))\n            }\n            return _insert(data, true, true, callback);\n        },\n        remove (testFn) {\n            q._tasks.remove(testFn);\n        },\n        process () {\n            // Avoid trying to start too many processing operations. This can occur\n            // when callbacks resolve synchronously (#1267).\n            if (isProcessing) {\n                return;\n            }\n            isProcessing = true;\n            while(!q.paused && numRunning < q.concurrency && q._tasks.length){\n                var tasks = [], data = [];\n                var l = q._tasks.length;\n                if (q.payload) l = Math.min(l, q.payload);\n                for (var i = 0; i < l; i++) {\n                    var node = q._tasks.shift();\n                    tasks.push(node);\n                    workersList.push(node);\n                    data.push(node.data);\n                }\n\n                numRunning += 1;\n\n                if (q._tasks.length === 0) {\n                    trigger('empty');\n                }\n\n                if (numRunning === q.concurrency) {\n                    trigger('saturated');\n                }\n\n                var cb = onlyOnce(_createCB(tasks));\n                _worker(data, cb);\n            }\n            isProcessing = false;\n        },\n        length () {\n            return q._tasks.length;\n        },\n        running () {\n            return numRunning;\n        },\n        workersList () {\n            return workersList;\n        },\n        idle() {\n            return q._tasks.length + numRunning === 0;\n        },\n        pause () {\n            q.paused = true;\n        },\n        resume () {\n            if (q.paused === false) { return; }\n            q.paused = false;\n            setImmediate$1(q.process);\n        }\n    };\n    // define these as fixed properties, so people get useful errors when updating\n    Object.defineProperties(q, {\n        saturated: {\n            writable: false,\n            value: eventMethod('saturated')\n        },\n        unsaturated: {\n            writable: false,\n            value: eventMethod('unsaturated')\n        },\n        empty: {\n            writable: false,\n            value: eventMethod('empty')\n        },\n        drain: {\n            writable: false,\n            value: eventMethod('drain')\n        },\n        error: {\n            writable: false,\n            value: eventMethod('error')\n        },\n    });\n    return q;\n}\n\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * await cargo.push({name: 'baz'});\n * console.log('finished processing baz');\n */\nfunction cargo(worker, payload) {\n    return queue(worker, 1, payload);\n}\n\n/**\n * Creates a `cargoQueue` object with the specified payload. Tasks added to the\n * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.\n * If the all `workers` are in progress, the task is queued until one becomes available. Once\n * a `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,\n * the cargoQueue passes an array of tasks to multiple parallel workers.\n *\n * @name cargoQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @see [async.cargo]{@link module:ControlFLow.cargo}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargoQueue and inner queue.\n * @example\n *\n * // create a cargoQueue object with payload 2 and concurrency 2\n * var cargoQueue = async.cargoQueue(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2, 2);\n *\n * // add some items\n * cargoQueue.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargoQueue.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargoQueue.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n * cargoQueue.push({name: 'boo'}, function(err) {\n *     console.log('finished processing boo');\n * });\n */\nfunction cargo$1(worker, concurrency, payload) {\n    return queue(worker, concurrency, payload);\n}\n\n/**\n * Reduces `coll` into a single value using an async `iteratee` to return each\n * successive step. `memo` is the initial state of the reduction. This function\n * only operates in series.\n *\n * For performance reasons, it may make sense to split a call to this function\n * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n * results. This function is for situations where each step in the reduction\n * needs to be async; if you can get the data before reducing it, then it's\n * probably a good idea to do so.\n *\n * @name reduce\n * @static\n * @memberOf module:Collections\n * @method\n * @alias inject\n * @alias foldl\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee completes with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n * // file4.txt does not exist\n *\n * const fileList = ['file1.txt','file2.txt','file3.txt'];\n * const withMissingFileList = ['file1.txt','file2.txt','file3.txt', 'file4.txt'];\n *\n * // asynchronous function that computes the file size in bytes\n * // file size is added to the memoized value, then returned\n * function getFileSizeInBytes(memo, file, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         callback(null, memo + stat.size);\n *     });\n * }\n *\n * // Using callbacks\n * async.reduce(fileList, 0, getFileSizeInBytes, function(err, result) {\n *     if (err) {\n *         console.log(err);\n *     } else {\n *         console.log(result);\n *         // 6000\n *         // which is the sum of the file sizes of the three files\n *     }\n * });\n *\n * // Error Handling\n * async.reduce(withMissingFileList, 0, getFileSizeInBytes, function(err, result) {\n *     if (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     } else {\n *         console.log(result);\n *     }\n * });\n *\n * // Using Promises\n * async.reduce(fileList, 0, getFileSizeInBytes)\n * .then( result => {\n *     console.log(result);\n *     // 6000\n *     // which is the sum of the file sizes of the three files\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Error Handling\n * async.reduce(withMissingFileList, 0, getFileSizeInBytes)\n * .then( result => {\n *     console.log(result);\n * }).catch( err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.reduce(fileList, 0, getFileSizeInBytes);\n *         console.log(result);\n *         // 6000\n *         // which is the sum of the file sizes of the three files\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         let result = await async.reduce(withMissingFileList, 0, getFileSizeInBytes);\n *         console.log(result);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     }\n * }\n *\n */\nfunction reduce(coll, memo, iteratee, callback) {\n    callback = once(callback);\n    var _iteratee = wrapAsync(iteratee);\n    return eachOfSeries$1(coll, (x, i, iterCb) => {\n        _iteratee(memo, x, (err, v) => {\n            memo = v;\n            iterCb(err);\n        });\n    }, err => callback(err, memo));\n}\nvar reduce$1 = awaitify(reduce, 4);\n\n/**\n * Version of the compose function that is more natural to read. Each function\n * consumes the return value of the previous function. It is the equivalent of\n * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name seq\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.compose]{@link module:ControlFlow.compose}\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} a function that composes the `functions` in order\n * @example\n *\n * // Requires lodash (or underscore), express3 and dresende's orm2.\n * // Part of an app, that fetches cats of the logged user.\n * // This example uses `seq` function to avoid overnesting and error\n * // handling clutter.\n * app.get('/cats', function(request, response) {\n *     var User = request.models.User;\n *     async.seq(\n *         User.get.bind(User),  // 'User.get' has signature (id, callback(err, data))\n *         function(user, fn) {\n *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n *         }\n *     )(req.session.user_id, function (err, cats) {\n *         if (err) {\n *             console.error(err);\n *             response.json({ status: 'error', message: err.message });\n *         } else {\n *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n *         }\n *     });\n * });\n */\nfunction seq(...functions) {\n    var _functions = functions.map(wrapAsync);\n    return function (...args) {\n        var that = this;\n\n        var cb = args[args.length - 1];\n        if (typeof cb == 'function') {\n            args.pop();\n        } else {\n            cb = promiseCallback();\n        }\n\n        reduce$1(_functions, args, (newargs, fn, iterCb) => {\n            fn.apply(that, newargs.concat((err, ...nextargs) => {\n                iterCb(err, nextargs);\n            }));\n        },\n        (err, results) => cb(err, ...results));\n\n        return cb[PROMISE_SYMBOL]\n    };\n}\n\n/**\n * Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * If the last argument to the composed function is not a function, a promise\n * is returned when you call it.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });\n */\nfunction compose(...args) {\n    return seq(...args.reverse());\n}\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n *\n * @name mapLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction mapLimit (coll, limit, iteratee, callback) {\n    return _asyncMap(eachOfLimit(limit), coll, iteratee, callback)\n}\nvar mapLimit$1 = awaitify(mapLimit, 4);\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.\n *\n * @name concatLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @alias flatMapLimit\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @returns A Promise, if no callback is passed\n */\nfunction concatLimit(coll, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return mapLimit$1(coll, limit, (val, iterCb) => {\n        _iteratee(val, (err, ...args) => {\n            if (err) return iterCb(err);\n            return iterCb(err, args);\n        });\n    }, (err, mapResults) => {\n        var result = [];\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                result = result.concat(...mapResults[i]);\n            }\n        }\n\n        return callback(err, result);\n    });\n}\nvar concatLimit$1 = awaitify(concatLimit, 4);\n\n/**\n * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. The results array will be returned in\n * the original order of `coll` passed to the `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @alias flatMap\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @returns A Promise, if no callback is passed\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * let directoryList = ['dir1','dir2','dir3'];\n * let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4'];\n *\n * // Using callbacks\n * async.concat(directoryList, fs.readdir, function(err, results) {\n *    if (err) {\n *        console.log(err);\n *    } else {\n *        console.log(results);\n *        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n *    }\n * });\n *\n * // Error Handling\n * async.concat(withMissingDirectoryList, fs.readdir, function(err, results) {\n *    if (err) {\n *        console.log(err);\n *        // [ Error: ENOENT: no such file or directory ]\n *        // since dir4 does not exist\n *    } else {\n *        console.log(results);\n *    }\n * });\n *\n * // Using Promises\n * async.concat(directoryList, fs.readdir)\n * .then(results => {\n *     console.log(results);\n *     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n * }).catch(err => {\n *      console.log(err);\n * });\n *\n * // Error Handling\n * async.concat(withMissingDirectoryList, fs.readdir)\n * .then(results => {\n *     console.log(results);\n * }).catch(err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n *     // since dir4 does not exist\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let results = await async.concat(directoryList, fs.readdir);\n *         console.log(results);\n *         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n *     } catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         let results = await async.concat(withMissingDirectoryList, fs.readdir);\n *         console.log(results);\n *     } catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *         // since dir4 does not exist\n *     }\n * }\n *\n */\nfunction concat(coll, iteratee, callback) {\n    return concatLimit$1(coll, Infinity, iteratee, callback)\n}\nvar concat$1 = awaitify(concat, 3);\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @alias flatMapSeries\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n * The iteratee should complete with an array an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @returns A Promise, if no callback is passed\n */\nfunction concatSeries(coll, iteratee, callback) {\n    return concatLimit$1(coll, 1, iteratee, callback)\n}\nvar concatSeries$1 = awaitify(concatSeries, 3);\n\n/**\n * Returns a function that when called, calls-back with the values provided.\n * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n * [`auto`]{@link module:ControlFlow.auto}.\n *\n * @name constant\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {...*} arguments... - Any number of arguments to automatically invoke\n * callback with.\n * @returns {AsyncFunction} Returns a function that when invoked, automatically\n * invokes the callback with the previous given arguments.\n * @example\n *\n * async.waterfall([\n *     async.constant(42),\n *     function (value, next) {\n *         // value === 42\n *     },\n *     //...\n * ], callback);\n *\n * async.waterfall([\n *     async.constant(filename, \"utf8\"),\n *     fs.readFile,\n *     function (fileData, next) {\n *         //...\n *     }\n *     //...\n * ], callback);\n *\n * async.auto({\n *     hostname: async.constant(\"https://server.net/\"),\n *     port: findFreePort,\n *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n *         startServer(options, cb);\n *     }],\n *     //...\n * }, callback);\n */\nfunction constant(...args) {\n    return function (...ignoredArgs/*, callback*/) {\n        var callback = ignoredArgs.pop();\n        return callback(null, ...args);\n    };\n}\n\nfunction _createTester(check, getResult) {\n    return (eachfn, arr, _iteratee, cb) => {\n        var testPassed = false;\n        var testResult;\n        const iteratee = wrapAsync(_iteratee);\n        eachfn(arr, (value, _, callback) => {\n            iteratee(value, (err, result) => {\n                if (err || err === false) return callback(err);\n\n                if (check(result) && !testResult) {\n                    testPassed = true;\n                    testResult = getResult(true, value);\n                    return callback(null, breakLoop);\n                }\n                callback();\n            });\n        }, err => {\n            if (err) return cb(err);\n            cb(null, testPassed ? testResult : getResult(false));\n        });\n    };\n}\n\n/**\n * Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * [`detectSeries`]{@link module:Collections.detectSeries}.\n *\n * @name detect\n * @static\n * @memberOf module:Collections\n * @method\n * @alias find\n * @category Collections\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists,\n *    function(err, result) {\n *        console.log(result);\n *        // dir1/file1.txt\n *        // result now equals the first file in the list that exists\n *    }\n *);\n *\n * // Using Promises\n * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists)\n * .then(result => {\n *     console.log(result);\n *     // dir1/file1.txt\n *     // result now equals the first file in the list that exists\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists);\n *         console.log(result);\n *         // dir1/file1.txt\n *         // result now equals the file in the list that exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction detect(coll, iteratee, callback) {\n    return _createTester(bool => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback)\n}\nvar detect$1 = awaitify(detect, 3);\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name detectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findLimit\n * @category Collections\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction detectLimit(coll, limit, iteratee, callback) {\n    return _createTester(bool => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback)\n}\nvar detectLimit$1 = awaitify(detectLimit, 4);\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n *\n * @name detectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findSeries\n * @category Collections\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction detectSeries(coll, iteratee, callback) {\n    return _createTester(bool => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback)\n}\n\nvar detectSeries$1 = awaitify(detectSeries, 3);\n\nfunction consoleFunc(name) {\n    return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {\n        /* istanbul ignore else */\n        if (typeof console === 'object') {\n            /* istanbul ignore else */\n            if (err) {\n                /* istanbul ignore else */\n                if (console.error) {\n                    console.error(err);\n                }\n            } else if (console[name]) { /* istanbul ignore else */\n                resultArgs.forEach(x => console[name](x));\n            }\n        }\n    })\n}\n\n/**\n * Logs the result of an [`async` function]{@link AsyncFunction} to the\n * `console` using `console.dir` to display the properties of the resulting object.\n * Only works in Node.js or in browsers that support `console.dir` and\n * `console.error` (such as FF and Chrome).\n * If multiple arguments are returned from the async function,\n * `console.dir` is called on each argument in order.\n *\n * @name dir\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, {hello: name});\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.dir(hello, 'world');\n * {hello: 'world'}\n */\nvar dir = consoleFunc('dir');\n\n/**\n * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n * the order of operations, the arguments `test` and `iteratee` are switched.\n *\n * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n *\n * @name doWhilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - A function which is called each time `test`\n * passes. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform after each\n * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped.\n * `callback` will be passed an error and any arguments passed to the final\n * `iteratee`'s callback. Invoked with (err, [results]);\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction doWhilst(iteratee, test, callback) {\n    callback = onlyOnce(callback);\n    var _fn = wrapAsync(iteratee);\n    var _test = wrapAsync(test);\n    var results;\n\n    function next(err, ...args) {\n        if (err) return callback(err);\n        if (err === false) return;\n        results = args;\n        _test(...args, check);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (err === false) return;\n        if (!truth) return callback(null, ...results);\n        _fn(next);\n    }\n\n    return check(null, true);\n}\n\nvar doWhilst$1 = awaitify(doWhilst, 3);\n\n/**\n * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n * argument ordering differs from `until`.\n *\n * @name doUntil\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform after each\n * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `iteratee`\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction doUntil(iteratee, test, callback) {\n    const _test = wrapAsync(test);\n    return doWhilst$1(iteratee, (...args) => {\n        const cb = args.pop();\n        _test(...args, (err, truth) => cb (err, !truth));\n    }, callback);\n}\n\nfunction _withoutIndex(iteratee) {\n    return (value, index, callback) => iteratee(value, callback);\n}\n\n/**\n * Applies the function `iteratee` to each item in `coll`, in parallel.\n * The `iteratee` is called with an item from the list, and a callback for when\n * it has finished. If the `iteratee` passes an error to its `callback`, the\n * main `callback` (for the `each` function) is immediately called with the\n * error.\n *\n * Note, that since this function applies `iteratee` to each item in parallel,\n * there is no guarantee that the iteratee functions will complete in order.\n *\n * @name each\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEach\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to\n * each item in `coll`. Invoked with (item, callback).\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOf`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];\n * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];\n *\n * // asynchronous function that deletes a file\n * const deleteFile = function(file, callback) {\n *     fs.unlink(file, callback);\n * };\n *\n * // Using callbacks\n * async.each(fileList, deleteFile, function(err) {\n *     if( err ) {\n *         console.log(err);\n *     } else {\n *         console.log('All files have been deleted successfully');\n *     }\n * });\n *\n * // Error Handling\n * async.each(withMissingFileList, deleteFile, function(err){\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n *     // since dir4/file2.txt does not exist\n *     // dir1/file1.txt could have been deleted\n * });\n *\n * // Using Promises\n * async.each(fileList, deleteFile)\n * .then( () => {\n *     console.log('All files have been deleted successfully');\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Error Handling\n * async.each(fileList, deleteFile)\n * .then( () => {\n *     console.log('All files have been deleted successfully');\n * }).catch( err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n *     // since dir4/file2.txt does not exist\n *     // dir1/file1.txt could have been deleted\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         await async.each(files, deleteFile);\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         await async.each(withMissingFileList, deleteFile);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *         // since dir4/file2.txt does not exist\n *         // dir1/file1.txt could have been deleted\n *     }\n * }\n *\n */\nfunction eachLimit(coll, iteratee, callback) {\n    return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\n\nvar each = awaitify(eachLimit, 3);\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachLimit$1(coll, limit, iteratee, callback) {\n    return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\nvar eachLimit$2 = awaitify(eachLimit$1, 4);\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item\n * in series and therefore the iteratee functions will complete in order.\n\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @returns {Promise} a promise, if a callback is omitted\n */\nfunction eachSeries(coll, iteratee, callback) {\n    return eachLimit$2(coll, 1, iteratee, callback)\n}\nvar eachSeries$1 = awaitify(eachSeries, 3);\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained. ES2017 `async` functions are returned as-is -- they are immune\n * to Zalgo's corrupting influences, as they always resolve on a later tick.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nfunction ensureAsync(fn) {\n    if (isAsync(fn)) return fn;\n    return function (...args/*, callback*/) {\n        var callback = args.pop();\n        var sync = true;\n        args.push((...innerArgs) => {\n            if (sync) {\n                setImmediate$1(() => callback(...innerArgs));\n            } else {\n                callback(...innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    };\n}\n\n/**\n * Returns `true` if every element in `coll` satisfies an async test. If any\n * iteratee call returns `false`, the main `callback` is immediately called.\n *\n * @name every\n * @static\n * @memberOf module:Collections\n * @method\n * @alias all\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file5.txt'];\n * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * // Using callbacks\n * async.every(fileList, fileExists, function(err, result) {\n *     console.log(result);\n *     // true\n *     // result is true since every file exists\n * });\n *\n * async.every(withMissingFileList, fileExists, function(err, result) {\n *     console.log(result);\n *     // false\n *     // result is false since NOT every file exists\n * });\n *\n * // Using Promises\n * async.every(fileList, fileExists)\n * .then( result => {\n *     console.log(result);\n *     // true\n *     // result is true since every file exists\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * async.every(withMissingFileList, fileExists)\n * .then( result => {\n *     console.log(result);\n *     // false\n *     // result is false since NOT every file exists\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.every(fileList, fileExists);\n *         console.log(result);\n *         // true\n *         // result is true since every file exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * async () => {\n *     try {\n *         let result = await async.every(withMissingFileList, fileExists);\n *         console.log(result);\n *         // false\n *         // result is false since NOT every file exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction every(coll, iteratee, callback) {\n    return _createTester(bool => !bool, res => !res)(eachOf$1, coll, iteratee, callback)\n}\nvar every$1 = awaitify(every, 3);\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n *\n * @name everyLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n */\nfunction everyLimit(coll, limit, iteratee, callback) {\n    return _createTester(bool => !bool, res => !res)(eachOfLimit(limit), coll, iteratee, callback)\n}\nvar everyLimit$1 = awaitify(everyLimit, 4);\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n *\n * @name everySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in series.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n */\nfunction everySeries(coll, iteratee, callback) {\n    return _createTester(bool => !bool, res => !res)(eachOfSeries$1, coll, iteratee, callback)\n}\nvar everySeries$1 = awaitify(everySeries, 3);\n\nfunction filterArray(eachfn, arr, iteratee, callback) {\n    var truthValues = new Array(arr.length);\n    eachfn(arr, (x, index, iterCb) => {\n        iteratee(x, (err, v) => {\n            truthValues[index] = !!v;\n            iterCb(err);\n        });\n    }, err => {\n        if (err) return callback(err);\n        var results = [];\n        for (var i = 0; i < arr.length; i++) {\n            if (truthValues[i]) results.push(arr[i]);\n        }\n        callback(null, results);\n    });\n}\n\nfunction filterGeneric(eachfn, coll, iteratee, callback) {\n    var results = [];\n    eachfn(coll, (x, index, iterCb) => {\n        iteratee(x, (err, v) => {\n            if (err) return iterCb(err);\n            if (v) {\n                results.push({index, value: x});\n            }\n            iterCb(err);\n        });\n    }, err => {\n        if (err) return callback(err);\n        callback(null, results\n            .sort((a, b) => a.index - b.index)\n            .map(v => v.value));\n    });\n}\n\nfunction _filter(eachfn, coll, iteratee, callback) {\n    var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n    return filter(eachfn, coll, wrapAsync(iteratee), callback);\n}\n\n/**\n * Returns a new array of all the values in `coll` which pass an async truth\n * test. This operation is performed in parallel, but the results array will be\n * in the same order as the original.\n *\n * @name filter\n * @static\n * @memberOf module:Collections\n * @method\n * @alias select\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback provided\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n *\n * const files = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * // Using callbacks\n * async.filter(files, fileExists, function(err, results) {\n *    if(err) {\n *        console.log(err);\n *    } else {\n *        console.log(results);\n *        // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n *        // results is now an array of the existing files\n *    }\n * });\n *\n * // Using Promises\n * async.filter(files, fileExists)\n * .then(results => {\n *     console.log(results);\n *     // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n *     // results is now an array of the existing files\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let results = await async.filter(files, fileExists);\n *         console.log(results);\n *         // [ 'dir1/file1.txt', 'dir2/file3.txt' ]\n *         // results is now an array of the existing files\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction filter (coll, iteratee, callback) {\n    return _filter(eachOf$1, coll, iteratee, callback)\n}\nvar filter$1 = awaitify(filter, 3);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name filterLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback provided\n */\nfunction filterLimit (coll, limit, iteratee, callback) {\n    return _filter(eachOfLimit(limit), coll, iteratee, callback)\n}\nvar filterLimit$1 = awaitify(filterLimit, 4);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n *\n * @name filterSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectSeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results)\n * @returns {Promise} a promise, if no callback provided\n */\nfunction filterSeries (coll, iteratee, callback) {\n    return _filter(eachOfSeries$1, coll, iteratee, callback)\n}\nvar filterSeries$1 = awaitify(filterSeries, 3);\n\n/**\n * Calls the asynchronous function `fn` with a callback parameter that allows it\n * to call itself again, in series, indefinitely.\n\n * If an error is passed to the callback then `errback` is called with the\n * error, and execution stops, otherwise it will never be called.\n *\n * @name forever\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} fn - an async function to call repeatedly.\n * Invoked with (next).\n * @param {Function} [errback] - when `fn` passes an error to it's callback,\n * this function will be called, and execution stops. Invoked with (err).\n * @returns {Promise} a promise that rejects if an error occurs and an errback\n * is not passed\n * @example\n *\n * async.forever(\n *     function(next) {\n *         // next is suitable for passing to things that need a callback(err [, whatever]);\n *         // it will result in this function being called again.\n *     },\n *     function(err) {\n *         // if next is called with a value in its first parameter, it will appear\n *         // in here as 'err', and execution will stop.\n *     }\n * );\n */\nfunction forever(fn, errback) {\n    var done = onlyOnce(errback);\n    var task = wrapAsync(ensureAsync(fn));\n\n    function next(err) {\n        if (err) return done(err);\n        if (err === false) return;\n        task(next);\n    }\n    return next();\n}\nvar forever$1 = awaitify(forever, 2);\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n *\n * @name groupByLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction groupByLimit(coll, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return mapLimit$1(coll, limit, (val, iterCb) => {\n        _iteratee(val, (err, key) => {\n            if (err) return iterCb(err);\n            return iterCb(err, {key, val});\n        });\n    }, (err, mapResults) => {\n        var result = {};\n        // from MDN, handle object having an `hasOwnProperty` prop\n        var {hasOwnProperty} = Object.prototype;\n\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                var {key} = mapResults[i];\n                var {val} = mapResults[i];\n\n                if (hasOwnProperty.call(result, key)) {\n                    result[key].push(val);\n                } else {\n                    result[key] = [val];\n                }\n            }\n        }\n\n        return callback(err, result);\n    });\n}\n\nvar groupByLimit$1 = awaitify(groupByLimit, 4);\n\n/**\n * Returns a new object, where each value corresponds to an array of items, from\n * `coll`, that returned the corresponding key. That is, the keys of the object\n * correspond to the values passed to the `iteratee` callback.\n *\n * Note: Since this function applies the `iteratee` to each item in parallel,\n * there is no guarantee that the `iteratee` functions will complete in order.\n * However, the values for each key in the `result` will be in the same order as\n * the original `coll`. For Objects, the values will roughly be in the order of\n * the original Objects' keys (but this can vary across JavaScript engines).\n *\n * @name groupBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * const files = ['dir1/file1.txt','dir2','dir4']\n *\n * // asynchronous function that detects file type as none, file, or directory\n * function detectFile(file, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(null, 'none');\n *         }\n *         callback(null, stat.isDirectory() ? 'directory' : 'file');\n *     });\n * }\n *\n * //Using callbacks\n * async.groupBy(files, detectFile, function(err, result) {\n *     if(err) {\n *         console.log(err);\n *     } else {\n *\t       console.log(result);\n *         // {\n *         //     file: [ 'dir1/file1.txt' ],\n *         //     none: [ 'dir4' ],\n *         //     directory: [ 'dir2']\n *         // }\n *         // result is object containing the files grouped by type\n *     }\n * });\n *\n * // Using Promises\n * async.groupBy(files, detectFile)\n * .then( result => {\n *     console.log(result);\n *     // {\n *     //     file: [ 'dir1/file1.txt' ],\n *     //     none: [ 'dir4' ],\n *     //     directory: [ 'dir2']\n *     // }\n *     // result is object containing the files grouped by type\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.groupBy(files, detectFile);\n *         console.log(result);\n *         // {\n *         //     file: [ 'dir1/file1.txt' ],\n *         //     none: [ 'dir4' ],\n *         //     directory: [ 'dir2']\n *         // }\n *         // result is object containing the files grouped by type\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction groupBy (coll, iteratee, callback) {\n    return groupByLimit$1(coll, Infinity, iteratee, callback)\n}\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n *\n * @name groupBySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whose\n * properties are arrays of values which returned the corresponding key.\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction groupBySeries (coll, iteratee, callback) {\n    return groupByLimit$1(coll, 1, iteratee, callback)\n}\n\n/**\n * Logs the result of an `async` function to the `console`. Only works in\n * Node.js or in browsers that support `console.log` and `console.error` (such\n * as FF and Chrome). If multiple arguments are returned from the async\n * function, `console.log` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, 'hello ' + name);\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.log(hello, 'world');\n * 'hello world'\n */\nvar log = consoleFunc('log');\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name mapValuesLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction mapValuesLimit(obj, limit, iteratee, callback) {\n    callback = once(callback);\n    var newObj = {};\n    var _iteratee = wrapAsync(iteratee);\n    return eachOfLimit(limit)(obj, (val, key, next) => {\n        _iteratee(val, key, (err, result) => {\n            if (err) return next(err);\n            newObj[key] = result;\n            next(err);\n        });\n    }, err => callback(err, newObj));\n}\n\nvar mapValuesLimit$1 = awaitify(mapValuesLimit, 4);\n\n/**\n * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n *\n * Produces a new Object by mapping each value of `obj` through the `iteratee`\n * function. The `iteratee` is called each `value` and `key` from `obj` and a\n * callback for when it has finished processing. Each of these callbacks takes\n * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n * passes an error to its callback, the main `callback` (for the `mapValues`\n * function) is immediately called with the error.\n *\n * Note, the order of the keys in the result is not guaranteed.  The keys will\n * be roughly in the order they complete, (but this is very engine-specific)\n *\n * @name mapValues\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n * // file4.txt does not exist\n *\n * const fileMap = {\n *     f1: 'file1.txt',\n *     f2: 'file2.txt',\n *     f3: 'file3.txt'\n * };\n *\n * const withMissingFileMap = {\n *     f1: 'file1.txt',\n *     f2: 'file2.txt',\n *     f3: 'file4.txt'\n * };\n *\n * // asynchronous function that returns the file size in bytes\n * function getFileSizeInBytes(file, key, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         callback(null, stat.size);\n *     });\n * }\n *\n * // Using callbacks\n * async.mapValues(fileMap, getFileSizeInBytes, function(err, result) {\n *     if (err) {\n *         console.log(err);\n *     } else {\n *         console.log(result);\n *         // result is now a map of file size in bytes for each file, e.g.\n *         // {\n *         //     f1: 1000,\n *         //     f2: 2000,\n *         //     f3: 3000\n *         // }\n *     }\n * });\n *\n * // Error handling\n * async.mapValues(withMissingFileMap, getFileSizeInBytes, function(err, result) {\n *     if (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     } else {\n *         console.log(result);\n *     }\n * });\n *\n * // Using Promises\n * async.mapValues(fileMap, getFileSizeInBytes)\n * .then( result => {\n *     console.log(result);\n *     // result is now a map of file size in bytes for each file, e.g.\n *     // {\n *     //     f1: 1000,\n *     //     f2: 2000,\n *     //     f3: 3000\n *     // }\n * }).catch (err => {\n *     console.log(err);\n * });\n *\n * // Error Handling\n * async.mapValues(withMissingFileMap, getFileSizeInBytes)\n * .then( result => {\n *     console.log(result);\n * }).catch (err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.mapValues(fileMap, getFileSizeInBytes);\n *         console.log(result);\n *         // result is now a map of file size in bytes for each file, e.g.\n *         // {\n *         //     f1: 1000,\n *         //     f2: 2000,\n *         //     f3: 3000\n *         // }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         let result = await async.mapValues(withMissingFileMap, getFileSizeInBytes);\n *         console.log(result);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     }\n * }\n *\n */\nfunction mapValues(obj, iteratee, callback) {\n    return mapValuesLimit$1(obj, Infinity, iteratee, callback)\n}\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n *\n * @name mapValuesSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction mapValuesSeries(obj, iteratee, callback) {\n    return mapValuesLimit$1(obj, 1, iteratee, callback)\n}\n\n/**\n * Caches the results of an async function. When creating a hash to store\n * function results against, the callback is omitted from the hash and an\n * optional hash function can be used.\n *\n * **Note: if the async function errs, the result will not be cached and\n * subsequent calls will call the wrapped function.**\n *\n * If no hash function is specified, the first argument is used as a hash key,\n * which may work reasonably if it is a string or a data type that converts to a\n * distinct string. Note that objects and arrays will not behave reasonably.\n * Neither will cases where the other arguments are significant. In such cases,\n * specify your own hash function.\n *\n * The cache of results is exposed as the `memo` property of the function\n * returned by `memoize`.\n *\n * @name memoize\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n * @param {Function} hasher - An optional function for generating a custom hash\n * for storing results. It has all the arguments applied to it apart from the\n * callback, and must be synchronous.\n * @returns {AsyncFunction} a memoized version of `fn`\n * @example\n *\n * var slow_fn = function(name, callback) {\n *     // do something\n *     callback(null, result);\n * };\n * var fn = async.memoize(slow_fn);\n *\n * // fn can now be used as if it were slow_fn\n * fn('some name', function() {\n *     // callback\n * });\n */\nfunction memoize(fn, hasher = v => v) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    var _fn = wrapAsync(fn);\n    var memoized = initialParams((args, callback) => {\n        var key = hasher(...args);\n        if (key in memo) {\n            setImmediate$1(() => callback(null, ...memo[key]));\n        } else if (key in queues) {\n            queues[key].push(callback);\n        } else {\n            queues[key] = [callback];\n            _fn(...args, (err, ...resultArgs) => {\n                // #1465 don't memoize if an error occurred\n                if (!err) {\n                    memo[key] = resultArgs;\n                }\n                var q = queues[key];\n                delete queues[key];\n                for (var i = 0, l = q.length; i < l; i++) {\n                    q[i](err, ...resultArgs);\n                }\n            });\n        }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n}\n\n/* istanbul ignore file */\n\n/**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `process.nextTick`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name nextTick\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.setImmediate]{@link module:Utils.setImmediate}\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */\nvar _defer$1;\n\nif (hasNextTick) {\n    _defer$1 = process.nextTick;\n} else if (hasSetImmediate) {\n    _defer$1 = setImmediate;\n} else {\n    _defer$1 = fallback;\n}\n\nvar nextTick = wrap(_defer$1);\n\nvar parallel = awaitify((eachfn, tasks, callback) => {\n    var results = isArrayLike(tasks) ? [] : {};\n\n    eachfn(tasks, (task, key, taskCb) => {\n        wrapAsync(task)((err, ...result) => {\n            if (result.length < 2) {\n                [result] = result;\n            }\n            results[key] = result;\n            taskCb(err);\n        });\n    }, err => callback(err, results));\n}, 3);\n\n/**\n * Run the `tasks` collection of functions in parallel, without waiting until\n * the previous function has completed. If any of the functions pass an error to\n * its callback, the main `callback` is immediately called with the value of the\n * error. Once the `tasks` have completed, the results are passed to the final\n * `callback` as an array.\n *\n * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n * parallel execution of code.  If your tasks do not use any timers or perform\n * any I/O, they will actually be executed in series.  Any synchronous setup\n * sections for each task will happen one after the other.  JavaScript remains\n * single-threaded.\n *\n * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n * execution of other tasks when a task fails.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n * results from {@link async.parallel}.\n *\n * @name parallel\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n *\n * @example\n *\n * //Using Callbacks\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ], function(err, results) {\n *     console.log(results);\n *     // results is equal to ['one','two'] even though\n *     // the second function had a shorter timeout.\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     console.log(results);\n *     // results is equal to: { one: 1, two: 2 }\n * });\n *\n * //Using Promises\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ]).then(results => {\n *     console.log(results);\n *     // results is equal to ['one','two'] even though\n *     // the second function had a shorter timeout.\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }).then(results => {\n *     console.log(results);\n *     // results is equal to: { one: 1, two: 2 }\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.parallel([\n *             function(callback) {\n *                 setTimeout(function() {\n *                     callback(null, 'one');\n *                 }, 200);\n *             },\n *             function(callback) {\n *                 setTimeout(function() {\n *                     callback(null, 'two');\n *                 }, 100);\n *             }\n *         ]);\n *         console.log(results);\n *         // results is equal to ['one','two'] even though\n *         // the second function had a shorter timeout.\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // an example using an object instead of an array\n * async () => {\n *     try {\n *         let results = await async.parallel({\n *             one: function(callback) {\n *                 setTimeout(function() {\n *                     callback(null, 1);\n *                 }, 200);\n *             },\n *            two: function(callback) {\n *                 setTimeout(function() {\n *                     callback(null, 2);\n *                 }, 100);\n *            }\n *         });\n *         console.log(results);\n *         // results is equal to: { one: 1, two: 2 }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction parallel$1(tasks, callback) {\n    return parallel(eachOf$1, tasks, callback);\n}\n\n/**\n * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name parallelLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.parallel]{@link module:ControlFlow.parallel}\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n */\nfunction parallelLimit(tasks, limit, callback) {\n    return parallel(eachOfLimit(limit), tasks, callback);\n}\n\n/**\n * A queue of tasks for the worker function to complete.\n * @typedef {Iterable} QueueObject\n * @memberOf module:ControlFlow\n * @property {Function} length - a function returning the number of items\n * waiting to be processed. Invoke with `queue.length()`.\n * @property {boolean} started - a boolean indicating whether or not any\n * items have been pushed and processed by the queue.\n * @property {Function} running - a function returning the number of items\n * currently being processed. Invoke with `queue.running()`.\n * @property {Function} workersList - a function returning the array of items\n * currently being processed. Invoke with `queue.workersList()`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n * @property {number} concurrency - an integer for determining how many `worker`\n * functions should be run in parallel. This property can be changed after a\n * `queue` is created to alter the concurrency on-the-fly.\n * @property {number} payload - an integer that specifies how many items are\n * passed to the worker function at a time. only applies if this is a\n * [cargo]{@link module:ControlFlow.cargo} object\n * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`\n * once the `worker` has finished processing the task. Instead of a single task,\n * a `tasks` array can be submitted. The respective callback is used for every\n * task in the list. Invoke with `queue.push(task, [callback])`,\n * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.\n * Invoke with `queue.unshift(task, [callback])`.\n * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns\n * a promise that rejects if an error occurs.\n * @property {AsyncFunction} unshiftAsync - the same as `q.unshift`, except this returns\n * a promise that rejects if an error occurs.\n * @property {Function} remove - remove items from the queue that match a test\n * function.  The test function will be passed an object with a `data` property,\n * and a `priority` property, if this is a\n * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.\n * Invoked with `queue.remove(testFn)`, where `testFn` is of the form\n * `function ({data, priority}) {}` and returns a Boolean.\n * @property {Function} saturated - a function that sets a callback that is\n * called when the number of running workers hits the `concurrency` limit, and\n * further tasks will be queued.  If the callback is omitted, `q.saturated()`\n * returns a promise for the next occurrence.\n * @property {Function} unsaturated - a function that sets a callback that is\n * called when the number of running workers is less than the `concurrency` &\n * `buffer` limits, and further tasks will not be queued. If the callback is\n * omitted, `q.unsaturated()` returns a promise for the next occurrence.\n * @property {number} buffer - A minimum threshold buffer in order to say that\n * the `queue` is `unsaturated`.\n * @property {Function} empty - a function that sets a callback that is called\n * when the last item from the `queue` is given to a `worker`. If the callback\n * is omitted, `q.empty()` returns a promise for the next occurrence.\n * @property {Function} drain - a function that sets a callback that is called\n * when the last item from the `queue` has returned from the `worker`. If the\n * callback is omitted, `q.drain()` returns a promise for the next occurrence.\n * @property {Function} error - a function that sets a callback that is called\n * when a task errors. Has the signature `function(error, task)`. If the\n * callback is omitted, `error()` returns a promise that rejects on the next\n * error.\n * @property {boolean} paused - a boolean for determining whether the queue is\n * in a paused state.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke with `queue.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. No more tasks\n * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.\n *\n * @example\n * const q = async.queue(worker, 2)\n * q.push(item1)\n * q.push(item2)\n * q.push(item3)\n * // queues are iterable, spread into an array to inspect\n * const items = [...q] // [item1, item2, item3]\n * // or use for of\n * for (let item of q) {\n *     console.log(item)\n * }\n *\n * q.drain(() => {\n *     console.log('all done')\n * })\n * // or\n * await q.drain()\n */\n\n/**\n * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n * `queue` are processed in parallel (up to the `concurrency` limit). If all\n * `worker`s are in progress, the task is queued until one becomes available.\n * Once a `worker` completes a `task`, that `task`'s callback is called.\n *\n * @name queue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`. Invoked with (task, callback).\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be\n * attached as certain properties to listen for specific events during the\n * lifecycle of the queue.\n * @example\n *\n * // create a queue object with concurrency 2\n * var q = async.queue(function(task, callback) {\n *     console.log('hello ' + task.name);\n *     callback();\n * }, 2);\n *\n * // assign a callback\n * q.drain(function() {\n *     console.log('all items have been processed');\n * });\n * // or await the end\n * await q.drain()\n *\n * // assign an error callback\n * q.error(function(err, task) {\n *     console.error('task experienced an error');\n * });\n *\n * // add some items to the queue\n * q.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * // callback is optional\n * q.push({name: 'bar'});\n *\n * // add some items to the queue (batch-wise)\n * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n *     console.log('finished processing item');\n * });\n *\n * // add some items to the front of the queue\n * q.unshift({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n */\nfunction queue$1 (worker, concurrency) {\n    var _worker = wrapAsync(worker);\n    return queue((items, cb) => {\n        _worker(items[0], cb);\n    }, concurrency, 1);\n}\n\n// Binary min-heap implementation used for priority queue.\n// Implementation is stable, i.e. push time is considered for equal priorities\nclass Heap {\n    constructor() {\n        this.heap = [];\n        this.pushCount = Number.MIN_SAFE_INTEGER;\n    }\n\n    get length() {\n        return this.heap.length;\n    }\n\n    empty () {\n        this.heap = [];\n        return this;\n    }\n\n    percUp(index) {\n        let p;\n\n        while (index > 0 && smaller(this.heap[index], this.heap[p=parent(index)])) {\n            let t = this.heap[index];\n            this.heap[index] = this.heap[p];\n            this.heap[p] = t;\n\n            index = p;\n        }\n    }\n\n    percDown(index) {\n        let l;\n\n        while ((l=leftChi(index)) < this.heap.length) {\n            if (l+1 < this.heap.length && smaller(this.heap[l+1], this.heap[l])) {\n                l = l+1;\n            }\n\n            if (smaller(this.heap[index], this.heap[l])) {\n                break;\n            }\n\n            let t = this.heap[index];\n            this.heap[index] = this.heap[l];\n            this.heap[l] = t;\n\n            index = l;\n        }\n    }\n\n    push(node) {\n        node.pushCount = ++this.pushCount;\n        this.heap.push(node);\n        this.percUp(this.heap.length-1);\n    }\n\n    unshift(node) {\n        return this.heap.push(node);\n    }\n\n    shift() {\n        let [top] = this.heap;\n\n        this.heap[0] = this.heap[this.heap.length-1];\n        this.heap.pop();\n        this.percDown(0);\n\n        return top;\n    }\n\n    toArray() {\n        return [...this];\n    }\n\n    *[Symbol.iterator] () {\n        for (let i = 0; i < this.heap.length; i++) {\n            yield this.heap[i].data;\n        }\n    }\n\n    remove (testFn) {\n        let j = 0;\n        for (let i = 0; i < this.heap.length; i++) {\n            if (!testFn(this.heap[i])) {\n                this.heap[j] = this.heap[i];\n                j++;\n            }\n        }\n\n        this.heap.splice(j);\n\n        for (let i = parent(this.heap.length-1); i >= 0; i--) {\n            this.percDown(i);\n        }\n\n        return this;\n    }\n}\n\nfunction leftChi(i) {\n    return (i<<1)+1;\n}\n\nfunction parent(i) {\n    return ((i+1)>>1)-1;\n}\n\nfunction smaller(x, y) {\n    if (x.priority !== y.priority) {\n        return x.priority < y.priority;\n    }\n    else {\n        return x.pushCount < y.pushCount;\n    }\n}\n\n/**\n * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n * completed in ascending priority order.\n *\n * @name priorityQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`.\n * Invoked with (task, callback).\n * @param {number} concurrency - An `integer` for determining how many `worker`\n * functions should be run in parallel.  If omitted, the concurrency defaults to\n * `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are three\n * differences between `queue` and `priorityQueue` objects:\n * * `push(task, priority, [callback])` - `priority` should be a number. If an\n *   array of `tasks` is given, all tasks will be assigned the same priority.\n * * `pushAsync(task, priority, [callback])` - the same as `priorityQueue.push`,\n *   except this returns a promise that rejects if an error occurs.\n * * The `unshift` and `unshiftAsync` methods were removed.\n */\nfunction priorityQueue(worker, concurrency) {\n    // Start with a normal queue\n    var q = queue$1(worker, concurrency);\n\n    var {\n        push,\n        pushAsync\n    } = q;\n\n    q._tasks = new Heap();\n    q._createTaskItem = ({data, priority}, callback) => {\n        return {\n            data,\n            priority,\n            callback\n        };\n    };\n\n    function createDataItems(tasks, priority) {\n        if (!Array.isArray(tasks)) {\n            return {data: tasks, priority};\n        }\n        return tasks.map(data => { return {data, priority}; });\n    }\n\n    // Override push to accept second parameter representing priority\n    q.push = function(data, priority = 0, callback) {\n        return push(createDataItems(data, priority), callback);\n    };\n\n    q.pushAsync = function(data, priority = 0, callback) {\n        return pushAsync(createDataItems(data, priority), callback);\n    };\n\n    // Remove unshift functions\n    delete q.unshift;\n    delete q.unshiftAsync;\n\n    return q;\n}\n\n/**\n * Runs the `tasks` array of functions in parallel, without waiting until the\n * previous function has completed. Once any of the `tasks` complete or pass an\n * error to its callback, the main `callback` is immediately called. It's\n * equivalent to `Promise.race()`.\n *\n * @name race\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n * to run. Each function can complete with an optional `result` value.\n * @param {Function} callback - A callback to run once any of the functions have\n * completed. This function gets an error or result from the first function that\n * completed. Invoked with (err, result).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * async.race([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // main callback\n * function(err, result) {\n *     // the result will be equal to 'two' as it finishes earlier\n * });\n */\nfunction race(tasks, callback) {\n    callback = once(callback);\n    if (!Array.isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n    if (!tasks.length) return callback();\n    for (var i = 0, l = tasks.length; i < l; i++) {\n        wrapAsync(tasks[i])(callback);\n    }\n}\n\nvar race$1 = awaitify(race, 2);\n\n/**\n * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n *\n * @name reduceRight\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reduce]{@link module:Collections.reduce}\n * @alias foldr\n * @category Collection\n * @param {Array} array - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee completes with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction reduceRight (array, memo, iteratee, callback) {\n    var reversed = [...array].reverse();\n    return reduce$1(reversed, memo, iteratee, callback);\n}\n\n/**\n * Wraps the async function in another function that always completes with a\n * result object, even when it errors.\n *\n * The result object has either the property `error` or `value`.\n *\n * @name reflect\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function you want to wrap\n * @returns {Function} - A function that always passes null to it's callback as\n * the error. The second argument to the callback will be an `object` with\n * either an `error` or a `value` property.\n * @example\n *\n * async.parallel([\n *     async.reflect(function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff but error ...\n *         callback('bad stuff happened');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     })\n * ],\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = 'bad stuff happened'\n *     // results[2].value = 'two'\n * });\n */\nfunction reflect(fn) {\n    var _fn = wrapAsync(fn);\n    return initialParams(function reflectOn(args, reflectCallback) {\n        args.push((error, ...cbArgs) => {\n            let retVal = {};\n            if (error) {\n                retVal.error = error;\n            }\n            if (cbArgs.length > 0){\n                var value = cbArgs;\n                if (cbArgs.length <= 1) {\n                    [value] = cbArgs;\n                }\n                retVal.value = value;\n            }\n            reflectCallback(null, retVal);\n        });\n\n        return _fn.apply(this, args);\n    });\n}\n\n/**\n * A helper function that wraps an array or an object of functions with `reflect`.\n *\n * @name reflectAll\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.reflect]{@link module:Utils.reflect}\n * @category Util\n * @param {Array|Object|Iterable} tasks - The collection of\n * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n * @returns {Array} Returns an array of async functions, each wrapped in\n * `async.reflect`\n * @example\n *\n * let tasks = [\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         // do some more stuff but error ...\n *         callback(new Error('bad stuff happened'));\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ];\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = Error('bad stuff happened')\n *     // results[2].value = 'two'\n * });\n *\n * // an example using an object instead of an array\n * let tasks = {\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         callback('two');\n *     },\n *     three: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'three');\n *         }, 100);\n *     }\n * };\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results.one.value = 'one'\n *     // results.two.error = 'two'\n *     // results.three.value = 'three'\n * });\n */\nfunction reflectAll(tasks) {\n    var results;\n    if (Array.isArray(tasks)) {\n        results = tasks.map(reflect);\n    } else {\n        results = {};\n        Object.keys(tasks).forEach(key => {\n            results[key] = reflect.call(this, tasks[key]);\n        });\n    }\n    return results;\n}\n\nfunction reject(eachfn, arr, _iteratee, callback) {\n    const iteratee = wrapAsync(_iteratee);\n    return _filter(eachfn, arr, (value, cb) => {\n        iteratee(value, (err, v) => {\n            cb(err, !v);\n        });\n    }, callback);\n}\n\n/**\n * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n *\n * @name reject\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n *\n * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * // Using callbacks\n * async.reject(fileList, fileExists, function(err, results) {\n *    // [ 'dir3/file6.txt' ]\n *    // results now equals an array of the non-existing files\n * });\n *\n * // Using Promises\n * async.reject(fileList, fileExists)\n * .then( results => {\n *     console.log(results);\n *     // [ 'dir3/file6.txt' ]\n *     // results now equals an array of the non-existing files\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let results = await async.reject(fileList, fileExists);\n *         console.log(results);\n *         // [ 'dir3/file6.txt' ]\n *         // results now equals an array of the non-existing files\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction reject$1 (coll, iteratee, callback) {\n    return reject(eachOf$1, coll, iteratee, callback)\n}\nvar reject$2 = awaitify(reject$1, 3);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name rejectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction rejectLimit (coll, limit, iteratee, callback) {\n    return reject(eachOfLimit(limit), coll, iteratee, callback)\n}\nvar rejectLimit$1 = awaitify(rejectLimit, 4);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n *\n * @name rejectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback is passed\n */\nfunction rejectSeries (coll, iteratee, callback) {\n    return reject(eachOfSeries$1, coll, iteratee, callback)\n}\nvar rejectSeries$1 = awaitify(rejectSeries, 3);\n\nfunction constant$1(value) {\n    return function () {\n        return value;\n    }\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n * @returns {Promise} a promise if no callback provided\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nconst DEFAULT_TIMES = 5;\nconst DEFAULT_INTERVAL = 0;\n\nfunction retry(opts, task, callback) {\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant$1(DEFAULT_INTERVAL)\n    };\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || promiseCallback();\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || promiseCallback();\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = wrapAsync(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task((err, ...args) => {\n            if (err === false) return\n            if (err && attempt++ < options.times &&\n                (typeof options.errorFilter != 'function' ||\n                    options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt - 1));\n            } else {\n                callback(err, ...args);\n            }\n        });\n    }\n\n    retryAttempt();\n    return callback[PROMISE_SYMBOL]\n}\n\nfunction parseTimes(acc, t) {\n    if (typeof t === 'object') {\n        acc.times = +t.times || DEFAULT_TIMES;\n\n        acc.intervalFunc = typeof t.interval === 'function' ?\n            t.interval :\n            constant$1(+t.interval || DEFAULT_INTERVAL);\n\n        acc.errorFilter = t.errorFilter;\n    } else if (typeof t === 'number' || typeof t === 'string') {\n        acc.times = +t || DEFAULT_TIMES;\n    } else {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n}\n\n/**\n * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n * wraps a task and makes it retryable, rather than immediately calling it\n * with retries.\n *\n * @name retryable\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.retry]{@link module:ControlFlow.retry}\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n * options, exactly the same as from `retry`, except for a `opts.arity` that\n * is the arity of the `task` function, defaulting to `task.length`\n * @param {AsyncFunction} task - the asynchronous function to wrap.\n * This function will be passed any arguments passed to the returned wrapper.\n * Invoked with (...args, callback).\n * @returns {AsyncFunction} The wrapped function, which when invoked, will\n * retry on an error, based on the parameters specified in `opts`.\n * This function will accept the same parameters as `task`.\n * @example\n *\n * async.auto({\n *     dep1: async.retryable(3, getFromFlakyService),\n *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n *         maybeProcessData(results.dep1, cb);\n *     })]\n * }, callback);\n */\nfunction retryable (opts, task) {\n    if (!task) {\n        task = opts;\n        opts = null;\n    }\n    let arity = (opts && opts.arity) || task.length;\n    if (isAsync(task)) {\n        arity += 1;\n    }\n    var _task = wrapAsync(task);\n    return initialParams((args, callback) => {\n        if (args.length < arity - 1 || callback == null) {\n            args.push(callback);\n            callback = promiseCallback();\n        }\n        function taskFn(cb) {\n            _task(...args, cb);\n        }\n\n        if (opts) retry(opts, taskFn, callback);\n        else retry(taskFn, callback);\n\n        return callback[PROMISE_SYMBOL]\n    });\n}\n\n/**\n * Run the functions in the `tasks` collection in series, each one running once\n * the previous function has completed. If any functions in the series pass an\n * error to its callback, no more functions are run, and `callback` is\n * immediately called with the value of the error. Otherwise, `callback`\n * receives an array of results when `tasks` have completed.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function, and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n *  results from {@link async.series}.\n *\n * **Note** that while many implementations preserve the order of object\n * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n * explicitly states that\n *\n * > The mechanics and order of enumerating the properties is not specified.\n *\n * So if you rely on the order in which your series of functions are executed,\n * and want this to work on all platforms, consider using an array.\n *\n * @name series\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing\n * [async functions]{@link AsyncFunction} to run in series.\n * Each function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This function gets a results array (or object)\n * containing all the result arguments passed to the `task` callbacks. Invoked\n * with (err, result).\n * @return {Promise} a promise, if no callback is passed\n * @example\n *\n * //Using Callbacks\n * async.series([\n *     function(callback) {\n *         setTimeout(function() {\n *             // do some async task\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             // then do another async task\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ], function(err, results) {\n *     console.log(results);\n *     // results is equal to ['one','two']\n * });\n *\n * // an example using objects instead of arrays\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             // do some async task\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             // then do another async task\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     console.log(results);\n *     // results is equal to: { one: 1, two: 2 }\n * });\n *\n * //Using Promises\n * async.series([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ]).then(results => {\n *     console.log(results);\n *     // results is equal to ['one','two']\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // an example using an object instead of an array\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             // do some async task\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             // then do another async task\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }).then(results => {\n *     console.log(results);\n *     // results is equal to: { one: 1, two: 2 }\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.series([\n *             function(callback) {\n *                 setTimeout(function() {\n *                     // do some async task\n *                     callback(null, 'one');\n *                 }, 200);\n *             },\n *             function(callback) {\n *                 setTimeout(function() {\n *                     // then do another async task\n *                     callback(null, 'two');\n *                 }, 100);\n *             }\n *         ]);\n *         console.log(results);\n *         // results is equal to ['one','two']\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // an example using an object instead of an array\n * async () => {\n *     try {\n *         let results = await async.parallel({\n *             one: function(callback) {\n *                 setTimeout(function() {\n *                     // do some async task\n *                     callback(null, 1);\n *                 }, 200);\n *             },\n *            two: function(callback) {\n *                 setTimeout(function() {\n *                     // then do another async task\n *                     callback(null, 2);\n *                 }, 100);\n *            }\n *         });\n *         console.log(results);\n *         // results is equal to: { one: 1, two: 2 }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction series(tasks, callback) {\n    return parallel(eachOfSeries$1, tasks, callback);\n}\n\n/**\n * Returns `true` if at least one element in the `coll` satisfies an async test.\n * If any iteratee call returns `true`, the main `callback` is immediately\n * called.\n *\n * @name some\n * @static\n * @memberOf module:Collections\n * @method\n * @alias any\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * // Using callbacks\n * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists,\n *    function(err, result) {\n *        console.log(result);\n *        // true\n *        // result is true since some file in the list exists\n *    }\n *);\n *\n * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists,\n *    function(err, result) {\n *        console.log(result);\n *        // false\n *        // result is false since none of the files exists\n *    }\n *);\n *\n * // Using Promises\n * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists)\n * .then( result => {\n *     console.log(result);\n *     // true\n *     // result is true since some file in the list exists\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists)\n * .then( result => {\n *     console.log(result);\n *     // false\n *     // result is false since none of the files exists\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists);\n *         console.log(result);\n *         // true\n *         // result is true since some file in the list exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * async () => {\n *     try {\n *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists);\n *         console.log(result);\n *         // false\n *         // result is false since none of the files exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction some(coll, iteratee, callback) {\n    return _createTester(Boolean, res => res)(eachOf$1, coll, iteratee, callback)\n}\nvar some$1 = awaitify(some, 3);\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n *\n * @name someLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anyLimit\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n */\nfunction someLimit(coll, limit, iteratee, callback) {\n    return _createTester(Boolean, res => res)(eachOfLimit(limit), coll, iteratee, callback)\n}\nvar someLimit$1 = awaitify(someLimit, 4);\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n *\n * @name someSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anySeries\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in series.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n */\nfunction someSeries(coll, iteratee, callback) {\n    return _createTester(Boolean, res => res)(eachOfSeries$1, coll, iteratee, callback)\n}\nvar someSeries$1 = awaitify(someSeries, 3);\n\n/**\n * Sorts a list by the results of running each `coll` value through an async\n * `iteratee`.\n *\n * @name sortBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a value to use as the sort criteria as\n * its `result`.\n * Invoked with (item, callback).\n * @param {Function} callback - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is the items\n * from the original `coll` sorted by the values returned by the `iteratee`\n * calls. Invoked with (err, results).\n * @returns {Promise} a promise, if no callback passed\n * @example\n *\n * // bigfile.txt is a file that is 251100 bytes in size\n * // mediumfile.txt is a file that is 11000 bytes in size\n * // smallfile.txt is a file that is 121 bytes in size\n *\n * // asynchronous function that returns the file size in bytes\n * function getFileSizeInBytes(file, callback) {\n *     fs.stat(file, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         callback(null, stat.size);\n *     });\n * }\n *\n * // Using callbacks\n * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes,\n *     function(err, results) {\n *         if (err) {\n *             console.log(err);\n *         } else {\n *             console.log(results);\n *             // results is now the original array of files sorted by\n *             // file size (ascending by default), e.g.\n *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n *         }\n *     }\n * );\n *\n * // By modifying the callback parameter the\n * // sorting order can be influenced:\n *\n * // ascending order\n * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], function(file, callback) {\n *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {\n *         if (getFileSizeErr) return callback(getFileSizeErr);\n *         callback(null, fileSize);\n *     });\n * }, function(err, results) {\n *         if (err) {\n *             console.log(err);\n *         } else {\n *             console.log(results);\n *             // results is now the original array of files sorted by\n *             // file size (ascending by default), e.g.\n *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n *         }\n *     }\n * );\n *\n * // descending order\n * async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], function(file, callback) {\n *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {\n *         if (getFileSizeErr) {\n *             return callback(getFileSizeErr);\n *         }\n *         callback(null, fileSize * -1);\n *     });\n * }, function(err, results) {\n *         if (err) {\n *             console.log(err);\n *         } else {\n *             console.log(results);\n *             // results is now the original array of files sorted by\n *             // file size (ascending by default), e.g.\n *             // [ 'bigfile.txt', 'mediumfile.txt', 'smallfile.txt']\n *         }\n *     }\n * );\n *\n * // Error handling\n * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes,\n *     function(err, results) {\n *         if (err) {\n *             console.log(err);\n *             // [ Error: ENOENT: no such file or directory ]\n *         } else {\n *             console.log(results);\n *         }\n *     }\n * );\n *\n * // Using Promises\n * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes)\n * .then( results => {\n *     console.log(results);\n *     // results is now the original array of files sorted by\n *     // file size (ascending by default), e.g.\n *     // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n * }).catch( err => {\n *     console.log(err);\n * });\n *\n * // Error handling\n * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes)\n * .then( results => {\n *     console.log(results);\n * }).catch( err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n * });\n *\n * // Using async/await\n * (async () => {\n *     try {\n *         let results = await async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);\n *         console.log(results);\n *         // results is now the original array of files sorted by\n *         // file size (ascending by default), e.g.\n *         // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * })();\n *\n * // Error handling\n * async () => {\n *     try {\n *         let results = await async.sortBy(['missingfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);\n *         console.log(results);\n *     }\n *     catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *     }\n * }\n *\n */\nfunction sortBy (coll, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return map$1(coll, (x, iterCb) => {\n        _iteratee(x, (err, criteria) => {\n            if (err) return iterCb(err);\n            iterCb(err, {value: x, criteria});\n        });\n    }, (err, results) => {\n        if (err) return callback(err);\n        callback(null, results.sort(comparator).map(v => v.value));\n    });\n\n    function comparator(left, right) {\n        var a = left.criteria, b = right.criteria;\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\nvar sortBy$1 = awaitify(sortBy, 3);\n\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} asyncFn - The async function to limit in time.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n * of the control flow functions.\n * Invoke this function with the same parameters as you would `asyncFunc`.\n * @example\n *\n * function myFunction(foo, callback) {\n *     doAsyncTask(foo, function(err, data) {\n *         // handle errors\n *         if (err) return callback(err);\n *\n *         // do some stuff ...\n *\n *         // return processed data\n *         return callback(null, data);\n *     });\n * }\n *\n * var wrapped = async.timeout(myFunction, 1000);\n *\n * // call `wrapped` as you would `myFunction`\n * wrapped({ bar: 'bar' }, function(err, data) {\n *     // if `myFunction` takes < 1000 ms to execute, `err`\n *     // and `data` will have their expected values\n *\n *     // else `err` will be an Error with the code 'ETIMEDOUT'\n * });\n */\nfunction timeout(asyncFn, milliseconds, info) {\n    var fn = wrapAsync(asyncFn);\n\n    return initialParams((args, callback) => {\n        var timedOut = false;\n        var timer;\n\n        function timeoutCallback() {\n            var name = asyncFn.name || 'anonymous';\n            var error  = new Error('Callback function \"' + name + '\" timed out.');\n            error.code = 'ETIMEDOUT';\n            if (info) {\n                error.info = info;\n            }\n            timedOut = true;\n            callback(error);\n        }\n\n        args.push((...cbArgs) => {\n            if (!timedOut) {\n                callback(...cbArgs);\n                clearTimeout(timer);\n            }\n        });\n\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        fn(...args);\n    });\n}\n\nfunction range(size) {\n    var result = Array(size);\n    while (size--) {\n        result[size] = size;\n    }\n    return result;\n}\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name timesLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} count - The number of times to run the function.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n * @returns {Promise} a promise, if no callback is provided\n */\nfunction timesLimit(count, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return mapLimit$1(range(count), limit, _iteratee, callback);\n}\n\n/**\n * Calls the `iteratee` function `n` times, and accumulates results in the same\n * manner you would use with [map]{@link module:Collections.map}.\n *\n * @name times\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @returns {Promise} a promise, if no callback is provided\n * @example\n *\n * // Pretend this is some complicated async factory\n * var createUser = function(id, callback) {\n *     callback(null, {\n *         id: 'user' + id\n *     });\n * };\n *\n * // generate 5 users\n * async.times(5, function(n, next) {\n *     createUser(n, function(err, user) {\n *         next(err, user);\n *     });\n * }, function(err, users) {\n *     // we should now have 5 users\n * });\n */\nfunction times (n, iteratee, callback) {\n    return timesLimit(n, Infinity, iteratee, callback)\n}\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n *\n * @name timesSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @returns {Promise} a promise, if no callback is provided\n */\nfunction timesSeries (n, iteratee, callback) {\n    return timesLimit(n, 1, iteratee, callback)\n}\n\n/**\n * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n * element in parallel, each step potentially mutating an `accumulator` value.\n * The type of the accumulator defaults to the type of collection passed in.\n *\n * @name transform\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n * it will default to an empty Object or Array, depending on the type of `coll`\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * collection that potentially modifies the accumulator.\n * Invoked with (accumulator, item, key, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the transformed accumulator.\n * Invoked with (err, result).\n * @returns {Promise} a promise, if no callback provided\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n *\n * // helper function that returns human-readable size format from bytes\n * function formatBytes(bytes, decimals = 2) {\n *   // implementation not included for brevity\n *   return humanReadbleFilesize;\n * }\n *\n * const fileList = ['file1.txt','file2.txt','file3.txt'];\n *\n * // asynchronous function that returns the file size, transformed to human-readable format\n * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.\n * function transformFileSize(acc, value, key, callback) {\n *     fs.stat(value, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         acc[key] = formatBytes(stat.size);\n *         callback(null);\n *     });\n * }\n *\n * // Using callbacks\n * async.transform(fileList, transformFileSize, function(err, result) {\n *     if(err) {\n *         console.log(err);\n *     } else {\n *         console.log(result);\n *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n *     }\n * });\n *\n * // Using Promises\n * async.transform(fileList, transformFileSize)\n * .then(result => {\n *     console.log(result);\n *     // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * (async () => {\n *     try {\n *         let result = await async.transform(fileList, transformFileSize);\n *         console.log(result);\n *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * })();\n *\n * @example\n *\n * // file1.txt is a file that is 1000 bytes in size\n * // file2.txt is a file that is 2000 bytes in size\n * // file3.txt is a file that is 3000 bytes in size\n *\n * // helper function that returns human-readable size format from bytes\n * function formatBytes(bytes, decimals = 2) {\n *   // implementation not included for brevity\n *   return humanReadbleFilesize;\n * }\n *\n * const fileMap = { f1: 'file1.txt', f2: 'file2.txt', f3: 'file3.txt' };\n *\n * // asynchronous function that returns the file size, transformed to human-readable format\n * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.\n * function transformFileSize(acc, value, key, callback) {\n *     fs.stat(value, function(err, stat) {\n *         if (err) {\n *             return callback(err);\n *         }\n *         acc[key] = formatBytes(stat.size);\n *         callback(null);\n *     });\n * }\n *\n * // Using callbacks\n * async.transform(fileMap, transformFileSize, function(err, result) {\n *     if(err) {\n *         console.log(err);\n *     } else {\n *         console.log(result);\n *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n *     }\n * });\n *\n * // Using Promises\n * async.transform(fileMap, transformFileSize)\n * .then(result => {\n *     console.log(result);\n *     // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.transform(fileMap, transformFileSize);\n *         console.log(result);\n *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction transform (coll, accumulator, iteratee, callback) {\n    if (arguments.length <= 3 && typeof accumulator === 'function') {\n        callback = iteratee;\n        iteratee = accumulator;\n        accumulator = Array.isArray(coll) ? [] : {};\n    }\n    callback = once(callback || promiseCallback());\n    var _iteratee = wrapAsync(iteratee);\n\n    eachOf$1(coll, (v, k, cb) => {\n        _iteratee(accumulator, v, k, cb);\n    }, err => callback(err, accumulator));\n    return callback[PROMISE_SYMBOL]\n}\n\n/**\n * It runs each task in series but stops whenever any of the functions were\n * successful. If one of the tasks were successful, the `callback` will be\n * passed the result of the successful task. If all tasks fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name tryEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to\n * run, each function is passed a `callback(err, result)` it must call on\n * completion with an error `err` (which can be `null`) and an optional `result`\n * value.\n * @param {Function} [callback] - An optional callback which is called when one\n * of the tasks has succeeded, or all have failed. It receives the `err` and\n * `result` arguments of the last attempt at completing the `task`. Invoked with\n * (err, results).\n * @returns {Promise} a promise, if no callback is passed\n * @example\n * async.tryEach([\n *     function getDataFromFirstWebsite(callback) {\n *         // Try getting the data from the first website\n *         callback(err, data);\n *     },\n *     function getDataFromSecondWebsite(callback) {\n *         // First website failed,\n *         // Try getting the data from the backup website\n *         callback(err, data);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     Now do something with the data.\n * });\n *\n */\nfunction tryEach(tasks, callback) {\n    var error = null;\n    var result;\n    return eachSeries$1(tasks, (task, taskCb) => {\n        wrapAsync(task)((err, ...args) => {\n            if (err === false) return taskCb(err);\n\n            if (args.length < 2) {\n                [result] = args;\n            } else {\n                result = args;\n            }\n            error = err;\n            taskCb(err ? null : {});\n        });\n    }, () => callback(error, result));\n}\n\nvar tryEach$1 = awaitify(tryEach);\n\n/**\n * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n * unmemoized form. Handy for testing.\n *\n * @name unmemoize\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.memoize]{@link module:Utils.memoize}\n * @category Util\n * @param {AsyncFunction} fn - the memoized function\n * @returns {AsyncFunction} a function that calls the original unmemoized function\n */\nfunction unmemoize(fn) {\n    return (...args) => {\n        return (fn.unmemoized || fn)(...args);\n    };\n}\n\n/**\n * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs.\n *\n * @name whilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * var count = 0;\n * async.whilst(\n *     function test(cb) { cb(null, count < 5); },\n *     function iter(callback) {\n *         count++;\n *         setTimeout(function() {\n *             callback(null, count);\n *         }, 1000);\n *     },\n *     function (err, n) {\n *         // 5 seconds have passed, n = 5\n *     }\n * );\n */\nfunction whilst(test, iteratee, callback) {\n    callback = onlyOnce(callback);\n    var _fn = wrapAsync(iteratee);\n    var _test = wrapAsync(test);\n    var results = [];\n\n    function next(err, ...rest) {\n        if (err) return callback(err);\n        results = rest;\n        if (err === false) return;\n        _test(check);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (err === false) return;\n        if (!truth) return callback(null, ...results);\n        _fn(next);\n    }\n\n    return _test(check);\n}\nvar whilst$1 = awaitify(whilst, 3);\n\n/**\n * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs. `callback` will be passed an error and any\n * arguments passed to the final `iteratee`'s callback.\n *\n * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n *\n * @name until\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `iteratee`. Invoked with (callback).\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns {Promise} a promise, if a callback is not passed\n *\n * @example\n * const results = []\n * let finished = false\n * async.until(function test(cb) {\n *     cb(null, finished)\n * }, function iter(next) {\n *     fetchPage(url, (err, body) => {\n *         if (err) return next(err)\n *         results = results.concat(body.objects)\n *         finished = !!body.next\n *         next(err)\n *     })\n * }, function done (err) {\n *     // all pages have been fetched\n * })\n */\nfunction until(test, iteratee, callback) {\n    const _test = wrapAsync(test);\n    return whilst$1((cb) => _test((err, truth) => cb (err, !truth)), iteratee, callback);\n}\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nfunction waterfall (tasks, callback) {\n    callback = once(callback);\n    if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = wrapAsync(tasks[taskIndex++]);\n        task(...args, onlyOnce(next));\n    }\n\n    function next(err, ...args) {\n        if (err === false) return\n        if (err || taskIndex === tasks.length) {\n            return callback(err, ...args);\n        }\n        nextTask(args);\n    }\n\n    nextTask([]);\n}\n\nvar waterfall$1 = awaitify(waterfall);\n\n/**\n * An \"async function\" in the context of Async is an asynchronous function with\n * a variable number of parameters, with the final parameter being a callback.\n * (`function (arg1, arg2, ..., callback) {}`)\n * The final callback is of the form `callback(err, results...)`, which must be\n * called once the function is completed.  The callback should be called with a\n * Error as its first argument to signal that an error occurred.\n * Otherwise, if no error occurred, it should be called with `null` as the first\n * argument, and any additional `result` arguments that may apply, to signal\n * successful completion.\n * The callback must be called exactly once, ideally on a later tick of the\n * JavaScript event loop.\n *\n * This type of function is also referred to as a \"Node-style async function\",\n * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n * library are themselves CPS/Node-style async functions, or functions that\n * return CPS/Node-style async functions.\n *\n * Wherever we accept a Node-style async function, we also directly accept an\n * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n * In this case, the `async` function will not be passed a final callback\n * argument, and any thrown error will be used as the `err` argument of the\n * implicit callback, and the return value will be used as the `result` value.\n * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n * argument, and a `resolved` value becomes the `result`.)\n *\n * Note, due to JavaScript limitations, we can only detect native `async`\n * functions and not transpilied implementations.\n * Your environment must have `async`/`await` support for this to work.\n * (e.g. Node > v7.6, or a recent version of a modern browser).\n * If you are using `async` functions through a transpiler (e.g. Babel), you\n * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n * because the `async function` will be compiled to an ordinary function that\n * returns a promise.\n *\n * @typedef {Function} AsyncFunction\n * @static\n */\n\nvar index = {\n    apply,\n    applyEach: applyEach$1,\n    applyEachSeries,\n    asyncify,\n    auto,\n    autoInject,\n    cargo,\n    cargoQueue: cargo$1,\n    compose,\n    concat: concat$1,\n    concatLimit: concatLimit$1,\n    concatSeries: concatSeries$1,\n    constant,\n    detect: detect$1,\n    detectLimit: detectLimit$1,\n    detectSeries: detectSeries$1,\n    dir,\n    doUntil,\n    doWhilst: doWhilst$1,\n    each,\n    eachLimit: eachLimit$2,\n    eachOf: eachOf$1,\n    eachOfLimit: eachOfLimit$2,\n    eachOfSeries: eachOfSeries$1,\n    eachSeries: eachSeries$1,\n    ensureAsync,\n    every: every$1,\n    everyLimit: everyLimit$1,\n    everySeries: everySeries$1,\n    filter: filter$1,\n    filterLimit: filterLimit$1,\n    filterSeries: filterSeries$1,\n    forever: forever$1,\n    groupBy,\n    groupByLimit: groupByLimit$1,\n    groupBySeries,\n    log,\n    map: map$1,\n    mapLimit: mapLimit$1,\n    mapSeries: mapSeries$1,\n    mapValues,\n    mapValuesLimit: mapValuesLimit$1,\n    mapValuesSeries,\n    memoize,\n    nextTick,\n    parallel: parallel$1,\n    parallelLimit,\n    priorityQueue,\n    queue: queue$1,\n    race: race$1,\n    reduce: reduce$1,\n    reduceRight,\n    reflect,\n    reflectAll,\n    reject: reject$2,\n    rejectLimit: rejectLimit$1,\n    rejectSeries: rejectSeries$1,\n    retry,\n    retryable,\n    seq,\n    series,\n    setImmediate: setImmediate$1,\n    some: some$1,\n    someLimit: someLimit$1,\n    someSeries: someSeries$1,\n    sortBy: sortBy$1,\n    timeout,\n    times,\n    timesLimit,\n    timesSeries,\n    transform,\n    tryEach: tryEach$1,\n    unmemoize,\n    until,\n    waterfall: waterfall$1,\n    whilst: whilst$1,\n\n    // aliases\n    all: every$1,\n    allLimit: everyLimit$1,\n    allSeries: everySeries$1,\n    any: some$1,\n    anyLimit: someLimit$1,\n    anySeries: someSeries$1,\n    find: detect$1,\n    findLimit: detectLimit$1,\n    findSeries: detectSeries$1,\n    flatMap: concat$1,\n    flatMapLimit: concatLimit$1,\n    flatMapSeries: concatSeries$1,\n    forEach: each,\n    forEachSeries: eachSeries$1,\n    forEachLimit: eachLimit$2,\n    forEachOf: eachOf$1,\n    forEachOfSeries: eachOfSeries$1,\n    forEachOfLimit: eachOfLimit$2,\n    inject: reduce$1,\n    foldl: reduce$1,\n    foldr: reduceRight,\n    select: filter$1,\n    selectLimit: filterLimit$1,\n    selectSeries: filterSeries$1,\n    wrapSync: asyncify,\n    during: whilst$1,\n    doDuring: doWhilst$1\n};\n\nexport default index;\nexport { apply, applyEach$1 as applyEach, applyEachSeries, asyncify, auto, autoInject, cargo, cargo$1 as cargoQueue, compose, concat$1 as concat, concatLimit$1 as concatLimit, concatSeries$1 as concatSeries, constant, detect$1 as detect, detectLimit$1 as detectLimit, detectSeries$1 as detectSeries, dir, doUntil, doWhilst$1 as doWhilst, each, eachLimit$2 as eachLimit, eachOf$1 as eachOf, eachOfLimit$2 as eachOfLimit, eachOfSeries$1 as eachOfSeries, eachSeries$1 as eachSeries, ensureAsync, every$1 as every, everyLimit$1 as everyLimit, everySeries$1 as everySeries, filter$1 as filter, filterLimit$1 as filterLimit, filterSeries$1 as filterSeries, forever$1 as forever, groupBy, groupByLimit$1 as groupByLimit, groupBySeries, log, map$1 as map, mapLimit$1 as mapLimit, mapSeries$1 as mapSeries, mapValues, mapValuesLimit$1 as mapValuesLimit, mapValuesSeries, memoize, nextTick, parallel$1 as parallel, parallelLimit, priorityQueue, queue$1 as queue, race$1 as race, reduce$1 as reduce, reduceRight, reflect, reflectAll, reject$2 as reject, rejectLimit$1 as rejectLimit, rejectSeries$1 as rejectSeries, retry, retryable, seq, series, setImmediate$1 as setImmediate, some$1 as some, someLimit$1 as someLimit, someSeries$1 as someSeries, sortBy$1 as sortBy, timeout, times, timesLimit, timesSeries, transform, tryEach$1 as tryEach, unmemoize, until, waterfall$1 as waterfall, whilst$1 as whilst, every$1 as all, everyLimit$1 as allLimit, everySeries$1 as allSeries, some$1 as any, someLimit$1 as anyLimit, someSeries$1 as anySeries, detect$1 as find, detectLimit$1 as findLimit, detectSeries$1 as findSeries, concat$1 as flatMap, concatLimit$1 as flatMapLimit, concatSeries$1 as flatMapSeries, each as forEach, eachSeries$1 as forEachSeries, eachLimit$2 as forEachLimit, eachOf$1 as forEachOf, eachOfSeries$1 as forEachOfSeries, eachOfLimit$2 as forEachOfLimit, reduce$1 as inject, reduce$1 as foldl, reduceRight as foldr, filter$1 as select, filterLimit$1 as selectLimit, filterSeries$1 as selectSeries, asyncify as wrapSync, whilst$1 as during, doWhilst$1 as doDuring };\n","/*jshint node:true*/\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar async = require('async');\nvar utils = require('./utils');\n\n/*\n *! Capability helpers\n */\n\nvar avCodecRegexp = /^\\s*([D ])([E ])([VAS])([S ])([D ])([T ]) ([^ ]+) +(.*)$/;\nvar ffCodecRegexp = /^\\s*([D\\.])([E\\.])([VAS])([I\\.])([L\\.])([S\\.]) ([^ ]+) +(.*)$/;\nvar ffEncodersRegexp = /\\(encoders:([^\\)]+)\\)/;\nvar ffDecodersRegexp = /\\(decoders:([^\\)]+)\\)/;\nvar encodersRegexp = /^\\s*([VAS\\.])([F\\.])([S\\.])([X\\.])([B\\.])([D\\.]) ([^ ]+) +(.*)$/;\nvar formatRegexp = /^\\s*([D ])([E ]) ([^ ]+) +(.*)$/;\nvar lineBreakRegexp = /\\r\\n|\\r|\\n/;\nvar filterRegexp = /^(?: [T\\.][S\\.][C\\.] )?([^ ]+) +(AA?|VV?|\\|)->(AA?|VV?|\\|) +(.*)$/;\n\nvar cache = {};\n\nmodule.exports = function(proto) {\n  /**\n   * Manually define the ffmpeg binary full path.\n   *\n   * @method FfmpegCommand#setFfmpegPath\n   *\n   * @param {String} ffmpegPath The full path to the ffmpeg binary.\n   * @return FfmpegCommand\n   */\n  proto.setFfmpegPath = function(ffmpegPath) {\n    cache.ffmpegPath = ffmpegPath;\n    return this;\n  };\n\n  /**\n   * Manually define the ffprobe binary full path.\n   *\n   * @method FfmpegCommand#setFfprobePath\n   *\n   * @param {String} ffprobePath The full path to the ffprobe binary.\n   * @return FfmpegCommand\n   */\n  proto.setFfprobePath = function(ffprobePath) {\n    cache.ffprobePath = ffprobePath;\n    return this;\n  };\n\n  /**\n   * Manually define the flvtool2/flvmeta binary full path.\n   *\n   * @method FfmpegCommand#setFlvtoolPath\n   *\n   * @param {String} flvtool The full path to the flvtool2 or flvmeta binary.\n   * @return FfmpegCommand\n   */\n  proto.setFlvtoolPath = function(flvtool) {\n    cache.flvtoolPath = flvtool;\n    return this;\n  };\n\n  /**\n   * Forget executable paths\n   *\n   * (only used for testing purposes)\n   *\n   * @method FfmpegCommand#_forgetPaths\n   * @private\n   */\n  proto._forgetPaths = function() {\n    delete cache.ffmpegPath;\n    delete cache.ffprobePath;\n    delete cache.flvtoolPath;\n  };\n\n  /**\n   * Check for ffmpeg availability\n   *\n   * If the FFMPEG_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffmpeg in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFfmpegPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  proto._getFfmpegPath = function(callback) {\n    if ('ffmpegPath' in cache) {\n      return callback(null, cache.ffmpegPath);\n    }\n\n    async.waterfall([\n      // Try FFMPEG_PATH\n      function(cb) {\n        if (process.env.FFMPEG_PATH) {\n          fs.exists(process.env.FFMPEG_PATH, function(exists) {\n            if (exists) {\n              cb(null, process.env.FFMPEG_PATH);\n            } else {\n              cb(null, '');\n            }\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search in the PATH\n      function(ffmpeg, cb) {\n        if (ffmpeg.length) {\n          return cb(null, ffmpeg);\n        }\n\n        utils.which('ffmpeg', function(err, ffmpeg) {\n          cb(err, ffmpeg);\n        });\n      }\n    ], function(err, ffmpeg) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffmpegPath = (ffmpeg || ''));\n      }\n    });\n  };\n\n\n  /**\n   * Check for ffprobe availability\n   *\n   * If the FFPROBE_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffprobe in the PATH instead.\n   * If this still fails, try to find ffprobe in the same directory as ffmpeg.\n   *\n   * @method FfmpegCommand#_getFfprobePath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  proto._getFfprobePath = function(callback) {\n    var self = this;\n\n    if ('ffprobePath' in cache) {\n      return callback(null, cache.ffprobePath);\n    }\n\n    async.waterfall([\n      // Try FFPROBE_PATH\n      function(cb) {\n        if (process.env.FFPROBE_PATH) {\n          fs.exists(process.env.FFPROBE_PATH, function(exists) {\n            cb(null, exists ? process.env.FFPROBE_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search in the PATH\n      function(ffprobe, cb) {\n        if (ffprobe.length) {\n          return cb(null, ffprobe);\n        }\n\n        utils.which('ffprobe', function(err, ffprobe) {\n          cb(err, ffprobe);\n        });\n      },\n\n      // Search in the same directory as ffmpeg\n      function(ffprobe, cb) {\n        if (ffprobe.length) {\n          return cb(null, ffprobe);\n        }\n\n        self._getFfmpegPath(function(err, ffmpeg) {\n          if (err) {\n            cb(err);\n          } else if (ffmpeg.length) {\n            var name = utils.isWindows ? 'ffprobe.exe' : 'ffprobe';\n            var ffprobe = path.join(path.dirname(ffmpeg), name);\n            fs.exists(ffprobe, function(exists) {\n              cb(null, exists ? ffprobe : '');\n            });\n          } else {\n            cb(null, '');\n          }\n        });\n      }\n    ], function(err, ffprobe) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffprobePath = (ffprobe || ''));\n      }\n    });\n  };\n\n\n  /**\n   * Check for flvtool2/flvmeta availability\n   *\n   * If the FLVTOOL2_PATH or FLVMETA_PATH environment variable are set, try to use them.\n   * If both are either unset or incorrect, try to find flvtool2 or flvmeta in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFlvtoolPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n   proto._getFlvtoolPath = function(callback) {\n    if ('flvtoolPath' in cache) {\n      return callback(null, cache.flvtoolPath);\n    }\n\n    async.waterfall([\n      // Try FLVMETA_PATH\n      function(cb) {\n        if (process.env.FLVMETA_PATH) {\n          fs.exists(process.env.FLVMETA_PATH, function(exists) {\n            cb(null, exists ? process.env.FLVMETA_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Try FLVTOOL2_PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        if (process.env.FLVTOOL2_PATH) {\n          fs.exists(process.env.FLVTOOL2_PATH, function(exists) {\n            cb(null, exists ? process.env.FLVTOOL2_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search for flvmeta in the PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        utils.which('flvmeta', function(err, flvmeta) {\n          cb(err, flvmeta);\n        });\n      },\n\n      // Search for flvtool2 in the PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        utils.which('flvtool2', function(err, flvtool2) {\n          cb(err, flvtool2);\n        });\n      },\n    ], function(err, flvtool) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.flvtoolPath = (flvtool || ''));\n      }\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFilters}.\n   *\n   * @callback FfmpegCommand~filterCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} filters filter object with filter names as keys and the following\n   *   properties for each filter:\n   * @param {String} filters.description filter description\n   * @param {String} filters.input input type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleInputs whether the filter supports multiple inputs\n   * @param {String} filters.output output type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleOutputs whether the filter supports multiple outputs\n   */\n\n  /**\n   * Query ffmpeg for available filters\n   *\n   * @method FfmpegCommand#availableFilters\n   * @category Capabilities\n   * @aliases getAvailableFilters\n   *\n   * @param {FfmpegCommand~filterCallback} callback callback function\n   */\n  proto.availableFilters =\n  proto.getAvailableFilters = function(callback) {\n    if ('filters' in cache) {\n      return callback(null, cache.filters);\n    }\n\n    this._spawnFfmpeg(['-filters'], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split('\\n');\n      var data = {};\n      var types = { A: 'audio', V: 'video', '|': 'none' };\n\n      lines.forEach(function(line) {\n        var match = line.match(filterRegexp);\n        if (match) {\n          data[match[1]] = {\n            description: match[4],\n            input: types[match[2].charAt(0)],\n            multipleInputs: match[2].length > 1,\n            output: types[match[3].charAt(0)],\n            multipleOutputs: match[3].length > 1\n          };\n        }\n      });\n\n      callback(null, cache.filters = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableCodecs}.\n   *\n   * @callback FfmpegCommand~codecCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} codecs codec object with codec names as keys and the following\n   *   properties for each codec (more properties may be available depending on the\n   *   ffmpeg version used):\n   * @param {String} codecs.description codec description\n   * @param {Boolean} codecs.canDecode whether the codec is able to decode streams\n   * @param {Boolean} codecs.canEncode whether the codec is able to encode streams\n   */\n\n  /**\n   * Query ffmpeg for available codecs\n   *\n   * @method FfmpegCommand#availableCodecs\n   * @category Capabilities\n   * @aliases getAvailableCodecs\n   *\n   * @param {FfmpegCommand~codecCallback} callback callback function\n   */\n  proto.availableCodecs =\n  proto.getAvailableCodecs = function(callback) {\n    if ('codecs' in cache) {\n      return callback(null, cache.codecs);\n    }\n\n    this._spawnFfmpeg(['-codecs'], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(avCodecRegexp);\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            drawHorizBand: match[4] === 'S',\n            directRendering: match[5] === 'D',\n            weirdFrameTruncation: match[6] === 'T'\n          };\n        }\n\n        match = line.match(ffCodecRegexp);\n        if (match && match[7] !== '=') {\n          var codecData = data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            intraFrameOnly: match[4] === 'I',\n            isLossy: match[5] === 'L',\n            isLossless: match[6] === 'S'\n          };\n\n          var encoders = codecData.description.match(ffEncodersRegexp);\n          encoders = encoders ? encoders[1].trim().split(' ') : [];\n\n          var decoders = codecData.description.match(ffDecodersRegexp);\n          decoders = decoders ? decoders[1].trim().split(' ') : [];\n\n          if (encoders.length || decoders.length) {\n            var coderData = {};\n            utils.copy(codecData, coderData);\n            delete coderData.canEncode;\n            delete coderData.canDecode;\n\n            encoders.forEach(function(name) {\n              data[name] = {};\n              utils.copy(coderData, data[name]);\n              data[name].canEncode = true;\n            });\n\n            decoders.forEach(function(name) {\n              if (name in data) {\n                data[name].canDecode = true;\n              } else {\n                data[name] = {};\n                utils.copy(coderData, data[name]);\n                data[name].canDecode = true;\n              }\n            });\n          }\n        }\n      });\n\n      callback(null, cache.codecs = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableEncoders}.\n   *\n   * @callback FfmpegCommand~encodersCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} encoders encoders object with encoder names as keys and the following\n   *   properties for each encoder:\n   * @param {String} encoders.description codec description\n   * @param {Boolean} encoders.type \"audio\", \"video\" or \"subtitle\"\n   * @param {Boolean} encoders.frameMT whether the encoder is able to do frame-level multithreading\n   * @param {Boolean} encoders.sliceMT whether the encoder is able to do slice-level multithreading\n   * @param {Boolean} encoders.experimental whether the encoder is experimental\n   * @param {Boolean} encoders.drawHorizBand whether the encoder supports draw_horiz_band\n   * @param {Boolean} encoders.directRendering whether the encoder supports direct encoding method 1\n   */\n\n  /**\n   * Query ffmpeg for available encoders\n   *\n   * @method FfmpegCommand#availableEncoders\n   * @category Capabilities\n   * @aliases getAvailableEncoders\n   *\n   * @param {FfmpegCommand~encodersCallback} callback callback function\n   */\n  proto.availableEncoders =\n  proto.getAvailableEncoders = function(callback) {\n    if ('encoders' in cache) {\n      return callback(null, cache.encoders);\n    }\n\n    this._spawnFfmpeg(['-encoders'], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(encodersRegexp);\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[1]],\n            description: match[8],\n            frameMT: match[2] === 'F',\n            sliceMT: match[3] === 'S',\n            experimental: match[4] === 'X',\n            drawHorizBand: match[5] === 'B',\n            directRendering: match[6] === 'D'\n          };\n        }\n      });\n\n      callback(null, cache.encoders = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFormats}.\n   *\n   * @callback FfmpegCommand~formatCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} formats format object with format names as keys and the following\n   *   properties for each format:\n   * @param {String} formats.description format description\n   * @param {Boolean} formats.canDemux whether the format is able to demux streams from an input file\n   * @param {Boolean} formats.canMux whether the format is able to mux streams into an output file\n   */\n\n  /**\n   * Query ffmpeg for available formats\n   *\n   * @method FfmpegCommand#availableFormats\n   * @category Capabilities\n   * @aliases getAvailableFormats\n   *\n   * @param {FfmpegCommand~formatCallback} callback callback function\n   */\n  proto.availableFormats =\n  proto.getAvailableFormats = function(callback) {\n    if ('formats' in cache) {\n      return callback(null, cache.formats);\n    }\n\n    // Run ffmpeg -formats\n    this._spawnFfmpeg(['-formats'], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      // Parse output\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(formatRegexp);\n        if (match) {\n          match[3].split(',').forEach(function(format) {\n            if (!(format in data)) {\n              data[format] = {\n                description: match[4],\n                canDemux: false,\n                canMux: false\n              };\n            }\n\n            if (match[1] === 'D') {\n              data[format].canDemux = true;\n            }\n            if (match[2] === 'E') {\n              data[format].canMux = true;\n            }\n          });\n        }\n      });\n\n      callback(null, cache.formats = data);\n    });\n  };\n\n\n  /**\n   * Check capabilities before executing a command\n   *\n   * Checks whether all used codecs and formats are indeed available\n   *\n   * @method FfmpegCommand#_checkCapabilities\n   * @param {Function} callback callback with signature (err)\n   * @private\n   */\n  proto._checkCapabilities = function(callback) {\n    var self = this;\n    async.waterfall([\n      // Get available formats\n      function(cb) {\n        self.availableFormats(cb);\n      },\n\n      // Check whether specified formats are available\n      function(formats, cb) {\n        var unavailable;\n\n        // Output format(s)\n        unavailable = self._outputs\n          .reduce(function(fmts, output) {\n            var format = output.options.find('-f', 1);\n            if (format) {\n              if (!(format[0] in formats) || !(formats[format[0]].canMux)) {\n                fmts.push(format);\n              }\n            }\n\n            return fmts;\n          }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Output format ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Output formats ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        // Input format(s)\n        unavailable = self._inputs\n          .reduce(function(fmts, input) {\n            var format = input.options.find('-f', 1);\n            if (format) {\n              if (!(format[0] in formats) || !(formats[format[0]].canDemux)) {\n                fmts.push(format[0]);\n              }\n            }\n\n            return fmts;\n          }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Input format ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Input formats ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        cb();\n      },\n\n      // Get available codecs\n      function(cb) {\n        self.availableEncoders(cb);\n      },\n\n      // Check whether specified codecs are available and add strict experimental options if needed\n      function(encoders, cb) {\n        var unavailable;\n\n        // Audio codec(s)\n        unavailable = self._outputs.reduce(function(cdcs, output) {\n          var acodec = output.audio.find('-acodec', 1);\n          if (acodec && acodec[0] !== 'copy') {\n            if (!(acodec[0] in encoders) || encoders[acodec[0]].type !== 'audio') {\n              cdcs.push(acodec[0]);\n            }\n          }\n\n          return cdcs;\n        }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Audio codec ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Audio codecs ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        // Video codec(s)\n        unavailable = self._outputs.reduce(function(cdcs, output) {\n          var vcodec = output.video.find('-vcodec', 1);\n          if (vcodec && vcodec[0] !== 'copy') {\n            if (!(vcodec[0] in encoders) || encoders[vcodec[0]].type !== 'video') {\n              cdcs.push(vcodec[0]);\n            }\n          }\n\n          return cdcs;\n        }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Video codec ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Video codecs ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        cb();\n      }\n    ], callback);\n  };\n};\n","/*jshint node:true, laxcomma:true*/\n'use strict';\n\nvar spawn = require('child_process').spawn;\n\n\nfunction legacyTag(key) { return key.match(/^TAG:/); }\nfunction legacyDisposition(key) { return key.match(/^DISPOSITION:/); }\n\nfunction parseFfprobeOutput(out) {\n  var lines = out.split(/\\r\\n|\\r|\\n/);\n\n  lines = lines.filter(function (line) {\n    return line.length > 0;\n  });\n\n  var data = {\n    streams: [],\n    format: {},\n    chapters: []\n  };\n\n  function parseBlock(name) {\n    var data = {};\n\n    var line = lines.shift();\n    while (typeof line !== 'undefined') {\n      if (line.toLowerCase() == '[/'+name+']') {\n        return data;\n      } else if (line.match(/^\\[/)) {\n        line = lines.shift();\n        continue;\n      }\n\n      var kv = line.match(/^([^=]+)=(.*)$/);\n      if (kv) {\n        if (!(kv[1].match(/^TAG:/)) && kv[2].match(/^[0-9]+(\\.[0-9]+)?$/)) {\n          data[kv[1]] = Number(kv[2]);\n        } else {\n          data[kv[1]] = kv[2];\n        }\n      }\n\n      line = lines.shift();\n    }\n\n    return data;\n  }\n\n  var line = lines.shift();\n  while (typeof line !== 'undefined') {\n    if (line.match(/^\\[stream/i)) {\n      var stream = parseBlock('stream');\n      data.streams.push(stream);\n    } else if (line.match(/^\\[chapter/i)) {\n      var chapter = parseBlock('chapter');\n      data.chapters.push(chapter);\n    } else if (line.toLowerCase() === '[format]') {\n      data.format = parseBlock('format');\n    }\n\n    line = lines.shift();\n  }\n\n  return data;\n}\n\n\n\nmodule.exports = function(proto) {\n  /**\n   * A callback passed to the {@link FfmpegCommand#ffprobe} method.\n   *\n   * @callback FfmpegCommand~ffprobeCallback\n   *\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} ffprobeData ffprobe output data; this object\n   *   has the same format as what the following command returns:\n   *\n   *     `ffprobe -print_format json -show_streams -show_format INPUTFILE`\n   * @param {Array} ffprobeData.streams stream information\n   * @param {Object} ffprobeData.format format information\n   */\n\n  /**\n   * Run ffprobe on last specified input\n   *\n   * @method FfmpegCommand#ffprobe\n   * @category Metadata\n   *\n   * @param {?Number} [index] 0-based index of input to probe (defaults to last input)\n   * @param {?String[]} [options] array of output options to return\n   * @param {FfmpegCommand~ffprobeCallback} callback callback function\n   *\n   */\n  proto.ffprobe = function() {\n    var input, index = null, options = [], callback;\n\n    // the last argument should be the callback\n    var callback = arguments[arguments.length - 1];\n\n    var ended = false\n    function handleCallback(err, data) {\n      if (!ended) {\n        ended = true;\n        callback(err, data);\n      }\n    };\n\n    // map the arguments to the correct variable names\n    switch (arguments.length) {\n      case 3:\n        index = arguments[0];\n        options = arguments[1];\n        break;\n      case 2:\n        if (typeof arguments[0] === 'number') {\n          index = arguments[0];\n        } else if (Array.isArray(arguments[0])) {\n          options = arguments[0];\n        }\n        break;\n    }\n\n\n    if (index === null) {\n      if (!this._currentInput) {\n        return handleCallback(new Error('No input specified'));\n      }\n\n      input = this._currentInput;\n    } else {\n      input = this._inputs[index];\n\n      if (!input) {\n        return handleCallback(new Error('Invalid input index'));\n      }\n    }\n\n    // Find ffprobe\n    this._getFfprobePath(function(err, path) {\n      if (err) {\n        return handleCallback(err);\n      } else if (!path) {\n        return handleCallback(new Error('Cannot find ffprobe'));\n      }\n\n      var stdout = '';\n      var stdoutClosed = false;\n      var stderr = '';\n      var stderrClosed = false;\n\n      // Spawn ffprobe\n      var src = input.isStream ? 'pipe:0' : input.source;\n      var ffprobe = spawn(path, ['-show_streams', '-show_format'].concat(options, src));\n\n      if (input.isStream) {\n        // Skip errors on stdin. These get thrown when ffprobe is complete and\n        // there seems to be no way hook in and close stdin before it throws.\n        ffprobe.stdin.on('error', function(err) {\n          if (['ECONNRESET', 'EPIPE'].indexOf(err.code) >= 0) { return; }\n          handleCallback(err);\n        });\n\n        // Once ffprobe's input stream closes, we need no more data from the\n        // input\n        ffprobe.stdin.on('close', function() {\n            input.source.pause();\n            input.source.unpipe(ffprobe.stdin);\n        });\n\n        input.source.pipe(ffprobe.stdin);\n      }\n\n      ffprobe.on('error', callback);\n\n      // Ensure we wait for captured streams to end before calling callback\n      var exitError = null;\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n\n        if (processExited && stdoutClosed && stderrClosed) {\n          if (exitError) {\n            if (stderr) {\n              exitError.message += '\\n' + stderr;\n            }\n\n            return handleCallback(exitError);\n          }\n\n          // Process output\n          var data = parseFfprobeOutput(stdout);\n\n          // Handle legacy output with \"TAG:x\" and \"DISPOSITION:x\" keys\n          [data.format].concat(data.streams).forEach(function(target) {\n            if (target) {\n              var legacyTagKeys = Object.keys(target).filter(legacyTag);\n\n              if (legacyTagKeys.length) {\n                target.tags = target.tags || {};\n\n                legacyTagKeys.forEach(function(tagKey) {\n                  target.tags[tagKey.substr(4)] = target[tagKey];\n                  delete target[tagKey];\n                });\n              }\n\n              var legacyDispositionKeys = Object.keys(target).filter(legacyDisposition);\n\n              if (legacyDispositionKeys.length) {\n                target.disposition = target.disposition || {};\n\n                legacyDispositionKeys.forEach(function(dispositionKey) {\n                  target.disposition[dispositionKey.substr(12)] = target[dispositionKey];\n                  delete target[dispositionKey];\n                });\n              }\n            }\n          });\n\n          handleCallback(null, data);\n        }\n      }\n\n      // Handle ffprobe exit\n      var processExited = false;\n      ffprobe.on('exit', function(code, signal) {\n        processExited = true;\n\n        if (code) {\n          handleExit(new Error('ffprobe exited with code ' + code));\n        } else if (signal) {\n          handleExit(new Error('ffprobe was killed with signal ' + signal));\n        } else {\n          handleExit();\n        }\n      });\n\n      // Handle stdout/stderr streams\n      ffprobe.stdout.on('data', function(data) {\n        stdout += data;\n      });\n\n      ffprobe.stdout.on('close', function() {\n        stdoutClosed = true;\n        handleExit();\n      });\n\n      ffprobe.stderr.on('data', function(data) {\n        stderr += data;\n      });\n\n      ffprobe.stderr.on('close', function() {\n        stderrClosed = true;\n        handleExit();\n      });\n    });\n  };\n};\n","/*jshint node:true*/\n'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar PassThrough = require('stream').PassThrough;\nvar async = require('async');\nvar utils = require('./utils');\n\n\n/*\n * Useful recipes for commands\n */\n\nmodule.exports = function recipes(proto) {\n  /**\n   * Execute ffmpeg command and save output to a file\n   *\n   * @method FfmpegCommand#save\n   * @category Processing\n   * @aliases saveToFile\n   *\n   * @param {String} output file path\n   * @return FfmpegCommand\n   */\n  proto.saveToFile =\n  proto.save = function(output) {\n    this.output(output).run();\n    return this;\n  };\n\n\n  /**\n   * Execute ffmpeg command and save output to a stream\n   *\n   * If 'stream' is not specified, a PassThrough stream is created and returned.\n   * 'options' will be used when piping ffmpeg output to the output stream\n   * (@see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options)\n   *\n   * @method FfmpegCommand#pipe\n   * @category Processing\n   * @aliases stream,writeToStream\n   *\n   * @param {stream.Writable} [stream] output stream\n   * @param {Object} [options={}] pipe options\n   * @return Output stream\n   */\n  proto.writeToStream =\n  proto.pipe =\n  proto.stream = function(stream, options) {\n    if (stream && !('writable' in stream)) {\n      options = stream;\n      stream = undefined;\n    }\n\n    if (!stream) {\n      if (process.version.match(/v0\\.8\\./)) {\n        throw new Error('PassThrough stream is not supported on node v0.8');\n      }\n\n      stream = new PassThrough();\n    }\n\n    this.output(stream, options).run();\n    return stream;\n  };\n\n\n  /**\n   * Generate images from a video\n   *\n   * Note: this method makes the command emit a 'filenames' event with an array of\n   * the generated image filenames.\n   *\n   * @method FfmpegCommand#screenshots\n   * @category Processing\n   * @aliases takeScreenshots,thumbnail,thumbnails,screenshot\n   *\n   * @param {Number|Object} [config=1] screenshot count or configuration object with\n   *   the following keys:\n   * @param {Number} [config.count] number of screenshots to take; using this option\n   *   takes screenshots at regular intervals (eg. count=4 would take screens at 20%, 40%,\n   *   60% and 80% of the video length).\n   * @param {String} [config.folder='.'] output folder\n   * @param {String} [config.filename='tn.png'] output filename pattern, may contain the following\n   *   tokens:\n   *   - '%s': offset in seconds\n   *   - '%w': screenshot width\n   *   - '%h': screenshot height\n   *   - '%r': screenshot resolution (same as '%wx%h')\n   *   - '%f': input filename\n   *   - '%b': input basename (filename w/o extension)\n   *   - '%i': index of screenshot in timemark array (can be zero-padded by using it like `%000i`)\n   * @param {Number[]|String[]} [config.timemarks] array of timemarks to take screenshots\n   *   at; each timemark may be a number of seconds, a '[[hh:]mm:]ss[.xxx]' string or a\n   *   'XX%' string.  Overrides 'count' if present.\n   * @param {Number[]|String[]} [config.timestamps] alias for 'timemarks'\n   * @param {Boolean} [config.fastSeek] use fast seek (less accurate)\n   * @param {String} [config.size] screenshot size, with the same syntax as {@link FfmpegCommand#size}\n   * @param {String} [folder] output folder (legacy alias for 'config.folder')\n   * @return FfmpegCommand\n   */\n  proto.takeScreenshots =\n  proto.thumbnail =\n  proto.thumbnails =\n  proto.screenshot =\n  proto.screenshots = function(config, folder) {\n    var self = this;\n    var source = this._currentInput.source;\n    config = config || { count: 1 };\n\n    // Accept a number of screenshots instead of a config object\n    if (typeof config === 'number') {\n      config = {\n        count: config\n      };\n    }\n\n    // Accept a second 'folder' parameter instead of config.folder\n    if (!('folder' in config)) {\n      config.folder = folder || '.';\n    }\n\n    // Accept 'timestamps' instead of 'timemarks'\n    if ('timestamps' in config) {\n      config.timemarks = config.timestamps;\n    }\n\n    // Compute timemarks from count if not present\n    if (!('timemarks' in config)) {\n      if (!config.count) {\n        throw new Error('Cannot take screenshots: neither a count nor a timemark list are specified');\n      }\n\n      var interval = 100 / (1 + config.count);\n      config.timemarks = [];\n      for (var i = 0; i < config.count; i++) {\n        config.timemarks.push((interval * (i + 1)) + '%');\n      }\n    }\n\n    // Parse size option\n    if ('size' in config) {\n      var fixedSize = config.size.match(/^(\\d+)x(\\d+)$/);\n      var fixedWidth = config.size.match(/^(\\d+)x\\?$/);\n      var fixedHeight = config.size.match(/^\\?x(\\d+)$/);\n      var percentSize = config.size.match(/^(\\d+)%$/);\n\n      if (!fixedSize && !fixedWidth && !fixedHeight && !percentSize) {\n        throw new Error('Invalid size parameter: ' + config.size);\n      }\n    }\n\n    // Metadata helper\n    var metadata;\n    function getMetadata(cb) {\n      if (metadata) {\n        cb(null, metadata);\n      } else {\n        self.ffprobe(function(err, meta) {\n          metadata = meta;\n          cb(err, meta);\n        });\n      }\n    }\n\n    async.waterfall([\n      // Compute percent timemarks if any\n      function computeTimemarks(next) {\n        if (config.timemarks.some(function(t) { return ('' + t).match(/^[\\d.]+%$/); })) {\n          if (typeof source !== 'string') {\n            return next(new Error('Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks'));\n          }\n\n          getMetadata(function(err, meta) {\n            if (err) {\n              next(err);\n            } else {\n              // Select video stream with the highest resolution\n              var vstream = meta.streams.reduce(function(biggest, stream) {\n                if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n                  return stream;\n                } else {\n                  return biggest;\n                }\n              }, { width: 0, height: 0 });\n\n              if (vstream.width === 0) {\n                return next(new Error('No video stream in input, cannot take screenshots'));\n              }\n\n              var duration = Number(vstream.duration);\n              if (isNaN(duration)) {\n                duration = Number(meta.format.duration);\n              }\n\n              if (isNaN(duration)) {\n                return next(new Error('Could not get input duration, please specify fixed timemarks'));\n              }\n\n              config.timemarks = config.timemarks.map(function(mark) {\n                if (('' + mark).match(/^([\\d.]+)%$/)) {\n                  return duration * parseFloat(mark) / 100;\n                } else {\n                  return mark;\n                }\n              });\n\n              next();\n            }\n          });\n        } else {\n          next();\n        }\n      },\n\n      // Turn all timemarks into numbers and sort them\n      function normalizeTimemarks(next) {\n        config.timemarks = config.timemarks.map(function(mark) {\n          return utils.timemarkToSeconds(mark);\n        }).sort(function(a, b) { return a - b; });\n\n        next();\n      },\n\n      // Add '_%i' to pattern when requesting multiple screenshots and no variable token is present\n      function fixPattern(next) {\n        var pattern = config.filename || 'tn.png';\n\n        if (pattern.indexOf('.') === -1) {\n          pattern += '.png';\n        }\n\n        if (config.timemarks.length > 1 && !pattern.match(/%(s|0*i)/)) {\n          var ext = path.extname(pattern);\n          pattern = path.join(path.dirname(pattern), path.basename(pattern, ext) + '_%i' + ext);\n        }\n\n        next(null, pattern);\n      },\n\n      // Replace filename tokens (%f, %b) in pattern\n      function replaceFilenameTokens(pattern, next) {\n        if (pattern.match(/%[bf]/)) {\n          if (typeof source !== 'string') {\n            return next(new Error('Cannot replace %f or %b when using an input stream'));\n          }\n\n          pattern = pattern\n            .replace(/%f/g, path.basename(source))\n            .replace(/%b/g, path.basename(source, path.extname(source)));\n        }\n\n        next(null, pattern);\n      },\n\n      // Compute size if needed\n      function getSize(pattern, next) {\n        if (pattern.match(/%[whr]/)) {\n          if (fixedSize) {\n            return next(null, pattern, fixedSize[1], fixedSize[2]);\n          }\n\n          getMetadata(function(err, meta) {\n            if (err) {\n              return next(new Error('Could not determine video resolution to replace %w, %h or %r'));\n            }\n\n            var vstream = meta.streams.reduce(function(biggest, stream) {\n              if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n                return stream;\n              } else {\n                return biggest;\n              }\n            }, { width: 0, height: 0 });\n\n            if (vstream.width === 0) {\n              return next(new Error('No video stream in input, cannot replace %w, %h or %r'));\n            }\n\n            var width = vstream.width;\n            var height = vstream.height;\n\n            if (fixedWidth) {\n              height = height * Number(fixedWidth[1]) / width;\n              width = Number(fixedWidth[1]);\n            } else if (fixedHeight) {\n              width = width * Number(fixedHeight[1]) / height;\n              height = Number(fixedHeight[1]);\n            } else if (percentSize) {\n              width = width * Number(percentSize[1]) / 100;\n              height = height * Number(percentSize[1]) / 100;\n            }\n\n            next(null, pattern, Math.round(width / 2) * 2, Math.round(height / 2) * 2);\n          });\n        } else {\n          next(null, pattern, -1, -1);\n        }\n      },\n\n      // Replace size tokens (%w, %h, %r) in pattern\n      function replaceSizeTokens(pattern, width, height, next) {\n        pattern = pattern\n          .replace(/%r/g, '%wx%h')\n          .replace(/%w/g, width)\n          .replace(/%h/g, height);\n\n        next(null, pattern);\n      },\n\n      // Replace variable tokens in pattern (%s, %i) and generate filename list\n      function replaceVariableTokens(pattern, next) {\n        var filenames = config.timemarks.map(function(t, i) {\n          return pattern\n            .replace(/%s/g, utils.timemarkToSeconds(t))\n            .replace(/%(0*)i/g, function(match, padding) {\n              var idx = '' + (i + 1);\n              return padding.substr(0, Math.max(0, padding.length + 1 - idx.length)) + idx;\n            });\n        });\n\n        self.emit('filenames', filenames);\n        next(null, filenames);\n      },\n\n      // Create output directory\n      function createDirectory(filenames, next) {\n        fs.exists(config.folder, function(exists) {\n          if (!exists) {\n            fs.mkdir(config.folder, function(err) {\n              if (err) {\n                next(err);\n              } else {\n                next(null, filenames);\n              }\n            });\n          } else {\n            next(null, filenames);\n          }\n        });\n      }\n    ], function runCommand(err, filenames) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      var count = config.timemarks.length;\n      var split;\n      var filters = [split = {\n        filter: 'split',\n        options: count,\n        outputs: []\n      }];\n\n      if ('size' in config) {\n        // Set size to generate size filters\n        self.size(config.size);\n\n        // Get size filters and chain them with 'sizeN' stream names\n        var sizeFilters =  self._currentOutput.sizeFilters.get().map(function(f, i) {\n          if (i > 0) {\n            f.inputs = 'size' + (i - 1);\n          }\n\n          f.outputs = 'size' + i;\n\n          return f;\n        });\n\n        // Input last size filter output into split filter\n        split.inputs = 'size' + (sizeFilters.length - 1);\n\n        // Add size filters in front of split filter\n        filters = sizeFilters.concat(filters);\n\n        // Remove size filters\n        self._currentOutput.sizeFilters.clear();\n      }\n\n      var first = 0;\n      for (var i = 0; i < count; i++) {\n        var stream = 'screen' + i;\n        split.outputs.push(stream);\n\n        if (i === 0) {\n          first = config.timemarks[i];\n          self.seekInput(first);\n        }\n\n        self.output(path.join(config.folder, filenames[i]))\n          .frames(1)\n          .map(stream);\n\n        if (i > 0) {\n          self.seek(config.timemarks[i] - first);\n        }\n      }\n\n      self.complexFilter(filters);\n      self.run();\n    });\n\n    return this;\n  };\n\n\n  /**\n   * Merge (concatenate) inputs to a single file\n   *\n   * @method FfmpegCommand#concat\n   * @category Processing\n   * @aliases concatenate,mergeToFile\n   *\n   * @param {String|Writable} target output file or writable stream\n   * @param {Object} [options] pipe options (only used when outputting to a writable stream)\n   * @return FfmpegCommand\n   */\n  proto.mergeToFile =\n  proto.concatenate =\n  proto.concat = function(target, options) {\n    // Find out which streams are present in the first non-stream input\n    var fileInput = this._inputs.filter(function(input) {\n      return !input.isStream;\n    })[0];\n\n    var self = this;\n    this.ffprobe(this._inputs.indexOf(fileInput), function(err, data) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      var hasAudioStreams = data.streams.some(function(stream) {\n        return stream.codec_type === 'audio';\n      });\n\n      var hasVideoStreams = data.streams.some(function(stream) {\n        return stream.codec_type === 'video';\n      });\n\n      // Setup concat filter and start processing\n      self.output(target, options)\n        .complexFilter({\n          filter: 'concat',\n          options: {\n            n: self._inputs.length,\n            v: hasVideoStreams ? 1 : 0,\n            a: hasAudioStreams ? 1 : 0\n          }\n        })\n        .run();\n    });\n\n    return this;\n  };\n};\n","const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parser src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = _resolveHome(options.path)\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n  }\n\n  try {\n    // Specifying an encoding returns a string instead of a buffer\n    const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }))\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else {\n        if (override === true) {\n          process.env[key] = parsed[key]\n        }\n\n        if (debug) {\n          if (override === true) {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and WAS overwritten`)\n          } else {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and was NOT overwritten`)\n          }\n        }\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    if (debug) {\n      _log(`Failed to load ${dotenvPath} ${e.message}`)\n    }\n\n    return { error: e }\n  }\n}\n\nconst DotenvModule = {\n  config,\n  parse\n}\n\nmodule.exports.config = DotenvModule.config\nmodule.exports.parse = DotenvModule.parse\nmodule.exports = DotenvModule\n","{\n  \"name\": \"dotenv\",\n  \"version\": \"16.0.3\",\n  \"description\": \"Loads environment variables from .env file\",\n  \"main\": \"lib/main.js\",\n  \"types\": \"lib/main.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"require\": \"./lib/main.js\",\n      \"types\": \"./lib/main.d.ts\",\n      \"default\": \"./lib/main.js\"\n    },\n    \"./config\": \"./config.js\",\n    \"./config.js\": \"./config.js\",\n    \"./lib/env-options\": \"./lib/env-options.js\",\n    \"./lib/env-options.js\": \"./lib/env-options.js\",\n    \"./lib/cli-options\": \"./lib/cli-options.js\",\n    \"./lib/cli-options.js\": \"./lib/cli-options.js\",\n    \"./package.json\": \"./package.json\"\n  },\n  \"scripts\": {\n    \"dts-check\": \"tsc --project tests/types/tsconfig.json\",\n    \"lint\": \"standard\",\n    \"lint-readme\": \"standard-markdown\",\n    \"pretest\": \"npm run lint && npm run dts-check\",\n    \"test\": \"tap tests/*.js --100 -Rspec\",\n    \"prerelease\": \"npm test\",\n    \"release\": \"standard-version\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/motdotla/dotenv.git\"\n  },\n  \"keywords\": [\n    \"dotenv\",\n    \"env\",\n    \".env\",\n    \"environment\",\n    \"variables\",\n    \"config\",\n    \"settings\"\n  ],\n  \"readmeFilename\": \"README.md\",\n  \"license\": \"BSD-2-Clause\",\n  \"devDependencies\": {\n    \"@types/node\": \"^17.0.9\",\n    \"decache\": \"^4.6.1\",\n    \"dtslint\": \"^3.7.0\",\n    \"sinon\": \"^12.0.1\",\n    \"standard\": \"^16.0.4\",\n    \"standard-markdown\": \"^7.1.0\",\n    \"standard-version\": \"^9.3.2\",\n    \"tap\": \"^15.1.6\",\n    \"tar\": \"^6.1.11\",\n    \"typescript\": \"^4.5.4\"\n  },\n  \"engines\": {\n    \"node\": \">=12\"\n  }\n}\n","const fs = require(\"fs\");\nconst util = require(\"util\");\nconst exec = util.promisify(require(\"child_process\").exec);\nconst path = require(\"path\");\nconst ytdl = require(\"ytdl-core\");\nconst http = require(\"https\");\nconst ffmpeg = require(\"fluent-ffmpeg\");\nconst FFMPEG_PATH = `/opt/homebrew/Cellar/ffmpeg/5.1.2/bin/ffmpeg`;\nffmpeg.setFfmpegPath(FFMPEG_PATH);\nrequire(\"dotenv\").config();\nconst ffmpegOnProgress = require(\"ffmpeg-on-progress\");\nconst Max = require(\"max-api\");\n\nconst logProgress = (progress, event) => {\n  // progress is a floating point number from 0 to 1\n  Max.outlet([\"videoProgress\", progress * 100]);\n};\n\n// exec(\"where ffmpeg\", {\n//   shell: \"/bin/zsh\",\n// }).then((result) => {\n//   Max.post(result.stdout);\n// });\n\nlet savedVideos = { videos: [] };\n// require(\"./data/videos2.json\")\n// \t.then((data) => (savedVideos = data))\n// \t.catch(() => {\n// \t\tfs.writeFileSync(\"./data/videos2.json\", JSON.stringify({ videos: [] }));\n// \t\tsavedVideos = { videos: [] };\n// \t});\nMax.post(process.env.YTB_API_KEY);\n\nMax.outlet(\"ytbApiKeySet\", !!process.env.YTB_API_KEY);\n\nMax.outlet([\"savedVideos\", savedVideos.videos.sort()]);\n\nasync function updateYTDLCORE() {\n  try {\n    await exec(\"npm install --save ytdl-core@latest\");\n  } catch (err) {\n    Max.post(err);\n  }\n}\n\nconst searchYTBapi = async (term) =>\n  new Promise((resolve, reject) => {\n    const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=10&q=${term}&key=${process.env.YTB_API_KEY}}`;\n    http\n      .get(url, (res) => {\n        let data = [];\n        res.on(\"data\", (chunk) => {\n          data.push(chunk);\n        });\n\n        res.on(\"end\", () => {\n          const result = JSON.parse(Buffer.concat(data).toString());\n          if (result.items) {\n            resolve(result.items.map((item) => item.snippet));\n          } else {\n            Max.post(result);\n          }\n        });\n      })\n      .on(\"error\", (err) => {\n        Max.post(\"Error: \" + err.message);\n        reject(err);\n      });\n  });\n\nupdateYTDLCORE();\n\nlet currentResults = [];\nlet currentSelected;\n\nconst updateVideosJSON = (videosJSON) => {\n  let data = JSON.stringify(videosJSON, null, \"\\t\");\n  fs.writeFileSync(path.resolve(\"./videos.json\"), data);\n};\n\nconst getResults = async (term) => {\n  if (/^https:\\/\\/www\\.youtube\\.com\\/watch\\?v=/.test(term)) {\n    downloadResult(term);\n  } else {\n    if (!process.env.YTB_API_KEY) return;\n    const results = await searchYTBapi(term);\n    currentResults = results;\n    const thumbnailsDir = \"./media/thumbnails\";\n    if (!fs.existsSync(thumbnailsDir)) {\n      fs.mkdirSync(thumbnailsDir);\n    }\n    fs.readdir(thumbnailsDir, (err, files) => {\n      if (err) throw err;\n      for (const file of files) {\n        fs.unlink(path.join(thumbnailsDir, file), (err) => {\n          if (err) throw err;\n        });\n      }\n    });\n    results.forEach((result, index) => {\n      try {\n        download(\n          result.thumbnails.default.url,\n          \"./media/thumbnails/\" +\n            index +\n            result.title.replace(/(\\s+|\\:|\\/)/gi, \"_\").toLowerCase() +\n            \".jpg\",\n          () => {}\n        );\n      } catch (error) {\n        Max.outlet(\"error\", error.toString());\n      }\n    });\n  }\n};\n\nconst download = (url, dest, cb) => {\n  const file = fs.createWriteStream(dest);\n  http.get(url, function (response) {\n    response.pipe(file);\n    file.on(\"finish\", function () {\n      file.end(cb);\n      Max.outlet([\"newResults\", \"bang\"]);\n    });\n  });\n};\n\nconst convertVideo = (videoPath) => {\n  try {\n    Max.post(videoPath);\n    const vidId = videoPath.split(\"/\").reverse()[0].split(\".\")[0];\n    const videoStream = new ffmpeg(videoPath)\n      .withVideoCodec(\"hap\")\n      .outputOptions(\"-format hap_q\");\n    const audioStream = videoStream.clone();\n\n    let mp3Path = `./media/${vidId}.mp3`;\n    let movPath = `./media/${vidId}.mov`;\n\n    // videoStream.on(\"progress\", ffmpegOnProgress(logProgress, duration * 1000));\n\n    videoStream.save(path.resolve(movPath));\n\n    audioStream.on(\"progress\", (progress) => {\n      Max.outlet([\"audioProgress\", \"bang\"]);\n    });\n\n    audioStream.save(path.resolve(mp3Path));\n\n    audioStream.on(\"end\", () => {\n      savedVideos.videos.push(vidId);\n      updateVideosJSON(savedVideos);\n\n      Max.outlet([\"audio\", path.resolve(mp3Path)]);\n      Max.outlet([\"video\", path.resolve(movPath)]);\n      Max.outlet([\"savedVideos\", savedVideos.videos]);\n    });\n  } catch (error) {\n    Max.outlet(\"error\", error.toString());\n  }\n};\n\nconst downloadResult = async (link) => {\n  try {\n    let info = await ytdl.getInfo(link);\n    const videoLength = Number(info.videoDetails.lengthSeconds);\n    const format = ytdl.chooseFormat(info.formats, {\n      filter: \"videoandaudio\",\n      quality: \"highestvideo\",\n    });\n\n    let vidId =\n      info.videoDetails.title.replace(/(\\s+|\\:)/g, \"_\").toLowerCase() +\n      \"_\" +\n      info.videoDetails.videoId;\n\n    let mp3Path = `./media/${vidId}.mp3`;\n    let movPath = `./media/${vidId}.mov`;\n\n    let duration = videoLength;\n\n    const videoStream = new ffmpeg({ source: format.url })\n      .withVideoCodec(\"hap\")\n      .outputOptions(\"-format hap_q\");\n\n    if (duration > 60) {\n      duration = 60;\n      videoStream.duration(duration);\n    }\n\n    const audioStream = videoStream.clone();\n\n    videoStream.on(\"progress\", ffmpegOnProgress(logProgress, duration * 1000));\n\n    videoStream.save(path.resolve(movPath));\n\n    audioStream.on(\"progress\", (progress) => {\n      Max.outlet([\"audioProgress\", \"bang\"]);\n    });\n\n    audioStream.save(path.resolve(mp3Path));\n\n    videoStream.on(\"end\", () => {\n      savedVideos.videos.push(vidId);\n      updateVideosJSON(savedVideos);\n\n      Max.outlet([\"audio\", path.resolve(mp3Path)]);\n      Max.outlet([\"video\", path.resolve(movPath)]);\n      Max.outlet([\"savedVideos\", savedVideos.videos]);\n    });\n  } catch (error) {\n    Max.outlet(\"error\", error.toString());\n  }\n};\n\nMax.addHandler(\"downloadVid\", (index) => {\n  downloadResult(currentResults[index]);\n});\n\nMax.addHandler(\"convertVid\", (path) => {\n  convertVideo(path);\n});\n\nMax.addHandler(\"search\", (term) => {\n  getResults(term);\n});\n\nMax.addHandler(\"select\", (id) => {\n  currentSelected = id;\n  Max.outlet([\"audio\", path.resolve(`./media/${id}.mp3`)]);\n  Max.outlet([\"video\", path.resolve(`./media/${id}.mov`)]);\n});\n\nMax.addHandler(\"deleteCurrent\", () => {\n  if (currentSelected) {\n    const mp3 = `./media/${currentSelected}.mp3`;\n    const mov = `./media/${currentSelected}.mov`;\n\n    [mp3, mov].forEach((path) => {\n      fs.unlink(path, (err) => {\n        if (err) {\n          Max.outlet(\"error\", error.toString());\n          return;\n        }\n        //file removed\n      });\n    });\n\n    savedVideos.videos = savedVideos.videos.filter(\n      (vid) => vid !== currentSelected\n    );\n    updateVideosJSON(savedVideos);\n    Max.outlet([\"savedVideos\", savedVideos.videos]);\n  }\n});\n","const PassThrough = require('stream').PassThrough;\nconst getInfo = require('./info');\nconst utils = require('./utils');\nconst formatUtils = require('./format-utils');\nconst urlUtils = require('./url-utils');\nconst sig = require('./sig');\nconst miniget = require('miniget');\nconst m3u8stream = require('m3u8stream');\nconst { parseTimestamp } = require('m3u8stream');\n\n\n/**\n * @param {string} link\n * @param {!Object} options\n * @returns {ReadableStream}\n */\nconst ytdl = (link, options) => {\n  const stream = createStream(options);\n  ytdl.getInfo(link, options).then(info => {\n    downloadFromInfoCallback(stream, info, options);\n  }, stream.emit.bind(stream, 'error'));\n  return stream;\n};\nmodule.exports = ytdl;\n\nytdl.getBasicInfo = getInfo.getBasicInfo;\nytdl.getInfo = getInfo.getInfo;\nytdl.chooseFormat = formatUtils.chooseFormat;\nytdl.filterFormats = formatUtils.filterFormats;\nytdl.validateID = urlUtils.validateID;\nytdl.validateURL = urlUtils.validateURL;\nytdl.getURLVideoID = urlUtils.getURLVideoID;\nytdl.getVideoID = urlUtils.getVideoID;\nytdl.cache = {\n  sig: sig.cache,\n  info: getInfo.cache,\n  watch: getInfo.watchPageCache,\n  cookie: getInfo.cookieCache,\n};\nytdl.version = require('../package.json').version;\n\n\nconst createStream = options => {\n  const stream = new PassThrough({\n    highWaterMark: (options && options.highWaterMark) || 1024 * 512,\n  });\n  stream._destroy = () => { stream.destroyed = true; };\n  return stream;\n};\n\n\nconst pipeAndSetEvents = (req, stream, end) => {\n  // Forward events from the request to the stream.\n  [\n    'abort', 'request', 'response', 'error', 'redirect', 'retry', 'reconnect',\n  ].forEach(event => {\n    req.prependListener(event, stream.emit.bind(stream, event));\n  });\n  req.pipe(stream, { end });\n};\n\n\n/**\n * Chooses a format to download.\n *\n * @param {stream.Readable} stream\n * @param {Object} info\n * @param {Object} options\n */\nconst downloadFromInfoCallback = (stream, info, options) => {\n  options = options || {};\n\n  let err = utils.playError(info.player_response, ['UNPLAYABLE', 'LIVE_STREAM_OFFLINE', 'LOGIN_REQUIRED']);\n  if (err) {\n    stream.emit('error', err);\n    return;\n  }\n\n  if (!info.formats.length) {\n    stream.emit('error', Error('This video is unavailable'));\n    return;\n  }\n\n  let format;\n  try {\n    format = formatUtils.chooseFormat(info.formats, options);\n  } catch (e) {\n    stream.emit('error', e);\n    return;\n  }\n  stream.emit('info', info, format);\n  if (stream.destroyed) { return; }\n\n  let contentLength, downloaded = 0;\n  const ondata = chunk => {\n    downloaded += chunk.length;\n    stream.emit('progress', chunk.length, downloaded, contentLength);\n  };\n\n  if (options.IPv6Block) {\n    options.requestOptions = Object.assign({}, options.requestOptions, {\n      family: 6,\n      localAddress: utils.getRandomIPv6(options.IPv6Block),\n    });\n  }\n\n  // Download the file in chunks, in this case the default is 10MB,\n  // anything over this will cause youtube to throttle the download\n  const dlChunkSize = options.dlChunkSize || 1024 * 1024 * 10;\n  let req;\n  let shouldEnd = true;\n\n  if (format.isHLS || format.isDashMPD) {\n    req = m3u8stream(format.url, {\n      chunkReadahead: +info.live_chunk_readahead,\n      begin: options.begin || (format.isLive && Date.now()),\n      liveBuffer: options.liveBuffer,\n      requestOptions: options.requestOptions,\n      parser: format.isDashMPD ? 'dash-mpd' : 'm3u8',\n      id: format.itag,\n    });\n\n    req.on('progress', (segment, totalSegments) => {\n      stream.emit('progress', segment.size, segment.num, totalSegments);\n    });\n    pipeAndSetEvents(req, stream, shouldEnd);\n  } else {\n    const requestOptions = Object.assign({}, options.requestOptions, {\n      maxReconnects: 6,\n      maxRetries: 3,\n      backoff: { inc: 500, max: 10000 },\n    });\n\n    let shouldBeChunked = dlChunkSize !== 0 && (!format.hasAudio || !format.hasVideo);\n\n    if (shouldBeChunked) {\n      let start = (options.range && options.range.start) || 0;\n      let end = start + dlChunkSize;\n      const rangeEnd = options.range && options.range.end;\n\n      contentLength = options.range ?\n        (rangeEnd ? rangeEnd + 1 : parseInt(format.contentLength)) - start :\n        parseInt(format.contentLength);\n\n      const getNextChunk = () => {\n        if (!rangeEnd && end >= contentLength) end = 0;\n        if (rangeEnd && end > rangeEnd) end = rangeEnd;\n        shouldEnd = !end || end === rangeEnd;\n\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: `bytes=${start}-${end || ''}`,\n        });\n\n        req = miniget(format.url, requestOptions);\n        req.on('data', ondata);\n        req.on('end', () => {\n          if (stream.destroyed) { return; }\n          if (end && end !== rangeEnd) {\n            start = end + 1;\n            end += dlChunkSize;\n            getNextChunk();\n          }\n        });\n        pipeAndSetEvents(req, stream, shouldEnd);\n      };\n      getNextChunk();\n    } else {\n      // Audio only and video only formats don't support begin\n      if (options.begin) {\n        format.url += `&begin=${parseTimestamp(options.begin)}`;\n      }\n      if (options.range && (options.range.start || options.range.end)) {\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: `bytes=${options.range.start || '0'}-${options.range.end || ''}`,\n        });\n      }\n      req = miniget(format.url, requestOptions);\n      req.on('response', res => {\n        if (stream.destroyed) { return; }\n        contentLength = contentLength || parseInt(res.headers['content-length']);\n      });\n      req.on('data', ondata);\n      pipeAndSetEvents(req, stream, shouldEnd);\n    }\n  }\n\n  stream._destroy = () => {\n    stream.destroyed = true;\n    req.destroy();\n    req.end();\n  };\n};\n\n\n/**\n * Can be used to download video after its `info` is gotten through\n * `ytdl.getInfo()`. In case the user might want to look at the\n * `info` object before deciding to download.\n *\n * @param {Object} info\n * @param {!Object} options\n * @returns {ReadableStream}\n */\nytdl.downloadFromInfo = (info, options) => {\n  const stream = createStream(options);\n  if (!info.full) {\n    throw Error('Cannot use `ytdl.downloadFromInfo()` when called ' +\n      'with info from `ytdl.getBasicInfo()`');\n  }\n  setImmediate(() => {\n    downloadFromInfoCallback(stream, info, options);\n  });\n  return stream;\n};\n","const querystring = require('querystring');\nconst sax = require('sax');\nconst miniget = require('miniget');\nconst utils = require('./utils');\n// Forces Node JS version of setTimeout for Electron based applications\nconst { setTimeout } = require('timers');\nconst formatUtils = require('./format-utils');\nconst urlUtils = require('./url-utils');\nconst extras = require('./info-extras');\nconst sig = require('./sig');\nconst Cache = require('./cache');\n\n\nconst BASE_URL = 'https://www.youtube.com/watch?v=';\n\n\n// Cached for storing basic/full info.\nexports.cache = new Cache();\nexports.cookieCache = new Cache(1000 * 60 * 60 * 24);\nexports.watchPageCache = new Cache();\n// Cache for cver used in getVideoInfoPage\nlet cver = '2.20210622.10.00';\n\n\n// Special error class used to determine if an error is unrecoverable,\n// as in, ytdl-core should not try again to fetch the video metadata.\n// In this case, the video is usually unavailable in some way.\nclass UnrecoverableError extends Error {}\n\n\n// List of URLs that show up in `notice_url` for age restricted videos.\nconst AGE_RESTRICTED_URLS = [\n  'support.google.com/youtube/?p=age_restrictions',\n  'youtube.com/t/community_guidelines',\n];\n\n\n/**\n * Gets info from a video without getting additional formats.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n*/\nexports.getBasicInfo = async(id, options) => {\n  if (options.IPv6Block) {\n    options.requestOptions = Object.assign({}, options.requestOptions, {\n      family: 6,\n      localAddress: utils.getRandomIPv6(options.IPv6Block),\n    });\n  }\n  const retryOptions = Object.assign({}, miniget.defaultOptions, options.requestOptions);\n  options.requestOptions = Object.assign({}, options.requestOptions, {});\n  options.requestOptions.headers = Object.assign({},\n    {\n      // eslint-disable-next-line max-len\n      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.101 Safari/537.36',\n    }, options.requestOptions.headers);\n  const validate = info => {\n    let playErr = utils.playError(info.player_response, ['ERROR'], UnrecoverableError);\n    let privateErr = privateVideoError(info.player_response);\n    if (playErr || privateErr) {\n      throw playErr || privateErr;\n    }\n    return info && info.player_response && (\n      info.player_response.streamingData || isRental(info.player_response) || isNotYetBroadcasted(info.player_response)\n    );\n  };\n  let info = await pipeline([id, options], validate, retryOptions, [\n    getWatchHTMLPage,\n    getWatchJSONPage,\n    getVideoInfoPage,\n  ]);\n\n  Object.assign(info, {\n    formats: parseFormats(info.player_response),\n    related_videos: extras.getRelatedVideos(info),\n  });\n\n  // Add additional properties to info.\n  const media = extras.getMedia(info);\n  const additional = {\n    author: extras.getAuthor(info),\n    media,\n    likes: extras.getLikes(info),\n    dislikes: extras.getDislikes(info),\n    age_restricted: !!(media && AGE_RESTRICTED_URLS.some(url =>\n      Object.values(media).some(v => typeof v === 'string' && v.includes(url)))\n    ),\n\n    // Give the standard link to the video.\n    video_url: BASE_URL + id,\n    storyboards: extras.getStoryboards(info),\n    chapters: extras.getChapters(info),\n  };\n\n  info.videoDetails = extras.cleanVideoDetails(Object.assign({},\n    info.player_response && info.player_response.microformat &&\n    info.player_response.microformat.playerMicroformatRenderer,\n    info.player_response && info.player_response.videoDetails, additional), info);\n\n  return info;\n};\n\nconst privateVideoError = player_response => {\n  let playability = player_response && player_response.playabilityStatus;\n  if (playability && playability.status === 'LOGIN_REQUIRED' && playability.messages &&\n    playability.messages.filter(m => /This is a private video/.test(m)).length) {\n    return new UnrecoverableError(playability.reason || (playability.messages && playability.messages[0]));\n  } else {\n    return null;\n  }\n};\n\n\nconst isRental = player_response => {\n  let playability = player_response.playabilityStatus;\n  return playability && playability.status === 'UNPLAYABLE' &&\n    playability.errorScreen && playability.errorScreen.playerLegacyDesktopYpcOfferRenderer;\n};\n\n\nconst isNotYetBroadcasted = player_response => {\n  let playability = player_response.playabilityStatus;\n  return playability && playability.status === 'LIVE_STREAM_OFFLINE';\n};\n\n\nconst getWatchHTMLURL = (id, options) => `${BASE_URL + id}&hl=${options.lang || 'en'}`;\nconst getWatchHTMLPageBody = (id, options) => {\n  const url = getWatchHTMLURL(id, options);\n  return exports.watchPageCache.getOrSet(url, () => utils.exposedMiniget(url, options).text());\n};\n\n\nconst EMBED_URL = 'https://www.youtube.com/embed/';\nconst getEmbedPageBody = (id, options) => {\n  const embedUrl = `${EMBED_URL + id}?hl=${options.lang || 'en'}`;\n  return utils.exposedMiniget(embedUrl, options).text();\n};\n\n\nconst getHTML5player = body => {\n  let html5playerRes =\n    /<script\\s+src=\"([^\"]+)\"(?:\\s+type=\"text\\/javascript\")?\\s+name=\"player_ias\\/base\"\\s*>|\"jsUrl\":\"([^\"]+)\"/\n      .exec(body);\n  return html5playerRes ? html5playerRes[1] || html5playerRes[2] : null;\n};\n\n\nconst getIdentityToken = (id, options, key, throwIfNotFound) =>\n  exports.cookieCache.getOrSet(key, async() => {\n    let page = await getWatchHTMLPageBody(id, options);\n    let match = page.match(/([\"'])ID_TOKEN\\1[:,]\\s?\"([^\"]+)\"/);\n    if (!match && throwIfNotFound) {\n      throw new UnrecoverableError('Cookie header used in request, but unable to find YouTube identity token');\n    }\n    return match && match[2];\n  });\n\n\n/**\n * Goes through each endpoint in the pipeline, retrying on failure if the error is recoverable.\n * If unable to succeed with one endpoint, moves onto the next one.\n *\n * @param {Array.<Object>} args\n * @param {Function} validate\n * @param {Object} retryOptions\n * @param {Array.<Function>} endpoints\n * @returns {[Object, Object, Object]}\n */\nconst pipeline = async(args, validate, retryOptions, endpoints) => {\n  let info;\n  for (let func of endpoints) {\n    try {\n      const newInfo = await retryFunc(func, args.concat([info]), retryOptions);\n      if (newInfo.player_response) {\n        newInfo.player_response.videoDetails = assign(\n          info && info.player_response && info.player_response.videoDetails,\n          newInfo.player_response.videoDetails);\n        newInfo.player_response = assign(info && info.player_response, newInfo.player_response);\n      }\n      info = assign(info, newInfo);\n      if (validate(info, false)) {\n        break;\n      }\n    } catch (err) {\n      if (err instanceof UnrecoverableError || func === endpoints[endpoints.length - 1]) {\n        throw err;\n      }\n      // Unable to find video metadata... so try next endpoint.\n    }\n  }\n  return info;\n};\n\n\n/**\n * Like Object.assign(), but ignores `null` and `undefined` from `source`.\n *\n * @param {Object} target\n * @param {Object} source\n * @returns {Object}\n */\nconst assign = (target, source) => {\n  if (!target || !source) { return target || source; }\n  for (let [key, value] of Object.entries(source)) {\n    if (value !== null && value !== undefined) {\n      target[key] = value;\n    }\n  }\n  return target;\n};\n\n\n/**\n * Given a function, calls it with `args` until it's successful,\n * or until it encounters an unrecoverable error.\n * Currently, any error from miniget is considered unrecoverable. Errors such as\n * too many redirects, invalid URL, status code 404, status code 502.\n *\n * @param {Function} func\n * @param {Array.<Object>} args\n * @param {Object} options\n * @param {number} options.maxRetries\n * @param {Object} options.backoff\n * @param {number} options.backoff.inc\n */\nconst retryFunc = async(func, args, options) => {\n  let currentTry = 0, result;\n  while (currentTry <= options.maxRetries) {\n    try {\n      result = await func(...args);\n      break;\n    } catch (err) {\n      if (err instanceof UnrecoverableError ||\n        (err instanceof miniget.MinigetError && err.statusCode < 500) || currentTry >= options.maxRetries) {\n        throw err;\n      }\n      let wait = Math.min(++currentTry * options.backoff.inc, options.backoff.max);\n      await new Promise(resolve => setTimeout(resolve, wait));\n    }\n  }\n  return result;\n};\n\n\nconst jsonClosingChars = /^[)\\]}'\\s]+/;\nconst parseJSON = (source, varName, json) => {\n  if (!json || typeof json === 'object') {\n    return json;\n  } else {\n    try {\n      json = json.replace(jsonClosingChars, '');\n      return JSON.parse(json);\n    } catch (err) {\n      throw Error(`Error parsing ${varName} in ${source}: ${err.message}`);\n    }\n  }\n};\n\n\nconst findJSON = (source, varName, body, left, right, prependJSON) => {\n  let jsonStr = utils.between(body, left, right);\n  if (!jsonStr) {\n    throw Error(`Could not find ${varName} in ${source}`);\n  }\n  return parseJSON(source, varName, utils.cutAfterJS(`${prependJSON}${jsonStr}`));\n};\n\n\nconst findPlayerResponse = (source, info) => {\n  const player_response = info && (\n    (info.args && info.args.player_response) ||\n    info.player_response || info.playerResponse || info.embedded_player_response);\n  return parseJSON(source, 'player_response', player_response);\n};\n\n\nconst getWatchJSONURL = (id, options) => `${getWatchHTMLURL(id, options)}&pbj=1`;\nconst getWatchJSONPage = async(id, options) => {\n  const reqOptions = Object.assign({ headers: {} }, options.requestOptions);\n  let cookie = reqOptions.headers.Cookie || reqOptions.headers.cookie;\n  reqOptions.headers = Object.assign({\n    'x-youtube-client-name': '1',\n    'x-youtube-client-version': cver,\n    'x-youtube-identity-token': exports.cookieCache.get(cookie || 'browser') || '',\n  }, reqOptions.headers);\n\n  const setIdentityToken = async(key, throwIfNotFound) => {\n    if (reqOptions.headers['x-youtube-identity-token']) { return; }\n    reqOptions.headers['x-youtube-identity-token'] = await getIdentityToken(id, options, key, throwIfNotFound);\n  };\n\n  if (cookie) {\n    await setIdentityToken(cookie, true);\n  }\n\n  const jsonUrl = getWatchJSONURL(id, options);\n  const body = await utils.exposedMiniget(jsonUrl, options, reqOptions).text();\n  let parsedBody = parseJSON('watch.json', 'body', body);\n  if (parsedBody.reload === 'now') {\n    await setIdentityToken('browser', false);\n  }\n  if (parsedBody.reload === 'now' || !Array.isArray(parsedBody)) {\n    throw Error('Unable to retrieve video metadata in watch.json');\n  }\n  let info = parsedBody.reduce((part, curr) => Object.assign(curr, part), {});\n  info.player_response = findPlayerResponse('watch.json', info);\n  info.html5player = info.player && info.player.assets && info.player.assets.js;\n\n  return info;\n};\n\n\nconst getWatchHTMLPage = async(id, options) => {\n  let body = await getWatchHTMLPageBody(id, options);\n  let info = { page: 'watch' };\n  try {\n    cver = utils.between(body, '{\"key\":\"cver\",\"value\":\"', '\"}');\n    info.player_response = findJSON('watch.html', 'player_response',\n      body, /\\bytInitialPlayerResponse\\s*=\\s*\\{/i, '</script>', '{');\n  } catch (err) {\n    let args = findJSON('watch.html', 'player_response', body, /\\bytplayer\\.config\\s*=\\s*{/, '</script>', '{');\n    info.player_response = findPlayerResponse('watch.html', args);\n  }\n  info.response = findJSON('watch.html', 'response', body, /\\bytInitialData(\"\\])?\\s*=\\s*\\{/i, '</script>', '{');\n  info.html5player = getHTML5player(body);\n  return info;\n};\n\n\nconst INFO_HOST = 'www.youtube.com';\nconst INFO_PATH = '/get_video_info';\nconst VIDEO_EURL = 'https://youtube.googleapis.com/v/';\nconst getVideoInfoPage = async(id, options) => {\n  const url = new URL(`https://${INFO_HOST}${INFO_PATH}`);\n  url.searchParams.set('video_id', id);\n  url.searchParams.set('c', 'TVHTML5');\n  url.searchParams.set('cver', `7${cver.substr(1)}`);\n  url.searchParams.set('eurl', VIDEO_EURL + id);\n  url.searchParams.set('ps', 'default');\n  url.searchParams.set('gl', 'US');\n  url.searchParams.set('hl', options.lang || 'en');\n  url.searchParams.set('html5', '1');\n  const body = await utils.exposedMiniget(url.toString(), options).text();\n  let info = querystring.parse(body);\n  info.player_response = findPlayerResponse('get_video_info', info);\n  return info;\n};\n\n\n/**\n * @param {Object} player_response\n * @returns {Array.<Object>}\n */\nconst parseFormats = player_response => {\n  let formats = [];\n  if (player_response && player_response.streamingData) {\n    formats = formats\n      .concat(player_response.streamingData.formats || [])\n      .concat(player_response.streamingData.adaptiveFormats || []);\n  }\n  return formats;\n};\n\n\n/**\n * Gets info from a video additional formats and deciphered URLs.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n */\nexports.getInfo = async(id, options) => {\n  let info = await exports.getBasicInfo(id, options);\n  const hasManifest =\n    info.player_response && info.player_response.streamingData && (\n      info.player_response.streamingData.dashManifestUrl ||\n      info.player_response.streamingData.hlsManifestUrl\n    );\n  let funcs = [];\n  if (info.formats.length) {\n    info.html5player = info.html5player ||\n      getHTML5player(await getWatchHTMLPageBody(id, options)) || getHTML5player(await getEmbedPageBody(id, options));\n    if (!info.html5player) {\n      throw Error('Unable to find html5player file');\n    }\n    const html5player = new URL(info.html5player, BASE_URL).toString();\n    funcs.push(sig.decipherFormats(info.formats, html5player, options));\n  }\n  if (hasManifest && info.player_response.streamingData.dashManifestUrl) {\n    let url = info.player_response.streamingData.dashManifestUrl;\n    funcs.push(getDashManifest(url, options));\n  }\n  if (hasManifest && info.player_response.streamingData.hlsManifestUrl) {\n    let url = info.player_response.streamingData.hlsManifestUrl;\n    funcs.push(getM3U8(url, options));\n  }\n\n  let results = await Promise.all(funcs);\n  info.formats = Object.values(Object.assign({}, ...results));\n  info.formats = info.formats.map(formatUtils.addFormatMeta);\n  info.formats.sort(formatUtils.sortFormats);\n  info.full = true;\n  return info;\n};\n\n\n/**\n * Gets additional DASH formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\nconst getDashManifest = (url, options) => new Promise((resolve, reject) => {\n  let formats = {};\n  const parser = sax.parser(false);\n  parser.onerror = reject;\n  let adaptationSet;\n  parser.onopentag = node => {\n    if (node.name === 'ADAPTATIONSET') {\n      adaptationSet = node.attributes;\n    } else if (node.name === 'REPRESENTATION') {\n      const itag = parseInt(node.attributes.ID);\n      if (!isNaN(itag)) {\n        formats[url] = Object.assign({\n          itag, url,\n          bitrate: parseInt(node.attributes.BANDWIDTH),\n          mimeType: `${adaptationSet.MIMETYPE}; codecs=\"${node.attributes.CODECS}\"`,\n        }, node.attributes.HEIGHT ? {\n          width: parseInt(node.attributes.WIDTH),\n          height: parseInt(node.attributes.HEIGHT),\n          fps: parseInt(node.attributes.FRAMERATE),\n        } : {\n          audioSampleRate: node.attributes.AUDIOSAMPLINGRATE,\n        });\n      }\n    }\n  };\n  parser.onend = () => { resolve(formats); };\n  const req = utils.exposedMiniget(new URL(url, BASE_URL).toString(), options);\n  req.setEncoding('utf8');\n  req.on('error', reject);\n  req.on('data', chunk => { parser.write(chunk); });\n  req.on('end', parser.close.bind(parser));\n});\n\n\n/**\n * Gets additional formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\nconst getM3U8 = async(url, options) => {\n  url = new URL(url, BASE_URL);\n  const body = await utils.exposedMiniget(url.toString(), options).text();\n  let formats = {};\n  body\n    .split('\\n')\n    .filter(line => /^https?:\\/\\//.test(line))\n    .forEach(line => {\n      const itag = parseInt(line.match(/\\/itag\\/(\\d+)\\//)[1]);\n      formats[line] = { itag, url: line };\n    });\n  return formats;\n};\n\n\n// Cache get info functions.\n// In case a user wants to get a video's info before downloading.\nfor (let funcName of ['getBasicInfo', 'getInfo']) {\n  /**\n   * @param {string} link\n   * @param {Object} options\n   * @returns {Promise<Object>}\n   */\n  const func = exports[funcName];\n  exports[funcName] = async(link, options = {}) => {\n    utils.checkForUpdates();\n    let id = await urlUtils.getVideoID(link);\n    const key = [funcName, id, options.lang].join('-');\n    return exports.cache.getOrSet(key, () => func(id, options));\n  };\n}\n\n\n// Export a few helpers.\nexports.validateID = urlUtils.validateID;\nexports.validateURL = urlUtils.validateURL;\nexports.getURLVideoID = urlUtils.getURLVideoID;\nexports.getVideoID = urlUtils.getVideoID;\n","const miniget = require('miniget');\n\n\n/**\n * Extract string inbetween another.\n *\n * @param {string} haystack\n * @param {string} left\n * @param {string} right\n * @returns {string}\n */\nexports.between = (haystack, left, right) => {\n  let pos;\n  if (left instanceof RegExp) {\n    const match = haystack.match(left);\n    if (!match) { return ''; }\n    pos = match.index + match[0].length;\n  } else {\n    pos = haystack.indexOf(left);\n    if (pos === -1) { return ''; }\n    pos += left.length;\n  }\n  haystack = haystack.slice(pos);\n  pos = haystack.indexOf(right);\n  if (pos === -1) { return ''; }\n  haystack = haystack.slice(0, pos);\n  return haystack;\n};\n\n\n/**\n * Get a number from an abbreviated number string.\n *\n * @param {string} string\n * @returns {number}\n */\nexports.parseAbbreviatedNumber = string => {\n  const match = string\n    .replace(',', '.')\n    .replace(' ', '')\n    .match(/([\\d,.]+)([MK]?)/);\n  if (match) {\n    let [, num, multi] = match;\n    num = parseFloat(num);\n    return Math.round(multi === 'M' ? num * 1000000 :\n      multi === 'K' ? num * 1000 : num);\n  }\n  return null;\n};\n\n/**\n * Escape sequences for cutAfterJS\n * @param {string} start the character string the escape sequence\n * @param {string} end the character string to stop the escape seequence\n * @param {undefined|Regex} startPrefix a regex to check against the preceding 10 characters\n */\nconst ESCAPING_SEQUENZES = [\n  // Strings\n  { start: '\"', end: '\"' },\n  { start: \"'\", end: \"'\" },\n  { start: '`', end: '`' },\n  // RegeEx\n  { start: '/', end: '/', startPrefix: /(^|[[{:;,])\\s?$/ },\n];\n\n/**\n * Match begin and end braces of input JS, return only JS\n *\n * @param {string} mixedJson\n * @returns {string}\n*/\nexports.cutAfterJS = mixedJson => {\n  // Define the general open and closing tag\n  let open, close;\n  if (mixedJson[0] === '[') {\n    open = '[';\n    close = ']';\n  } else if (mixedJson[0] === '{') {\n    open = '{';\n    close = '}';\n  }\n\n  if (!open) {\n    throw new Error(`Can't cut unsupported JSON (need to begin with [ or { ) but got: ${mixedJson[0]}`);\n  }\n\n  // States if the loop is currently inside an escaped js object\n  let isEscapedObject = null;\n\n  // States if the current character is treated as escaped or not\n  let isEscaped = false;\n\n  // Current open brackets to be closed\n  let counter = 0;\n\n  let i;\n  // Go through all characters from the start\n  for (i = 0; i < mixedJson.length; i++) {\n    // End of current escaped object\n    if (!isEscaped && isEscapedObject !== null && mixedJson[i] === isEscapedObject.end) {\n      isEscapedObject = null;\n      continue;\n    // Might be the start of a new escaped object\n    } else if (!isEscaped && isEscapedObject === null) {\n      for (const escaped of ESCAPING_SEQUENZES) {\n        if (mixedJson[i] !== escaped.start) continue;\n        // Test startPrefix against last 10 characters\n        if (!escaped.startPrefix || mixedJson.substring(i - 10, i).match(escaped.startPrefix)) {\n          isEscapedObject = escaped;\n          break;\n        }\n      }\n      // Continue if we found a new escaped object\n      if (isEscapedObject !== null) {\n        continue;\n      }\n    }\n\n    // Toggle the isEscaped boolean for every backslash\n    // Reset for every regular character\n    isEscaped = mixedJson[i] === '\\\\' && !isEscaped;\n\n    if (isEscapedObject !== null) continue;\n\n    if (mixedJson[i] === open) {\n      counter++;\n    } else if (mixedJson[i] === close) {\n      counter--;\n    }\n\n    // All brackets have been closed, thus end of JSON is reached\n    if (counter === 0) {\n      // Return the cut JSON\n      return mixedJson.substring(0, i + 1);\n    }\n  }\n\n  // We ran through the whole string and ended up with an unclosed bracket\n  throw Error(\"Can't cut unsupported JSON (no matching closing bracket found)\");\n};\n\n\n/**\n * Checks if there is a playability error.\n *\n * @param {Object} player_response\n * @param {Array.<string>} statuses\n * @param {Error} ErrorType\n * @returns {!Error}\n */\nexports.playError = (player_response, statuses, ErrorType = Error) => {\n  let playability = player_response && player_response.playabilityStatus;\n  if (playability && statuses.includes(playability.status)) {\n    return new ErrorType(playability.reason || (playability.messages && playability.messages[0]));\n  }\n  return null;\n};\n\n/**\n * Does a miniget request and calls options.requestCallback if present\n *\n * @param {string} url the request url\n * @param {Object} options an object with optional requestOptions and requestCallback parameters\n * @param {Object} requestOptionsOverwrite overwrite of options.requestOptions\n * @returns {miniget.Stream}\n */\nexports.exposedMiniget = (url, options = {}, requestOptionsOverwrite) => {\n  const req = miniget(url, requestOptionsOverwrite || options.requestOptions);\n  if (typeof options.requestCallback === 'function') options.requestCallback(req);\n  return req;\n};\n\n/**\n * Temporary helper to help deprecating a few properties.\n *\n * @param {Object} obj\n * @param {string} prop\n * @param {Object} value\n * @param {string} oldPath\n * @param {string} newPath\n */\nexports.deprecate = (obj, prop, value, oldPath, newPath) => {\n  Object.defineProperty(obj, prop, {\n    get: () => {\n      console.warn(`\\`${oldPath}\\` will be removed in a near future release, ` +\n        `use \\`${newPath}\\` instead.`);\n      return value;\n    },\n  });\n};\n\n\n// Check for updates.\nconst pkg = require('../package.json');\nconst UPDATE_INTERVAL = 1000 * 60 * 60 * 12;\nexports.lastUpdateCheck = 0;\nexports.checkForUpdates = () => {\n  if (!process.env.YTDL_NO_UPDATE && !pkg.version.startsWith('0.0.0-') &&\n    Date.now() - exports.lastUpdateCheck >= UPDATE_INTERVAL) {\n    exports.lastUpdateCheck = Date.now();\n    return miniget('https://api.github.com/repos/fent/node-ytdl-core/releases/latest', {\n      headers: { 'User-Agent': 'ytdl-core' },\n    }).text().then(response => {\n      if (JSON.parse(response).tag_name !== `v${pkg.version}`) {\n        console.warn('\\x1b[33mWARNING:\\x1B[0m ytdl-core is out of date! Update with \"npm install ytdl-core@latest\".');\n      }\n    }, err => {\n      console.warn('Error checking for updates:', err.message);\n      console.warn('You can disable this check by setting the `YTDL_NO_UPDATE` env variable.');\n    });\n  }\n  return null;\n};\n\n\n/**\n * Gets random IPv6 Address from a block\n *\n * @param {string} ip the IPv6 block in CIDR-Notation\n * @returns {string}\n */\nexports.getRandomIPv6 = ip => {\n  // Start with a fast Regex-Check\n  if (!isIPv6(ip)) throw Error('Invalid IPv6 format');\n  // Start by splitting and normalizing addr and mask\n  const [rawAddr, rawMask] = ip.split('/');\n  let base10Mask = parseInt(rawMask);\n  if (!base10Mask || base10Mask > 128 || base10Mask < 24) throw Error('Invalid IPv6 subnet');\n  const base10addr = normalizeIP(rawAddr);\n  // Get random addr to pad with\n  // using Math.random since we're not requiring high level of randomness\n  const randomAddr = new Array(8).fill(1).map(() => Math.floor(Math.random() * 0xffff));\n\n  // Merge base10addr with randomAddr\n  const mergedAddr = randomAddr.map((randomItem, idx) => {\n    // Calculate the amount of static bits\n    const staticBits = Math.min(base10Mask, 16);\n    // Adjust the bitmask with the staticBits\n    base10Mask -= staticBits;\n    // Calculate the bitmask\n    // lsb makes the calculation way more complicated\n    const mask = 0xffff - ((2 ** (16 - staticBits)) - 1);\n    // Combine base10addr and random\n    return (base10addr[idx] & mask) + (randomItem & (mask ^ 0xffff));\n  });\n  // Return new addr\n  return mergedAddr.map(x => x.toString('16')).join(':');\n};\n\n\n// eslint-disable-next-line max-len\nconst IPV6_REGEX = /^(([0-9a-f]{1,4}:)(:[0-9a-f]{1,4}){1,6}|([0-9a-f]{1,4}:){1,2}(:[0-9a-f]{1,4}){1,5}|([0-9a-f]{1,4}:){1,3}(:[0-9a-f]{1,4}){1,4}|([0-9a-f]{1,4}:){1,4}(:[0-9a-f]{1,4}){1,3}|([0-9a-f]{1,4}:){1,5}(:[0-9a-f]{1,4}){1,2}|([0-9a-f]{1,4}:){1,6}(:[0-9a-f]{1,4})|([0-9a-f]{1,4}:){1,7}(([0-9a-f]{1,4})|:))\\/(1[0-1]\\d|12[0-8]|\\d{1,2})$/;\n/**\n * Quick check for a valid IPv6\n * The Regex only accepts a subset of all IPv6 Addresses\n *\n * @param {string} ip the IPv6 block in CIDR-Notation to test\n * @returns {boolean} true if valid\n */\nconst isIPv6 = exports.isIPv6 = ip => IPV6_REGEX.test(ip);\n\n\n/**\n * Normalise an IP Address\n *\n * @param {string} ip the IPv6 Addr\n * @returns {number[]} the 8 parts of the IPv6 as Integers\n */\nconst normalizeIP = exports.normalizeIP = ip => {\n  // Split by fill position\n  const parts = ip.split('::').map(x => x.split(':'));\n  // Normalize start and end\n  const partStart = parts[0] || [];\n  const partEnd = parts[1] || [];\n  partEnd.reverse();\n  // Placeholder for full ip\n  const fullIP = new Array(8).fill(0);\n  // Fill in start and end parts\n  for (let i = 0; i < Math.min(partStart.length, 8); i++) {\n    fullIP[i] = parseInt(partStart[i], 16) || 0;\n  }\n  for (let i = 0; i < Math.min(partEnd.length, 8); i++) {\n    fullIP[7 - i] = parseInt(partEnd[i], 16) || 0;\n  }\n  return fullIP;\n};\n","const utils = require('./utils');\nconst FORMATS = require('./formats');\n\n\n// Use these to help sort formats, higher index is better.\nconst audioEncodingRanks = [\n  'mp4a',\n  'mp3',\n  'vorbis',\n  'aac',\n  'opus',\n  'flac',\n];\nconst videoEncodingRanks = [\n  'mp4v',\n  'avc1',\n  'Sorenson H.283',\n  'MPEG-4 Visual',\n  'VP8',\n  'VP9',\n  'H.264',\n];\n\nconst getVideoBitrate = format => format.bitrate || 0;\nconst getVideoEncodingRank = format =>\n  videoEncodingRanks.findIndex(enc => format.codecs && format.codecs.includes(enc));\nconst getAudioBitrate = format => format.audioBitrate || 0;\nconst getAudioEncodingRank = format =>\n  audioEncodingRanks.findIndex(enc => format.codecs && format.codecs.includes(enc));\n\n\n/**\n * Sort formats by a list of functions.\n *\n * @param {Object} a\n * @param {Object} b\n * @param {Array.<Function>} sortBy\n * @returns {number}\n */\nconst sortFormatsBy = (a, b, sortBy) => {\n  let res = 0;\n  for (let fn of sortBy) {\n    res = fn(b) - fn(a);\n    if (res !== 0) {\n      break;\n    }\n  }\n  return res;\n};\n\n\nconst sortFormatsByVideo = (a, b) => sortFormatsBy(a, b, [\n  format => parseInt(format.qualityLabel),\n  getVideoBitrate,\n  getVideoEncodingRank,\n]);\n\n\nconst sortFormatsByAudio = (a, b) => sortFormatsBy(a, b, [\n  getAudioBitrate,\n  getAudioEncodingRank,\n]);\n\n\n/**\n * Sort formats from highest quality to lowest.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {number}\n */\nexports.sortFormats = (a, b) => sortFormatsBy(a, b, [\n  // Formats with both video and audio are ranked highest.\n  format => +!!format.isHLS,\n  format => +!!format.isDashMPD,\n  format => +(format.contentLength > 0),\n  format => +(format.hasVideo && format.hasAudio),\n  format => +format.hasVideo,\n  format => parseInt(format.qualityLabel) || 0,\n  getVideoBitrate,\n  getAudioBitrate,\n  getVideoEncodingRank,\n  getAudioEncodingRank,\n]);\n\n\n/**\n * Choose a format depending on the given options.\n *\n * @param {Array.<Object>} formats\n * @param {Object} options\n * @returns {Object}\n * @throws {Error} when no format matches the filter/format rules\n */\nexports.chooseFormat = (formats, options) => {\n  if (typeof options.format === 'object') {\n    if (!options.format.url) {\n      throw Error('Invalid format given, did you use `ytdl.getInfo()`?');\n    }\n    return options.format;\n  }\n\n  if (options.filter) {\n    formats = exports.filterFormats(formats, options.filter);\n  }\n\n  // We currently only support HLS-Formats for livestreams\n  // So we (now) remove all non-HLS streams\n  if (formats.some(fmt => fmt.isHLS)) {\n    formats = formats.filter(fmt => fmt.isHLS || !fmt.isLive);\n  }\n\n  let format;\n  const quality = options.quality || 'highest';\n  switch (quality) {\n    case 'highest':\n      format = formats[0];\n      break;\n\n    case 'lowest':\n      format = formats[formats.length - 1];\n      break;\n\n    case 'highestaudio': {\n      formats = exports.filterFormats(formats, 'audio');\n      formats.sort(sortFormatsByAudio);\n      // Filter for only the best audio format\n      const bestAudioFormat = formats[0];\n      formats = formats.filter(f => sortFormatsByAudio(bestAudioFormat, f) === 0);\n      // Check for the worst video quality for the best audio quality and pick according\n      // This does not loose default sorting of video encoding and bitrate\n      const worstVideoQuality = formats.map(f => parseInt(f.qualityLabel) || 0).sort((a, b) => a - b)[0];\n      format = formats.find(f => (parseInt(f.qualityLabel) || 0) === worstVideoQuality);\n      break;\n    }\n\n    case 'lowestaudio':\n      formats = exports.filterFormats(formats, 'audio');\n      formats.sort(sortFormatsByAudio);\n      format = formats[formats.length - 1];\n      break;\n\n    case 'highestvideo': {\n      formats = exports.filterFormats(formats, 'video');\n      formats.sort(sortFormatsByVideo);\n      // Filter for only the best video format\n      const bestVideoFormat = formats[0];\n      formats = formats.filter(f => sortFormatsByVideo(bestVideoFormat, f) === 0);\n      // Check for the worst audio quality for the best video quality and pick according\n      // This does not loose default sorting of audio encoding and bitrate\n      const worstAudioQuality = formats.map(f => f.audioBitrate || 0).sort((a, b) => a - b)[0];\n      format = formats.find(f => (f.audioBitrate || 0) === worstAudioQuality);\n      break;\n    }\n\n    case 'lowestvideo':\n      formats = exports.filterFormats(formats, 'video');\n      formats.sort(sortFormatsByVideo);\n      format = formats[formats.length - 1];\n      break;\n\n    default:\n      format = getFormatByQuality(quality, formats);\n      break;\n  }\n\n  if (!format) {\n    throw Error(`No such format found: ${quality}`);\n  }\n  return format;\n};\n\n/**\n * Gets a format based on quality or array of quality's\n *\n * @param {string|[string]} quality\n * @param {[Object]} formats\n * @returns {Object}\n */\nconst getFormatByQuality = (quality, formats) => {\n  let getFormat = itag => formats.find(format => `${format.itag}` === `${itag}`);\n  if (Array.isArray(quality)) {\n    return getFormat(quality.find(q => getFormat(q)));\n  } else {\n    return getFormat(quality);\n  }\n};\n\n\n/**\n * @param {Array.<Object>} formats\n * @param {Function} filter\n * @returns {Array.<Object>}\n */\nexports.filterFormats = (formats, filter) => {\n  let fn;\n  switch (filter) {\n    case 'videoandaudio':\n    case 'audioandvideo':\n      fn = format => format.hasVideo && format.hasAudio;\n      break;\n\n    case 'video':\n      fn = format => format.hasVideo;\n      break;\n\n    case 'videoonly':\n      fn = format => format.hasVideo && !format.hasAudio;\n      break;\n\n    case 'audio':\n      fn = format => format.hasAudio;\n      break;\n\n    case 'audioonly':\n      fn = format => !format.hasVideo && format.hasAudio;\n      break;\n\n    default:\n      if (typeof filter === 'function') {\n        fn = filter;\n      } else {\n        throw TypeError(`Given filter (${filter}) is not supported`);\n      }\n  }\n  return formats.filter(format => !!format.url && fn(format));\n};\n\n\n/**\n * @param {Object} format\n * @returns {Object}\n */\nexports.addFormatMeta = format => {\n  format = Object.assign({}, FORMATS[format.itag], format);\n  format.hasVideo = !!format.qualityLabel;\n  format.hasAudio = !!format.audioBitrate;\n  format.container = format.mimeType ?\n    format.mimeType.split(';')[0].split('/')[1] : null;\n  format.codecs = format.mimeType ?\n    utils.between(format.mimeType, 'codecs=\"', '\"') : null;\n  format.videoCodec = format.hasVideo && format.codecs ?\n    format.codecs.split(', ')[0] : null;\n  format.audioCodec = format.hasAudio && format.codecs ?\n    format.codecs.split(', ').slice(-1)[0] : null;\n  format.isLive = /\\bsource[/=]yt_live_broadcast\\b/.test(format.url);\n  format.isHLS = /\\/manifest\\/hls_(variant|playlist)\\//.test(format.url);\n  format.isDashMPD = /\\/manifest\\/dash\\//.test(format.url);\n  return format;\n};\n","/**\n * http://en.wikipedia.org/wiki/YouTube#Quality_and_formats\n */\nmodule.exports = {\n\n  5: {\n    mimeType: 'video/flv; codecs=\"Sorenson H.283, mp3\"',\n    qualityLabel: '240p',\n    bitrate: 250000,\n    audioBitrate: 64,\n  },\n\n  6: {\n    mimeType: 'video/flv; codecs=\"Sorenson H.263, mp3\"',\n    qualityLabel: '270p',\n    bitrate: 800000,\n    audioBitrate: 64,\n  },\n\n  13: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: null,\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  17: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: '144p',\n    bitrate: 50000,\n    audioBitrate: 24,\n  },\n\n  18: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 96,\n  },\n\n  22: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 192,\n  },\n\n  34: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 128,\n  },\n\n  35: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: '480p',\n    bitrate: 800000,\n    audioBitrate: 128,\n  },\n\n  36: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: '240p',\n    bitrate: 175000,\n    audioBitrate: 32,\n  },\n\n  37: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '1080p',\n    bitrate: 3000000,\n    audioBitrate: 192,\n  },\n\n  38: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '3072p',\n    bitrate: 3500000,\n    audioBitrate: 192,\n  },\n\n  43: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 128,\n  },\n\n  44: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '480p',\n    bitrate: 1000000,\n    audioBitrate: 128,\n  },\n\n  45: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 192,\n  },\n\n  46: {\n    mimeType: 'audio/webm; codecs=\"vp8, vorbis\"',\n    qualityLabel: '1080p',\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  82: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 96,\n  },\n\n  83: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '240p',\n    bitrate: 500000,\n    audioBitrate: 96,\n  },\n\n  84: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 192,\n  },\n\n  85: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '1080p',\n    bitrate: 3000000,\n    audioBitrate: 192,\n  },\n\n  91: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '144p',\n    bitrate: 100000,\n    audioBitrate: 48,\n  },\n\n  92: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '240p',\n    bitrate: 150000,\n    audioBitrate: 48,\n  },\n\n  93: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 128,\n  },\n\n  94: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '480p',\n    bitrate: 800000,\n    audioBitrate: 128,\n  },\n\n  95: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 1500000,\n    audioBitrate: 256,\n  },\n\n  96: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '1080p',\n    bitrate: 2500000,\n    audioBitrate: 256,\n  },\n\n  100: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '360p',\n    bitrate: null,\n    audioBitrate: 128,\n  },\n\n  101: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '360p',\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  102: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '720p',\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  120: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 128,\n  },\n\n  127: {\n    mimeType: 'audio/ts; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 96,\n  },\n\n  128: {\n    mimeType: 'audio/ts; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 96,\n  },\n\n  132: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '240p',\n    bitrate: 150000,\n    audioBitrate: 48,\n  },\n\n  133: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '240p',\n    bitrate: 200000,\n    audioBitrate: null,\n  },\n\n  134: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '360p',\n    bitrate: 300000,\n    audioBitrate: null,\n  },\n\n  135: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '480p',\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  136: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '720p',\n    bitrate: 1000000,\n    audioBitrate: null,\n  },\n\n  137: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '1080p',\n    bitrate: 2500000,\n    audioBitrate: null,\n  },\n\n  138: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '4320p',\n    bitrate: 13500000,\n    audioBitrate: null,\n  },\n\n  139: {\n    mimeType: 'audio/mp4; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 48,\n  },\n\n  140: {\n    mimeType: 'audio/m4a; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 128,\n  },\n\n  141: {\n    mimeType: 'audio/mp4; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 256,\n  },\n\n  151: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 50000,\n    audioBitrate: 24,\n  },\n\n  160: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '144p',\n    bitrate: 100000,\n    audioBitrate: null,\n  },\n\n  171: {\n    mimeType: 'audio/webm; codecs=\"vorbis\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 128,\n  },\n\n  172: {\n    mimeType: 'audio/webm; codecs=\"vorbis\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  242: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '240p',\n    bitrate: 100000,\n    audioBitrate: null,\n  },\n\n  243: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '360p',\n    bitrate: 250000,\n    audioBitrate: null,\n  },\n\n  244: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '480p',\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  247: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '720p',\n    bitrate: 700000,\n    audioBitrate: null,\n  },\n\n  248: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1080p',\n    bitrate: 1500000,\n    audioBitrate: null,\n  },\n\n  249: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 48,\n  },\n\n  250: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 64,\n  },\n\n  251: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 160,\n  },\n\n  264: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '1440p',\n    bitrate: 4000000,\n    audioBitrate: null,\n  },\n\n  266: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '2160p',\n    bitrate: 12500000,\n    audioBitrate: null,\n  },\n\n  271: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1440p',\n    bitrate: 9000000,\n    audioBitrate: null,\n  },\n\n  272: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '4320p',\n    bitrate: 20000000,\n    audioBitrate: null,\n  },\n\n  278: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '144p 30fps',\n    bitrate: 80000,\n    audioBitrate: null,\n  },\n\n  298: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '720p',\n    bitrate: 3000000,\n    audioBitrate: null,\n  },\n\n  299: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '1080p',\n    bitrate: 5500000,\n    audioBitrate: null,\n  },\n\n  300: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 1318000,\n    audioBitrate: 48,\n  },\n\n  302: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '720p HFR',\n    bitrate: 2500000,\n    audioBitrate: null,\n  },\n\n  303: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1080p HFR',\n    bitrate: 5000000,\n    audioBitrate: null,\n  },\n\n  308: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1440p HFR',\n    bitrate: 10000000,\n    audioBitrate: null,\n  },\n\n  313: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '2160p',\n    bitrate: 13000000,\n    audioBitrate: null,\n  },\n\n  315: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '2160p HFR',\n    bitrate: 20000000,\n    audioBitrate: null,\n  },\n\n  330: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '144p HDR, HFR',\n    bitrate: 80000,\n    audioBitrate: null,\n  },\n\n  331: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '240p HDR, HFR',\n    bitrate: 100000,\n    audioBitrate: null,\n  },\n\n  332: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '360p HDR, HFR',\n    bitrate: 250000,\n    audioBitrate: null,\n  },\n\n  333: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '240p HDR, HFR',\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  334: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '720p HDR, HFR',\n    bitrate: 1000000,\n    audioBitrate: null,\n  },\n\n  335: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1080p HDR, HFR',\n    bitrate: 1500000,\n    audioBitrate: null,\n  },\n\n  336: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1440p HDR, HFR',\n    bitrate: 5000000,\n    audioBitrate: null,\n  },\n\n  337: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '2160p HDR, HFR',\n    bitrate: 12000000,\n    audioBitrate: null,\n  },\n\n};\n","/**\n * Get video ID.\n *\n * There are a few type of video URL formats.\n *  - https://www.youtube.com/watch?v=VIDEO_ID\n *  - https://m.youtube.com/watch?v=VIDEO_ID\n *  - https://youtu.be/VIDEO_ID\n *  - https://www.youtube.com/v/VIDEO_ID\n *  - https://www.youtube.com/embed/VIDEO_ID\n *  - https://music.youtube.com/watch?v=VIDEO_ID\n *  - https://gaming.youtube.com/watch?v=VIDEO_ID\n *\n * @param {string} link\n * @return {string}\n * @throws {Error} If unable to find a id\n * @throws {TypeError} If videoid doesn't match specs\n */\nconst validQueryDomains = new Set([\n  'youtube.com',\n  'www.youtube.com',\n  'm.youtube.com',\n  'music.youtube.com',\n  'gaming.youtube.com',\n]);\nconst validPathDomains = /^https?:\\/\\/(youtu\\.be\\/|(www\\.)?youtube\\.com\\/(embed|v|shorts)\\/)/;\nexports.getURLVideoID = link => {\n  const parsed = new URL(link.trim());\n  let id = parsed.searchParams.get('v');\n  if (validPathDomains.test(link.trim()) && !id) {\n    const paths = parsed.pathname.split('/');\n    id = parsed.host === 'youtu.be' ? paths[1] : paths[2];\n  } else if (parsed.hostname && !validQueryDomains.has(parsed.hostname)) {\n    throw Error('Not a YouTube domain');\n  }\n  if (!id) {\n    throw Error(`No video id found: \"${link}\"`);\n  }\n  id = id.substring(0, 11);\n  if (!exports.validateID(id)) {\n    throw TypeError(`Video id (${id}) does not match expected ` +\n      `format (${idRegex.toString()})`);\n  }\n  return id;\n};\n\n\n/**\n * Gets video ID either from a url or by checking if the given string\n * matches the video ID format.\n *\n * @param {string} str\n * @returns {string}\n * @throws {Error} If unable to find a id\n * @throws {TypeError} If videoid doesn't match specs\n */\nconst urlRegex = /^https?:\\/\\//;\nexports.getVideoID = str => {\n  if (exports.validateID(str)) {\n    return str;\n  } else if (urlRegex.test(str.trim())) {\n    return exports.getURLVideoID(str);\n  } else {\n    throw Error(`No video id found: ${str}`);\n  }\n};\n\n\n/**\n * Returns true if given id satifies YouTube's id format.\n *\n * @param {string} id\n * @return {boolean}\n */\nconst idRegex = /^[a-zA-Z0-9-_]{11}$/;\nexports.validateID = id => idRegex.test(id.trim());\n\n\n/**\n * Checks wether the input string includes a valid id.\n *\n * @param {string} string\n * @returns {boolean}\n */\nexports.validateURL = string => {\n  try {\n    exports.getURLVideoID(string);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n","const utils = require('./utils');\nconst qs = require('querystring');\nconst { parseTimestamp } = require('m3u8stream');\n\n\nconst BASE_URL = 'https://www.youtube.com/watch?v=';\nconst TITLE_TO_CATEGORY = {\n  song: { name: 'Music', url: 'https://music.youtube.com/' },\n};\n\nconst getText = obj => obj ? obj.runs ? obj.runs[0].text : obj.simpleText : null;\n\n\n/**\n * Get video media.\n *\n * @param {Object} info\n * @returns {Object}\n */\nexports.getMedia = info => {\n  let media = {};\n  let results = [];\n  try {\n    results = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n  } catch (err) {\n    // Do nothing\n  }\n\n  let result = results.find(v => v.videoSecondaryInfoRenderer);\n  if (!result) { return {}; }\n\n  try {\n    let metadataRows =\n      (result.metadataRowContainer || result.videoSecondaryInfoRenderer.metadataRowContainer)\n        .metadataRowContainerRenderer.rows;\n    for (let row of metadataRows) {\n      if (row.metadataRowRenderer) {\n        let title = getText(row.metadataRowRenderer.title).toLowerCase();\n        let contents = row.metadataRowRenderer.contents[0];\n        media[title] = getText(contents);\n        let runs = contents.runs;\n        if (runs && runs[0].navigationEndpoint) {\n          media[`${title}_url`] = new URL(\n            runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n        }\n        if (title in TITLE_TO_CATEGORY) {\n          media.category = TITLE_TO_CATEGORY[title].name;\n          media.category_url = TITLE_TO_CATEGORY[title].url;\n        }\n      } else if (row.richMetadataRowRenderer) {\n        let contents = row.richMetadataRowRenderer.contents;\n        let boxArt = contents\n          .filter(meta => meta.richMetadataRenderer.style === 'RICH_METADATA_RENDERER_STYLE_BOX_ART');\n        for (let { richMetadataRenderer } of boxArt) {\n          let meta = richMetadataRenderer;\n          media.year = getText(meta.subtitle);\n          let type = getText(meta.callToAction).split(' ')[1];\n          media[type] = getText(meta.title);\n          media[`${type}_url`] = new URL(\n            meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n          media.thumbnails = meta.thumbnail.thumbnails;\n        }\n        let topic = contents\n          .filter(meta => meta.richMetadataRenderer.style === 'RICH_METADATA_RENDERER_STYLE_TOPIC');\n        for (let { richMetadataRenderer } of topic) {\n          let meta = richMetadataRenderer;\n          media.category = getText(meta.title);\n          media.category_url = new URL(\n            meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n        }\n      }\n    }\n  } catch (err) {\n    // Do nothing.\n  }\n\n  return media;\n};\n\n\nconst isVerified = badges => !!(badges && badges.find(b => b.metadataBadgeRenderer.tooltip === 'Verified'));\n\n\n/**\n * Get video author.\n *\n * @param {Object} info\n * @returns {Object}\n */\nexports.getAuthor = info => {\n  let channelId, thumbnails = [], subscriberCount, verified = false;\n  try {\n    let results = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    let v = results.find(v2 =>\n      v2.videoSecondaryInfoRenderer &&\n      v2.videoSecondaryInfoRenderer.owner &&\n      v2.videoSecondaryInfoRenderer.owner.videoOwnerRenderer);\n    let videoOwnerRenderer = v.videoSecondaryInfoRenderer.owner.videoOwnerRenderer;\n    channelId = videoOwnerRenderer.navigationEndpoint.browseEndpoint.browseId;\n    thumbnails = videoOwnerRenderer.thumbnail.thumbnails.map(thumbnail => {\n      thumbnail.url = new URL(thumbnail.url, BASE_URL).toString();\n      return thumbnail;\n    });\n    subscriberCount = utils.parseAbbreviatedNumber(getText(videoOwnerRenderer.subscriberCountText));\n    verified = isVerified(videoOwnerRenderer.badges);\n  } catch (err) {\n    // Do nothing.\n  }\n  try {\n    let videoDetails = info.player_response.microformat && info.player_response.microformat.playerMicroformatRenderer;\n    let id = (videoDetails && videoDetails.channelId) || channelId || info.player_response.videoDetails.channelId;\n    let author = {\n      id: id,\n      name: videoDetails ? videoDetails.ownerChannelName : info.player_response.videoDetails.author,\n      user: videoDetails ? videoDetails.ownerProfileUrl.split('/').slice(-1)[0] : null,\n      channel_url: `https://www.youtube.com/channel/${id}`,\n      external_channel_url: videoDetails ? `https://www.youtube.com/channel/${videoDetails.externalChannelId}` : '',\n      user_url: videoDetails ? new URL(videoDetails.ownerProfileUrl, BASE_URL).toString() : '',\n      thumbnails,\n      verified,\n      subscriber_count: subscriberCount,\n    };\n    if (thumbnails.length) {\n      utils.deprecate(author, 'avatar', author.thumbnails[0].url, 'author.avatar', 'author.thumbnails[0].url');\n    }\n    return author;\n  } catch (err) {\n    return {};\n  }\n};\n\nconst parseRelatedVideo = (details, rvsParams) => {\n  if (!details) return;\n  try {\n    let viewCount = getText(details.viewCountText);\n    let shortViewCount = getText(details.shortViewCountText);\n    let rvsDetails = rvsParams.find(elem => elem.id === details.videoId);\n    if (!/^\\d/.test(shortViewCount)) {\n      shortViewCount = (rvsDetails && rvsDetails.short_view_count_text) || '';\n    }\n    viewCount = (/^\\d/.test(viewCount) ? viewCount : shortViewCount).split(' ')[0];\n    let browseEndpoint = details.shortBylineText.runs[0].navigationEndpoint.browseEndpoint;\n    let channelId = browseEndpoint.browseId;\n    let name = getText(details.shortBylineText);\n    let user = (browseEndpoint.canonicalBaseUrl || '').split('/').slice(-1)[0];\n    let video = {\n      id: details.videoId,\n      title: getText(details.title),\n      published: getText(details.publishedTimeText),\n      author: {\n        id: channelId,\n        name,\n        user,\n        channel_url: `https://www.youtube.com/channel/${channelId}`,\n        user_url: `https://www.youtube.com/user/${user}`,\n        thumbnails: details.channelThumbnail.thumbnails.map(thumbnail => {\n          thumbnail.url = new URL(thumbnail.url, BASE_URL).toString();\n          return thumbnail;\n        }),\n        verified: isVerified(details.ownerBadges),\n\n        [Symbol.toPrimitive]() {\n          console.warn(`\\`relatedVideo.author\\` will be removed in a near future release, ` +\n            `use \\`relatedVideo.author.name\\` instead.`);\n          return video.author.name;\n        },\n\n      },\n      short_view_count_text: shortViewCount.split(' ')[0],\n      view_count: viewCount.replace(/,/g, ''),\n      length_seconds: details.lengthText ?\n        Math.floor(parseTimestamp(getText(details.lengthText)) / 1000) :\n        rvsParams && `${rvsParams.length_seconds}`,\n      thumbnails: details.thumbnail.thumbnails,\n      richThumbnails:\n        details.richThumbnail ?\n          details.richThumbnail.movingThumbnailRenderer.movingThumbnailDetails.thumbnails : [],\n      isLive: !!(details.badges && details.badges.find(b => b.metadataBadgeRenderer.label === 'LIVE NOW')),\n    };\n\n    utils.deprecate(video, 'author_thumbnail', video.author.thumbnails[0].url,\n      'relatedVideo.author_thumbnail', 'relatedVideo.author.thumbnails[0].url');\n    utils.deprecate(video, 'ucid', video.author.id, 'relatedVideo.ucid', 'relatedVideo.author.id');\n    utils.deprecate(video, 'video_thumbnail', video.thumbnails[0].url,\n      'relatedVideo.video_thumbnail', 'relatedVideo.thumbnails[0].url');\n    return video;\n  } catch (err) {\n    // Skip.\n  }\n};\n\n/**\n * Get related videos.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\nexports.getRelatedVideos = info => {\n  let rvsParams = [], secondaryResults = [];\n  try {\n    rvsParams = info.response.webWatchNextResponseExtensionData.relatedVideoArgs.split(',').map(e => qs.parse(e));\n  } catch (err) {\n    // Do nothing.\n  }\n  try {\n    secondaryResults = info.response.contents.twoColumnWatchNextResults.secondaryResults.secondaryResults.results;\n  } catch (err) {\n    return [];\n  }\n  let videos = [];\n  for (let result of secondaryResults || []) {\n    let details = result.compactVideoRenderer;\n    if (details) {\n      let video = parseRelatedVideo(details, rvsParams);\n      if (video) videos.push(video);\n    } else {\n      let autoplay = result.compactAutoplayRenderer || result.itemSectionRenderer;\n      if (!autoplay || !Array.isArray(autoplay.contents)) continue;\n      for (let content of autoplay.contents) {\n        let video = parseRelatedVideo(content.compactVideoRenderer, rvsParams);\n        if (video) videos.push(video);\n      }\n    }\n  }\n  return videos;\n};\n\n/**\n * Get like count.\n *\n * @param {Object} info\n * @returns {number}\n */\nexports.getLikes = info => {\n  try {\n    let contents = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    let video = contents.find(r => r.videoPrimaryInfoRenderer);\n    let buttons = video.videoPrimaryInfoRenderer.videoActions.menuRenderer.topLevelButtons;\n    let like = buttons.find(b => b.toggleButtonRenderer &&\n      b.toggleButtonRenderer.defaultIcon.iconType === 'LIKE');\n    return parseInt(like.toggleButtonRenderer.defaultText.accessibility.accessibilityData.label.replace(/\\D+/g, ''));\n  } catch (err) {\n    return null;\n  }\n};\n\n/**\n * Get dislike count.\n *\n * @param {Object} info\n * @returns {number}\n */\nexports.getDislikes = info => {\n  try {\n    let contents = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    let video = contents.find(r => r.videoPrimaryInfoRenderer);\n    let buttons = video.videoPrimaryInfoRenderer.videoActions.menuRenderer.topLevelButtons;\n    let dislike = buttons.find(b => b.toggleButtonRenderer &&\n      b.toggleButtonRenderer.defaultIcon.iconType === 'DISLIKE');\n    return parseInt(dislike.toggleButtonRenderer.defaultText.accessibility.accessibilityData.label.replace(/\\D+/g, ''));\n  } catch (err) {\n    return null;\n  }\n};\n\n/**\n * Cleans up a few fields on `videoDetails`.\n *\n * @param {Object} videoDetails\n * @param {Object} info\n * @returns {Object}\n */\nexports.cleanVideoDetails = (videoDetails, info) => {\n  videoDetails.thumbnails = videoDetails.thumbnail.thumbnails;\n  delete videoDetails.thumbnail;\n  utils.deprecate(videoDetails, 'thumbnail', { thumbnails: videoDetails.thumbnails },\n    'videoDetails.thumbnail.thumbnails', 'videoDetails.thumbnails');\n  videoDetails.description = videoDetails.shortDescription || getText(videoDetails.description);\n  delete videoDetails.shortDescription;\n  utils.deprecate(videoDetails, 'shortDescription', videoDetails.description,\n    'videoDetails.shortDescription', 'videoDetails.description');\n\n  // Use more reliable `lengthSeconds` from `playerMicroformatRenderer`.\n  videoDetails.lengthSeconds =\n    (info.player_response.microformat &&\n    info.player_response.microformat.playerMicroformatRenderer.lengthSeconds) ||\n    info.player_response.videoDetails.lengthSeconds;\n  return videoDetails;\n};\n\n/**\n * Get storyboards info.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\nexports.getStoryboards = info => {\n  const parts = info.player_response.storyboards &&\n    info.player_response.storyboards.playerStoryboardSpecRenderer &&\n    info.player_response.storyboards.playerStoryboardSpecRenderer.spec &&\n    info.player_response.storyboards.playerStoryboardSpecRenderer.spec.split('|');\n\n  if (!parts) return [];\n\n  const url = new URL(parts.shift());\n\n  return parts.map((part, i) => {\n    let [\n      thumbnailWidth,\n      thumbnailHeight,\n      thumbnailCount,\n      columns,\n      rows,\n      interval,\n      nameReplacement,\n      sigh,\n    ] = part.split('#');\n\n    url.searchParams.set('sigh', sigh);\n\n    thumbnailCount = parseInt(thumbnailCount, 10);\n    columns = parseInt(columns, 10);\n    rows = parseInt(rows, 10);\n\n    const storyboardCount = Math.ceil(thumbnailCount / (columns * rows));\n\n    return {\n      templateUrl: url.toString().replace('$L', i).replace('$N', nameReplacement),\n      thumbnailWidth: parseInt(thumbnailWidth, 10),\n      thumbnailHeight: parseInt(thumbnailHeight, 10),\n      thumbnailCount,\n      interval: parseInt(interval, 10),\n      columns,\n      rows,\n      storyboardCount,\n    };\n  });\n};\n\n/**\n * Get chapters info.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\nexports.getChapters = info => {\n  const playerOverlayRenderer = info.response &&\n    info.response.playerOverlays &&\n    info.response.playerOverlays.playerOverlayRenderer;\n  const playerBar = playerOverlayRenderer &&\n    playerOverlayRenderer.decoratedPlayerBarRenderer &&\n    playerOverlayRenderer.decoratedPlayerBarRenderer.decoratedPlayerBarRenderer &&\n    playerOverlayRenderer.decoratedPlayerBarRenderer.decoratedPlayerBarRenderer.playerBar;\n  const markersMap = playerBar &&\n    playerBar.multiMarkersPlayerBarRenderer &&\n    playerBar.multiMarkersPlayerBarRenderer.markersMap;\n  const marker = Array.isArray(markersMap) && markersMap.find(m => m.value && Array.isArray(m.value.chapters));\n  if (!marker) return [];\n  const chapters = marker.value.chapters;\n\n  return chapters.map(chapter => ({\n    title: getText(chapter.chapterRenderer.title),\n    start_time: chapter.chapterRenderer.timeRangeStartMillis / 1000,\n  }));\n};\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst stream_1 = require(\"stream\");\nconst miniget_1 = __importDefault(require(\"miniget\"));\nconst m3u8_parser_1 = __importDefault(require(\"./m3u8-parser\"));\nconst dash_mpd_parser_1 = __importDefault(require(\"./dash-mpd-parser\"));\nconst queue_1 = require(\"./queue\");\nconst parse_time_1 = require(\"./parse-time\");\nconst supportedParsers = {\n    m3u8: m3u8_parser_1.default,\n    'dash-mpd': dash_mpd_parser_1.default,\n};\nlet m3u8stream = ((playlistURL, options = {}) => {\n    const stream = new stream_1.PassThrough({ highWaterMark: options.highWaterMark });\n    const chunkReadahead = options.chunkReadahead || 3;\n    // 20 seconds.\n    const liveBuffer = options.liveBuffer || 20000;\n    const requestOptions = options.requestOptions;\n    const Parser = supportedParsers[options.parser || (/\\.mpd$/.test(playlistURL) ? 'dash-mpd' : 'm3u8')];\n    if (!Parser) {\n        throw TypeError(`parser '${options.parser}' not supported`);\n    }\n    let begin = 0;\n    if (typeof options.begin !== 'undefined') {\n        begin = typeof options.begin === 'string' ?\n            parse_time_1.humanStr(options.begin) :\n            Math.max(options.begin - liveBuffer, 0);\n    }\n    const forwardEvents = (req) => {\n        for (let event of ['abort', 'request', 'response', 'redirect', 'retry', 'reconnect']) {\n            req.on(event, stream.emit.bind(stream, event));\n        }\n    };\n    let currSegment;\n    const streamQueue = new queue_1.Queue((req, callback) => {\n        currSegment = req;\n        // Count the size manually, since the `content-length` header is not\n        // always there.\n        let size = 0;\n        req.on('data', (chunk) => size += chunk.length);\n        req.pipe(stream, { end: false });\n        req.on('end', () => callback(null, size));\n    }, { concurrency: 1 });\n    let segmentNumber = 0;\n    let downloaded = 0;\n    const requestQueue = new queue_1.Queue((segment, callback) => {\n        let reqOptions = Object.assign({}, requestOptions);\n        if (segment.range) {\n            reqOptions.headers = Object.assign({}, reqOptions.headers, {\n                Range: `bytes=${segment.range.start}-${segment.range.end}`,\n            });\n        }\n        let req = miniget_1.default(new URL(segment.url, playlistURL).toString(), reqOptions);\n        req.on('error', callback);\n        forwardEvents(req);\n        streamQueue.push(req, (_, size) => {\n            downloaded += +size;\n            stream.emit('progress', {\n                num: ++segmentNumber,\n                size: size,\n                duration: segment.duration,\n                url: segment.url,\n            }, requestQueue.total, downloaded);\n            callback(null);\n        });\n    }, { concurrency: chunkReadahead });\n    const onError = (err) => {\n        stream.emit('error', err);\n        // Stop on any error.\n        stream.end();\n    };\n    // When to look for items again.\n    let refreshThreshold;\n    let minRefreshTime;\n    let refreshTimeout;\n    let fetchingPlaylist = true;\n    let ended = false;\n    let isStatic = false;\n    let lastRefresh;\n    const onQueuedEnd = (err) => {\n        currSegment = null;\n        if (err) {\n            onError(err);\n        }\n        else if (!fetchingPlaylist && !ended && !isStatic &&\n            requestQueue.tasks.length + requestQueue.active <= refreshThreshold) {\n            let ms = Math.max(0, minRefreshTime - (Date.now() - lastRefresh));\n            fetchingPlaylist = true;\n            refreshTimeout = setTimeout(refreshPlaylist, ms);\n        }\n        else if ((ended || isStatic) &&\n            !requestQueue.tasks.length && !requestQueue.active) {\n            stream.end();\n        }\n    };\n    let currPlaylist;\n    let lastSeq;\n    let starttime = 0;\n    const refreshPlaylist = () => {\n        lastRefresh = Date.now();\n        currPlaylist = miniget_1.default(playlistURL, requestOptions);\n        currPlaylist.on('error', onError);\n        forwardEvents(currPlaylist);\n        const parser = currPlaylist.pipe(new Parser(options.id));\n        parser.on('starttime', (a) => {\n            if (starttime) {\n                return;\n            }\n            starttime = a;\n            if (typeof options.begin === 'string' && begin >= 0) {\n                begin += starttime;\n            }\n        });\n        parser.on('endlist', () => { isStatic = true; });\n        parser.on('endearly', currPlaylist.unpipe.bind(currPlaylist, parser));\n        let addedItems = [];\n        const addItem = (item) => {\n            if (!item.init) {\n                if (item.seq <= lastSeq) {\n                    return;\n                }\n                lastSeq = item.seq;\n            }\n            begin = item.time;\n            requestQueue.push(item, onQueuedEnd);\n            addedItems.push(item);\n        };\n        let tailedItems = [], tailedItemsDuration = 0;\n        parser.on('item', (item) => {\n            let timedItem = Object.assign({ time: starttime }, item);\n            if (begin <= timedItem.time) {\n                addItem(timedItem);\n            }\n            else {\n                tailedItems.push(timedItem);\n                tailedItemsDuration += timedItem.duration;\n                // Only keep the last `liveBuffer` of items.\n                while (tailedItems.length > 1 &&\n                    tailedItemsDuration - tailedItems[0].duration > liveBuffer) {\n                    const lastItem = tailedItems.shift();\n                    tailedItemsDuration -= lastItem.duration;\n                }\n            }\n            starttime += timedItem.duration;\n        });\n        parser.on('end', () => {\n            currPlaylist = null;\n            // If we are too ahead of the stream, make sure to get the\n            // latest available items with a small buffer.\n            if (!addedItems.length && tailedItems.length) {\n                tailedItems.forEach(item => { addItem(item); });\n            }\n            // Refresh the playlist when remaining segments get low.\n            refreshThreshold = Math.max(1, Math.ceil(addedItems.length * 0.01));\n            // Throttle refreshing the playlist by looking at the duration\n            // of live items added on this refresh.\n            minRefreshTime =\n                addedItems.reduce((total, item) => item.duration + total, 0);\n            fetchingPlaylist = false;\n            onQueuedEnd(null);\n        });\n    };\n    refreshPlaylist();\n    stream.end = () => {\n        ended = true;\n        streamQueue.die();\n        requestQueue.die();\n        clearTimeout(refreshTimeout);\n        currPlaylist === null || currPlaylist === void 0 ? void 0 : currPlaylist.destroy();\n        currSegment === null || currSegment === void 0 ? void 0 : currSegment.destroy();\n        stream_1.PassThrough.prototype.end.call(stream, null);\n        return stream;\n    };\n    return stream;\n});\nm3u8stream.parseTimestamp = parse_time_1.humanStr;\nmodule.exports = m3u8stream;\n//# sourceMappingURL=index.js.map",null,"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Queue = void 0;\nclass Queue {\n    /**\n     * A really simple queue with concurrency.\n     *\n     * @param {Function} worker\n     * @param {Object} options\n     * @param {!number} options.concurrency\n     */\n    constructor(worker, options = {}) {\n        this._worker = worker;\n        this._concurrency = options.concurrency || 1;\n        this.tasks = [];\n        this.total = 0;\n        this.active = 0;\n    }\n    /**\n     * Push a task to the queue.\n     *\n     *  @param {T} item\n     *  @param {!Function} callback\n     */\n    push(item, callback) {\n        this.tasks.push({ item, callback });\n        this.total++;\n        this._next();\n    }\n    /**\n     * Process next job in queue.\n     */\n    _next() {\n        if (this.active >= this._concurrency || !this.tasks.length) {\n            return;\n        }\n        const { item, callback } = this.tasks.shift();\n        let callbackCalled = false;\n        this.active++;\n        this._worker(item, (err, result) => {\n            if (callbackCalled) {\n                return;\n            }\n            this.active--;\n            callbackCalled = true;\n            callback === null || callback === void 0 ? void 0 : callback(err, result);\n            this._next();\n        });\n    }\n    /**\n     * Stops processing queued jobs.\n     */\n    die() {\n        this.tasks = [];\n    }\n}\nexports.Queue = Queue;\n//# sourceMappingURL=queue.js.map",null,"const querystring = require('querystring');\nconst Cache = require('./cache');\nconst utils = require('./utils');\nconst vm = require('vm');\n\n// A shared cache to keep track of html5player js functions.\nexports.cache = new Cache();\n\n/**\n * Extract signature deciphering and n parameter transform functions from html5player file.\n *\n * @param {string} html5playerfile\n * @param {Object} options\n * @returns {Promise<Array.<string>>}\n */\nexports.getFunctions = (html5playerfile, options) => exports.cache.getOrSet(html5playerfile, async() => {\n  const body = await utils.exposedMiniget(html5playerfile, options).text();\n  const functions = exports.extractFunctions(body);\n  if (!functions || !functions.length) {\n    throw Error('Could not extract functions');\n  }\n  exports.cache.set(html5playerfile, functions);\n  return functions;\n});\n\n/**\n * Extracts the actions that should be taken to decipher a signature\n * and tranform the n parameter\n *\n * @param {string} body\n * @returns {Array.<string>}\n */\nexports.extractFunctions = body => {\n  const functions = [];\n  const extractManipulations = caller => {\n    const functionName = utils.between(caller, `a=a.split(\"\");`, `.`);\n    if (!functionName) return '';\n    const functionStart = `var ${functionName}={`;\n    const ndx = body.indexOf(functionStart);\n    if (ndx < 0) return '';\n    const subBody = body.slice(ndx + functionStart.length - 1);\n    return `var ${functionName}=${utils.cutAfterJS(subBody)}`;\n  };\n  const extractDecipher = () => {\n    const functionName = utils.between(body, `a.set(\"alr\",\"yes\");c&&(c=`, `(decodeURIC`);\n    if (functionName && functionName.length) {\n      const functionStart = `${functionName}=function(a)`;\n      const ndx = body.indexOf(functionStart);\n      if (ndx >= 0) {\n        const subBody = body.slice(ndx + functionStart.length);\n        let functionBody = `var ${functionStart}${utils.cutAfterJS(subBody)}`;\n        functionBody = `${extractManipulations(functionBody)};${functionBody};${functionName}(sig);`;\n        functions.push(functionBody);\n      }\n    }\n  };\n  const extractNCode = () => {\n    let functionName = utils.between(body, `&&(b=a.get(\"n\"))&&(b=`, `(b)`);\n    if (functionName.includes('[')) functionName = utils.between(body, `${functionName.split('[')[0]}=[`, `]`);\n    if (functionName && functionName.length) {\n      const functionStart = `${functionName}=function(a)`;\n      const ndx = body.indexOf(functionStart);\n      if (ndx >= 0) {\n        const subBody = body.slice(ndx + functionStart.length);\n        const functionBody = `var ${functionStart}${utils.cutAfterJS(subBody)};${functionName}(ncode);`;\n        functions.push(functionBody);\n      }\n    }\n  };\n  extractDecipher();\n  extractNCode();\n  return functions;\n};\n\n/**\n * Apply decipher and n-transform to individual format\n *\n * @param {Object} format\n * @param {vm.Script} decipherScript\n * @param {vm.Script} nTransformScript\n */\nexports.setDownloadURL = (format, decipherScript, nTransformScript) => {\n  const decipher = url => {\n    const args = querystring.parse(url);\n    if (!args.s || !decipherScript) return args.url;\n    const components = new URL(decodeURIComponent(args.url));\n    components.searchParams.set(args.sp ? args.sp : 'signature',\n      decipherScript.runInNewContext({ sig: decodeURIComponent(args.s) }));\n    return components.toString();\n  };\n  const ncode = url => {\n    const components = new URL(decodeURIComponent(url));\n    const n = components.searchParams.get('n');\n    if (!n || !nTransformScript) return url;\n    components.searchParams.set('n', nTransformScript.runInNewContext({ ncode: n }));\n    return components.toString();\n  };\n  const cipher = !format.url;\n  const url = format.url || format.signatureCipher || format.cipher;\n  format.url = cipher ? ncode(decipher(url)) : ncode(url);\n  delete format.signatureCipher;\n  delete format.cipher;\n};\n\n/**\n * Applies decipher and n parameter transforms to all format URL's.\n *\n * @param {Array.<Object>} formats\n * @param {string} html5player\n * @param {Object} options\n */\nexports.decipherFormats = async(formats, html5player, options) => {\n  let decipheredFormats = {};\n  let functions = await exports.getFunctions(html5player, options);\n  const decipherScript = functions.length ? new vm.Script(functions[0]) : null;\n  const nTransformScript = functions.length > 1 ? new vm.Script(functions[1]) : null;\n  formats.forEach(format => {\n    exports.setDownloadURL(format, decipherScript, nTransformScript);\n    decipheredFormats[format.url] = format;\n  });\n  return decipheredFormats;\n};\n","const { setTimeout } = require('timers');\n\n// A cache that expires.\nmodule.exports = class Cache extends Map {\n  constructor(timeout = 1000) {\n    super();\n    this.timeout = timeout;\n  }\n  set(key, value) {\n    if (this.has(key)) {\n      clearTimeout(super.get(key).tid);\n    }\n    super.set(key, {\n      tid: setTimeout(this.delete.bind(this, key), this.timeout).unref(),\n      value,\n    });\n  }\n  get(key) {\n    let entry = super.get(key);\n    if (entry) {\n      return entry.value;\n    }\n    return null;\n  }\n  getOrSet(key, fn) {\n    if (this.has(key)) {\n      return this.get(key);\n    } else {\n      let value = fn();\n      this.set(key, value);\n      (async() => {\n        try {\n          await value;\n        } catch (err) {\n          this.delete(key);\n        }\n      })();\n      return value;\n    }\n  }\n  delete(key) {\n    let entry = super.get(key);\n    if (entry) {\n      clearTimeout(entry.tid);\n      super.delete(key);\n    }\n  }\n  clear() {\n    for (let entry of this.values()) {\n      clearTimeout(entry.tid);\n    }\n    super.clear();\n  }\n};\n","module.exports = process.env.FLUENTFFMPEG_COV ? require('./lib-cov/fluent-ffmpeg') : require('./lib/fluent-ffmpeg');\n","'use strict'\n\nconst timeFormat = require('hh-mm-ss')\n\nmodule.exports = (onProgress, durationMs) => {\n  return (event) => {\n    let progress = 0\n\n    try {\n      const timestamp = timeFormat.toMs(event.timemark)\n      progress = timestamp / durationMs\n    } catch (err) { }\n\n    if (isNaN(progress) && !isNaN(event.percent)) {\n      progress = event.percent / 100\n    }\n\n    if (!isNaN(progress)) {\n      progress = Math.max(0, Math.min(1, progress))\n      onProgress(progress, event)\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = {\n  fromMs,\n  fromS,\n  toMs,\n  toS\n}\n\nconst zeroFill = require('zero-fill')\n\n// Time units with their corresponding values in miliseconds\nconst HOUR = 3600000\nconst MINUTE = 60000\nconst SECOND = 1000\n\nconst TIME_FORMAT_ERRMSG = 'Time format error'\n\n// =============================================================================\n// Export functions\n// =============================================================================\n\nfunction fromMs (ms, format = 'mm:ss') {\n  if (typeof ms !== 'number' || Number.isNaN(ms)) {\n    throw new Error('NaN error')\n  }\n\n  let absMs = Math.abs(ms)\n\n  let negative = (ms < 0)\n  let hours = Math.floor(absMs / HOUR)\n  let minutes = Math.floor(absMs % HOUR / MINUTE)\n  let seconds = Math.floor(absMs % MINUTE / SECOND)\n  let miliseconds = Math.floor(absMs % SECOND)\n\n  return formatTime({\n    negative, hours, minutes, seconds, miliseconds\n  }, format)\n}\n\nfunction fromS (s, format = 'mm:ss') {\n  if (typeof s !== 'number' || Number.isNaN(s)) {\n    throw new Error('NaN error')\n  }\n\n  let ms = s * SECOND\n\n  return fromMs(ms, format)\n}\n\nfunction toMs (time, format = 'mm:ss') {\n  let re\n\n  if (['mm:ss', 'mm:ss.sss', 'hh:mm:ss', 'hh:mm:ss.sss'].includes(format)) {\n    re = /^(-)?(?:(\\d\\d+):)?(\\d\\d):(\\d\\d)(\\.\\d+)?$/\n  } else if (format === 'hh:mm') {\n    re = /^(-)?(\\d\\d):(\\d\\d)(?::(\\d\\d)(?:(\\.\\d+))?)?$/\n  } else {\n    throw new Error(TIME_FORMAT_ERRMSG)\n  }\n\n  let result = re.exec(time)\n  if (!result) throw new Error()\n\n  let negative = result[1] === '-'\n  let hours = result[2] | 0\n  let minutes = result[3] | 0\n  let seconds = result[4] | 0\n  let miliseconds = Math.floor(1000 * result[5] | 0)\n\n  if (minutes > 60 || seconds > 60) {\n    throw new Error()\n  }\n\n  return (negative ? -1 : 1) * (\n    hours * HOUR + minutes * MINUTE + seconds * SECOND + miliseconds\n  )\n}\n\nfunction toS (time, format = 'mm:ss') {\n  let ms = toMs(time, format)\n  return Math.floor(ms / SECOND)\n}\n\n// =============================================================================\n// Utility functions\n// =============================================================================\n\nfunction formatTime (time, format) {\n  let showMs\n  let showSc\n  let showHr\n\n  switch (format.toLowerCase()) {\n    case 'hh:mm:ss.sss':\n      showMs = true\n      showSc = true\n      showHr = true\n      break\n    case 'hh:mm:ss':\n      showMs = !(!time.miliseconds)\n      showSc = true\n      showHr = true\n      break\n    case 'hh:mm':\n      showMs = !(!time.miliseconds)\n      showSc = showMs || !(!time.seconds)\n      showHr = true\n      break\n    case 'mm:ss':\n      showMs = !(!time.miliseconds)\n      showSc = true\n      showHr = !(!time.hours)\n      break\n    case 'mm:ss.sss':\n      showMs = true\n      showSc = true\n      showHr = !(!time.hours)\n      break\n    default:\n      throw new Error(TIME_FORMAT_ERRMSG)\n  }\n\n  let hh = zeroFill(2, time.hours)\n  let mm = zeroFill(2, time.minutes)\n  let ss = zeroFill(2, time.seconds)\n  let sss = zeroFill(3, time.miliseconds)\n\n  return (time.negative ? '-' : '') + (showHr ? (\n    showMs ? `${hh}:${mm}:${ss}.${sss}` : showSc ? `${hh}:${mm}:${ss}` : `${hh}:${mm}`\n  ) : (\n    showMs ? `${mm}:${ss}.${sss}` : `${mm}:${ss}`\n  ))\n}\n","/*! zero-fill. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/**\n * Given a number, return a zero-filled string.\n * From http://stackoverflow.com/questions/1267283/\n * @param  {number} width\n * @param  {number} number\n * @return {string}\n */\nmodule.exports = function zeroFill (width, number, pad) {\n  if (number === undefined) {\n    return function (number, pad) {\n      return zeroFill(width, number, pad)\n    }\n  }\n  if (pad === undefined) pad = '0'\n  width -= number.toString().length\n  if (width > 0) return new Array(width + (/\\./.test(number) ? 2 : 1)).join(pad) + number\n  return number + ''\n}\n","module.exports=Max;"],"names":[],"version":3,"file":"main.js.map"}